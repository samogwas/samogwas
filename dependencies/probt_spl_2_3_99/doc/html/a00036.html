<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ProBT: plComputableObject Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ProBT
   &#160;<span id="projectnumber">2.3.99</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="a00452.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">plComputableObject Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A <em>computable</em> <em>object</em> on <img class="formulaInl" alt="$ \omega $" src="form_40.png"/> is defined as an abstract object provided with a probability measure function <em>compute</em>( <img class="formulaInl" alt="$ \omega $" src="form_40.png"/>).  
 <a href="a00036.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for plComputableObject:</div>
<div class="dyncontent">
<div class="center"><img src="a00453.png" border="0" usemap="#pl_computable_object_inherit__map" alt="Inheritance graph"/></div>
<map name="pl_computable_object_inherit__map" id="pl_computable_object_inherit__map">
<area shape="rect" id="node3" href="a00024.html" title="plCndDistribution is the base class of all conditional probability (and density) distributions like P..." alt="" coords="315,487,437,513"/><area shape="rect" id="node23" href="a00049.html" title="The plDistribution class is the base class of all non&#45;conditional probability (and density) distribut..." alt="" coords="327,1373,425,1400"/><area shape="rect" id="node2" href="a00123.html" title="Used as the base class of all ProBT API objects. " alt="" coords="6,943,77,969"/><area shape="rect" id="node4" href="a00020.html" title="The plCndAnonymousDistribution class implements a conditional distribution having the user&#39;s external..." alt="" coords="486,5,677,32"/><area shape="rect" id="node5" href="a00021.html" title="This class implements conditional Beta distributions. " alt="" coords="540,56,623,83"/><area shape="rect" id="node6" href="a00022.html" title="Conditional Binomial distribution on one&#45;dimensional space. " alt="" coords="528,107,635,133"/><area shape="rect" id="node7" href="a00023.html" title="The plCndDeterministic class implements deterministic dependencies using user&#45;provided functions..." alt="" coords="515,157,648,184"/><area shape="rect" id="node8" href="a00025.html" title="This class implements conditional Exponential distributions. " alt="" coords="519,208,643,235"/><area shape="rect" id="node9" href="a00026.html" title="This class implements conditional Gamma distributions. " alt="" coords="530,259,633,285"/><area shape="rect" id="node10" href="a00027.html" title="Conditional distribution as returned by asking a question to a plJunctionTree. " alt="" coords="515,309,648,336"/><area shape="rect" id="node11" href="a00029.html" title="This class implements conditional lognormal distributions. " alt="" coords="522,360,641,387"/><area shape="rect" id="node12" href="a00030.html" title="This class implements conditional normal distributions on one or multiple dimensional spaces..." alt="" coords="532,411,631,437"/><area shape="rect" id="node13" href="a00031.html" title="Conditional Poisson distribution on one&#45;dimensional space. " alt="" coords="530,461,633,488"/><area shape="rect" id="node14" href="a00032.html" title="This class implements conditional uniform distributions on one dimensional space. ..." alt="" coords="530,512,633,539"/><area shape="rect" id="node15" href="a00033.html" title="This class allows defining an unknown distribution on a set of variables left knowing an other set of..." alt="" coords="526,563,637,589"/><area shape="rect" id="node16" href="a00034.html" title="This class implements conditional Von Mises distributions. " alt="" coords="524,613,639,640"/><area shape="rect" id="node17" href="a00035.html" title="This class implements conditional Weibull distributions. " alt="" coords="532,664,631,691"/><area shape="rect" id="node18" href="a00050.html" title="A plDistributionTable is a way to define a conditional distribution from a set of Computable Objects ..." alt="" coords="516,715,647,741"/><area shape="rect" id="node19" href="a00077.html" title="The plIneqConstraint class defines a conditional distribution representing an constraint_size&#45;dimensi..." alt="" coords="523,765,640,792"/><area shape="rect" id="node20" href="a00108.html" title="This implements the computation part of the linear regression model (aka Linear Gaussian). " alt="" coords="515,816,648,843"/><area shape="rect" id="node21" href="a00120.html" title="This class implements the computation part of the NoisyOR discrimination model. " alt="" coords="538,867,625,893"/><area shape="rect" id="node22" href="a00136.html" title="This implements the computation part of the Softmax (aka multinomial logistic or multinomial logit) r..." alt="" coords="541,917,622,944"/><area shape="rect" id="node24" href="a00003.html" title="The plAnonymousDistribution class implements a distribution having the user external function functio..." alt="" coords="498,968,665,995"/><area shape="rect" id="node25" href="a00017.html" title="This class implements the Beta distribution. " alt="" coords="552,1019,611,1045"/><area shape="rect" id="node26" href="a00018.html" title="This class implements the binomial distribution. " alt="" coords="540,1069,623,1096"/><area shape="rect" id="node27" href="a00045.html" title="The plDeterministic class implements the &quot;Dirac&quot; or &quot;Delta&quot; function. " alt="" coords="527,1120,636,1147"/><area shape="rect" id="node28" href="a00046.html" title="The Dirichlet distribution. " alt="" coords="541,1171,621,1197"/><area shape="rect" id="node29" href="a00064.html" title="This class implements the Exponential distribution. " alt="" coords="531,1221,631,1248"/><area shape="rect" id="node30" href="a00074.html" title="This class implements the Gamma distribution. " alt="" coords="542,1272,621,1299"/><area shape="rect" id="node31" href="a00079.html" title="The plJointDistribution class is used to describe a probabilistic model by providing a decomposition ..." alt="" coords="518,1323,645,1349"/><area shape="rect" id="node32" href="a00080.html" title="Non&#45;conditional distribution as returned by asking a question to a plJunctionTree. " alt="" coords="527,1373,636,1400"/><area shape="rect" id="node33" href="a00109.html" title="A plLogNormal is a one&#45;dimensional probability distribution on a single continuous variable..." alt="" coords="534,1424,629,1451"/><area shape="rect" id="node34" href="a00112.html" title="plMutable\&lt; plDistribution \&gt;" alt="" coords="492,1475,671,1501"/><area shape="rect" id="node35" href="a00122.html" title="This class implements Normal distributions on one or multiple dimensional space. " alt="" coords="544,1525,619,1552"/><area shape="rect" id="node36" href="a00127.html" title="This class implements the Poisson distribution. " alt="" coords="542,1576,621,1603"/><area shape="rect" id="node37" href="a00129.html" title="A plProbTable represents a table of probability values on discrete and/or continuous&#45;by&#45;interval vari..." alt="" coords="536,1627,627,1653"/><area shape="rect" id="node38" href="a00144.html" title="The plUniform class implements 1&#45;dimensional uniform distributions. " alt="" coords="542,1677,621,1704"/><area shape="rect" id="node39" href="a00145.html" title="The plUnknown class permits to define an unknown distribution on a set of variables variable..." alt="" coords="538,1728,625,1755"/><area shape="rect" id="node40" href="a00152.html" title="This class implements Von Mises distribution. " alt="" coords="536,1779,627,1805"/><area shape="rect" id="node41" href="a00153.html" title="This class implements the Weibull distribution. " alt="" coords="544,1829,619,1856"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for plComputableObject:</div>
<div class="dyncontent">
<div class="center"><img src="a00454.png" border="0" usemap="#pl_computable_object_coll__map" alt="Collaboration graph"/></div>
<map name="pl_computable_object_coll__map" id="pl_computable_object_coll__map">
<area shape="rect" id="node2" href="a00123.html" title="Used as the base class of all ProBT API objects. " alt="" coords="39,5,109,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac4a2eecd3f7b7ba2e0dedc90e97d9ec3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#ac4a2eecd3f7b7ba2e0dedc90e97d9ec3">plComputableObject</a> ()</td></tr>
<tr class="memdesc:ac4a2eecd3f7b7ba2e0dedc90e97d9ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="#ac4a2eecd3f7b7ba2e0dedc90e97d9ec3">More...</a><br/></td></tr>
<tr class="separator:ac4a2eecd3f7b7ba2e0dedc90e97d9ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201dc2483848f17a1edb7f41727684dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a201dc2483848f17a1edb7f41727684dd">plComputableObject</a> (const <a class="el" href="a00037.html">plComputableObjectList</a> &amp;func_lis)</td></tr>
<tr class="memdesc:a201dc2483848f17a1edb7f41727684dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a conditional or non conditional distribution as a product of a conditional and non conditional distributions.  <a href="#a201dc2483848f17a1edb7f41727684dd">More...</a><br/></td></tr>
<tr class="separator:a201dc2483848f17a1edb7f41727684dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb3cea71bb0cf291c660603df7ed78f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedb3cea71bb0cf291c660603df7ed78f"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#aedb3cea71bb0cf291c660603df7ed78f">~plComputableObject</a> ()</td></tr>
<tr class="memdesc:aedb3cea71bb0cf291c660603df7ed78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the function. <br/></td></tr>
<tr class="separator:aedb3cea71bb0cf291c660603df7ed78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91b5ec4f63bdcd75d635fbcc16f0874"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae91b5ec4f63bdcd75d635fbcc16f0874"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#ae91b5ec4f63bdcd75d635fbcc16f0874">plComputableObject</a> (const <a class="el" href="a00036.html">plComputableObject</a> &amp;)</td></tr>
<tr class="memdesc:ae91b5ec4f63bdcd75d635fbcc16f0874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr class="separator:ae91b5ec4f63bdcd75d635fbcc16f0874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3639141f807261b60485185899614eb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3639141f807261b60485185899614eb0"></a>
<a class="el" href="a00036.html">plComputableObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a3639141f807261b60485185899614eb0">operator=</a> (const <a class="el" href="a00036.html">plComputableObject</a> &amp;)</td></tr>
<tr class="memdesc:a3639141f807261b60485185899614eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br/></td></tr>
<tr class="separator:a3639141f807261b60485185899614eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99dc707a8567c7a4c0db54e312755436"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99dc707a8567c7a4c0db54e312755436"></a>
<a class="el" href="a00036.html">plComputableObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a99dc707a8567c7a4c0db54e312755436">assign_from</a> (const <a class="el" href="a00036.html">plComputableObject</a> &amp;other)</td></tr>
<tr class="memdesc:a99dc707a8567c7a4c0db54e312755436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="a00036.html#a3639141f807261b60485185899614eb0" title="Assignment operator. ">operator=()</a> <br/></td></tr>
<tr class="separator:a99dc707a8567c7a4c0db54e312755436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99000b50e1392f67bca21a3f250a4278"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99000b50e1392f67bca21a3f250a4278"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a99000b50e1392f67bca21a3f250a4278">get_print_name</a> () const </td></tr>
<tr class="memdesc:a99000b50e1392f67bca21a3f250a4278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the distribution print name. <br/></td></tr>
<tr class="separator:a99000b50e1392f67bca21a3f250a4278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2ffd5267d64569f1f2c42fb1aa9d36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf2ffd5267d64569f1f2c42fb1aa9d36"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#aaf2ffd5267d64569f1f2c42fb1aa9d36">is</a> (const <a class="el" href="a00278.html#a9edc51edaa4a10e2ecfea399e94bfd27">plComputableObjectType</a> &amp;type) const </td></tr>
<tr class="memdesc:aaf2ffd5267d64569f1f2c42fb1aa9d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <em>true</em> if the <a class="el" href="a00036.html" title="A computable object on  is defined as an abstract object provided with a probability measure function...">plComputableObject</a> is of type <em>type</em>. <br/></td></tr>
<tr class="separator:aaf2ffd5267d64569f1f2c42fb1aa9d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6c2fecec0175dbc3c2695336f651ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c6c2fecec0175dbc3c2695336f651ec"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a1c6c2fecec0175dbc3c2695336f651ec">is_some_on_signature</a> (const <a class="el" href="a00278.html#a89912cc6dac96ce67ffaca769ef25d44">plSignature</a> &amp;prototype_signature) const </td></tr>
<tr class="memdesc:a1c6c2fecec0175dbc3c2695336f651ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <em>true</em> if the plComputableObjectType is at least one of the types described by <em>prototype_signature</em>. <br/></td></tr>
<tr class="separator:a1c6c2fecec0175dbc3c2695336f651ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05d53d474ca8282099606f8246dd964"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#ad05d53d474ca8282099606f8246dd964">is_conditional</a> () const </td></tr>
<tr class="memdesc:ad05d53d474ca8282099606f8246dd964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the distribution really is conditional.  <a href="#ad05d53d474ca8282099606f8246dd964">More...</a><br/></td></tr>
<tr class="separator:ad05d53d474ca8282099606f8246dd964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8890f32f991d15122120dbc14d6fe9c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a8890f32f991d15122120dbc14d6fe9c6">is_empty</a> () const </td></tr>
<tr class="memdesc:a8890f32f991d15122120dbc14d6fe9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the object is default-constructed (as opposed to full-initialized).  <a href="#a8890f32f991d15122120dbc14d6fe9c6">More...</a><br/></td></tr>
<tr class="separator:a8890f32f991d15122120dbc14d6fe9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e46fb956c7fedf0b50e45315e3420c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62e46fb956c7fedf0b50e45315e3420c"></a>
const <a class="el" href="a00278.html#a89912cc6dac96ce67ffaca769ef25d44">plSignature</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a62e46fb956c7fedf0b50e45315e3420c">get_signature</a> () const </td></tr>
<tr class="memdesc:a62e46fb956c7fedf0b50e45315e3420c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the object full signature (e.g its actual type and parent classes) <br/></td></tr>
<tr class="separator:a62e46fb956c7fedf0b50e45315e3420c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd05a723760fa24a64202b188726b6a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00278.html#a9edc51edaa4a10e2ecfea399e94bfd27">plComputableObjectType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#afd05a723760fa24a64202b188726b6a6">get_computable_object_type</a> () const </td></tr>
<tr class="memdesc:afd05a723760fa24a64202b188726b6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the object actual (most derived) type.  <a href="#afd05a723760fa24a64202b188726b6a6">More...</a><br/></td></tr>
<tr class="separator:afd05a723760fa24a64202b188726b6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3318e9b147450d0159587e4371ab708c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00150.html">plVariablesConjunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a3318e9b147450d0159587e4371ab708c">get_variables</a> () const </td></tr>
<tr class="memdesc:a3318e9b147450d0159587e4371ab708c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all the variables (left and right) of the computable object.  <a href="#a3318e9b147450d0159587e4371ab708c">More...</a><br/></td></tr>
<tr class="separator:a3318e9b147450d0159587e4371ab708c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11292d79d09bf7af0136db1ecb2fdcef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00150.html">plVariablesConjunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a11292d79d09bf7af0136db1ecb2fdcef">get_left_variables</a> () const </td></tr>
<tr class="memdesc:a11292d79d09bf7af0136db1ecb2fdcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the left variables of the computable object.  <a href="#a11292d79d09bf7af0136db1ecb2fdcef">More...</a><br/></td></tr>
<tr class="separator:a11292d79d09bf7af0136db1ecb2fdcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21dc5841ed3c12c2638feab0b9fd4fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00150.html">plVariablesConjunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#ac21dc5841ed3c12c2638feab0b9fd4fd">get_right_variables</a> () const </td></tr>
<tr class="memdesc:ac21dc5841ed3c12c2638feab0b9fd4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the right variables of the computable object.  <a href="#ac21dc5841ed3c12c2638feab0b9fd4fd">More...</a><br/></td></tr>
<tr class="separator:ac21dc5841ed3c12c2638feab0b9fd4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac875aa862861dae7c5e33e4acc602dda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#ac875aa862861dae7c5e33e4acc602dda">compute</a> (const <a class="el" href="a00147.html">plValues</a> &amp;values) const </td></tr>
<tr class="memdesc:ac875aa862861dae7c5e33e4acc602dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of the function for the input parameter <em>values</em>.  <a href="#ac875aa862861dae7c5e33e4acc602dda">More...</a><br/></td></tr>
<tr class="separator:ac875aa862861dae7c5e33e4acc602dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2aec9ed79e39e56351684f6f9a0ce4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac2aec9ed79e39e56351684f6f9a0ce4"></a>
<a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#aac2aec9ed79e39e56351684f6f9a0ce4">compute_log</a> (const <a class="el" href="a00147.html">plValues</a> &amp;values) const </td></tr>
<tr class="memdesc:aac2aec9ed79e39e56351684f6f9a0ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the logarithm value of the function for the input parameter <em>values</em>. <br/></td></tr>
<tr class="separator:aac2aec9ed79e39e56351684f6f9a0ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e391b00c9279cf4fb2349b27472688"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#aa9e391b00c9279cf4fb2349b27472688">compute</a> (const int *values) const </td></tr>
<tr class="memdesc:aa9e391b00c9279cf4fb2349b27472688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of the function for the array input parameter <em>values</em>.  <a href="#aa9e391b00c9279cf4fb2349b27472688">More...</a><br/></td></tr>
<tr class="separator:aa9e391b00c9279cf4fb2349b27472688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fcc65c43c3e92b3230634c7a16b80d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a21fcc65c43c3e92b3230634c7a16b80d">compute</a> (const unsigned int *values) const </td></tr>
<tr class="memdesc:a21fcc65c43c3e92b3230634c7a16b80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of the function for the array input parameter <em>values</em>.  <a href="#a21fcc65c43c3e92b3230634c7a16b80d">More...</a><br/></td></tr>
<tr class="separator:a21fcc65c43c3e92b3230634c7a16b80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e87f4251e574b8c057958f33245001"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#ac7e87f4251e574b8c057958f33245001">compute</a> (const float *values) const </td></tr>
<tr class="memdesc:ac7e87f4251e574b8c057958f33245001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of the function for the array input parameter <em>values</em>.  <a href="#ac7e87f4251e574b8c057958f33245001">More...</a><br/></td></tr>
<tr class="separator:ac7e87f4251e574b8c057958f33245001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c8ffca06205ab9de5996c86012391d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#ab3c8ffca06205ab9de5996c86012391d">compute</a> (const double *values) const </td></tr>
<tr class="memdesc:ab3c8ffca06205ab9de5996c86012391d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of the function for the array input parameter <em>values</em>.  <a href="#ab3c8ffca06205ab9de5996c86012391d">More...</a><br/></td></tr>
<tr class="separator:ab3c8ffca06205ab9de5996c86012391d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec305b102d68327b6430269d818019d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ec305b102d68327b6430269d818019d"></a>
<a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a6ec305b102d68327b6430269d818019d">compute_log</a> (const int *values) const </td></tr>
<tr class="memdesc:a6ec305b102d68327b6430269d818019d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the logarithm value of the function for the input parameter <em>values</em>. <br/></td></tr>
<tr class="separator:a6ec305b102d68327b6430269d818019d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2ac9c22301f44b2324f886f144ac05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd2ac9c22301f44b2324f886f144ac05"></a>
<a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#abd2ac9c22301f44b2324f886f144ac05">compute_log</a> (const unsigned int *values) const </td></tr>
<tr class="memdesc:abd2ac9c22301f44b2324f886f144ac05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the logarithm value of the function for the input parameter <em>values</em>. <br/></td></tr>
<tr class="separator:abd2ac9c22301f44b2324f886f144ac05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0ecc4446045b533db6824b2cda3f4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d0ecc4446045b533db6824b2cda3f4a"></a>
<a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a1d0ecc4446045b533db6824b2cda3f4a">compute_log</a> (const float *values) const </td></tr>
<tr class="memdesc:a1d0ecc4446045b533db6824b2cda3f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the logarithm value of the function for the input parameter <em>values</em>. <br/></td></tr>
<tr class="separator:a1d0ecc4446045b533db6824b2cda3f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6ea47812aa246014d45acafb336c1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd6ea47812aa246014d45acafb336c1b"></a>
<a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#afd6ea47812aa246014d45acafb336c1b">compute_log</a> (const double *values) const </td></tr>
<tr class="memdesc:afd6ea47812aa246014d45acafb336c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the logarithm value of the function for the input parameter <em>values</em>. <br/></td></tr>
<tr class="separator:afd6ea47812aa246014d45acafb336c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9acae407bb514e68404015e3409626b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a9acae407bb514e68404015e3409626b6">compute</a> (const std::vector&lt; int &gt; &amp;parameter) const </td></tr>
<tr class="memdesc:a9acae407bb514e68404015e3409626b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of the function for the STL vector input parameter 'values'.  <a href="#a9acae407bb514e68404015e3409626b6">More...</a><br/></td></tr>
<tr class="separator:a9acae407bb514e68404015e3409626b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1265e5c7812f6b64e3aa83b24a88f19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#af1265e5c7812f6b64e3aa83b24a88f19">compute</a> (const std::vector&lt; unsigned int &gt; &amp;parameter) const </td></tr>
<tr class="memdesc:af1265e5c7812f6b64e3aa83b24a88f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of the function for the STL vector input parameter 'values'.  <a href="#af1265e5c7812f6b64e3aa83b24a88f19">More...</a><br/></td></tr>
<tr class="separator:af1265e5c7812f6b64e3aa83b24a88f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1861cd268512d85a6aa91f363809953a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a1861cd268512d85a6aa91f363809953a">compute</a> (const std::vector&lt; float &gt; &amp;parameter) const </td></tr>
<tr class="memdesc:a1861cd268512d85a6aa91f363809953a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of the function for the STL vector input parameter 'values'.  <a href="#a1861cd268512d85a6aa91f363809953a">More...</a><br/></td></tr>
<tr class="separator:a1861cd268512d85a6aa91f363809953a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006e193a6ba42c38245cc35d9b94a148"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a006e193a6ba42c38245cc35d9b94a148">compute</a> (const std::vector&lt; double &gt; &amp;parameter) const </td></tr>
<tr class="memdesc:a006e193a6ba42c38245cc35d9b94a148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of the function for the STL vector input parameter 'values'.  <a href="#a006e193a6ba42c38245cc35d9b94a148">More...</a><br/></td></tr>
<tr class="separator:a006e193a6ba42c38245cc35d9b94a148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fd3f0b17903f33e0172682bfedb808"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16fd3f0b17903f33e0172682bfedb808"></a>
<a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a16fd3f0b17903f33e0172682bfedb808">compute_log</a> (const std::vector&lt; int &gt; &amp;parameter) const </td></tr>
<tr class="memdesc:a16fd3f0b17903f33e0172682bfedb808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the logarithm value of the function for the input parameter <em>values</em>. <br/></td></tr>
<tr class="separator:a16fd3f0b17903f33e0172682bfedb808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbee86f8e3dbb0168331859bffc47f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fbee86f8e3dbb0168331859bffc47f8"></a>
<a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a8fbee86f8e3dbb0168331859bffc47f8">compute_log</a> (const std::vector&lt; unsigned int &gt; &amp;parameter) const </td></tr>
<tr class="memdesc:a8fbee86f8e3dbb0168331859bffc47f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the logarithm value of the function for the input parameter <em>values</em>. <br/></td></tr>
<tr class="separator:a8fbee86f8e3dbb0168331859bffc47f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b9aef6155cc716bc7ba57c73b38c46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61b9aef6155cc716bc7ba57c73b38c46"></a>
<a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a61b9aef6155cc716bc7ba57c73b38c46">compute_log</a> (const std::vector&lt; float &gt; &amp;parameter) const </td></tr>
<tr class="memdesc:a61b9aef6155cc716bc7ba57c73b38c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the logarithm value of the function for the input parameter <em>values</em>. <br/></td></tr>
<tr class="separator:a61b9aef6155cc716bc7ba57c73b38c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cc22cc54bcbc19544a100eb4524d38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6cc22cc54bcbc19544a100eb4524d38"></a>
<a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#ad6cc22cc54bcbc19544a100eb4524d38">compute_log</a> (const std::vector&lt; double &gt; &amp;parameter) const </td></tr>
<tr class="memdesc:ad6cc22cc54bcbc19544a100eb4524d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the logarithm value of the function for the input parameter <em>values</em>. <br/></td></tr>
<tr class="separator:ad6cc22cc54bcbc19544a100eb4524d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4df0b55bd356d06d31b50720e5c1d20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00036.html">plComputableObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#ae4df0b55bd356d06d31b50720e5c1d20">rename</a> (const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;new_variables)</td></tr>
<tr class="memdesc:ae4df0b55bd356d06d31b50720e5c1d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames the head variables of a function and returns a reference to it .  <a href="#ae4df0b55bd356d06d31b50720e5c1d20">More...</a><br/></td></tr>
<tr class="separator:ae4df0b55bd356d06d31b50720e5c1d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c1f2f71433a33bdfbb575bb91231aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70c1f2f71433a33bdfbb575bb91231aa"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a70c1f2f71433a33bdfbb575bb91231aa">write_head</a> (std::ostream &amp;out=std::cout) const </td></tr>
<tr class="memdesc:a70c1f2f71433a33bdfbb575bb91231aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the the distribution head at the output stream <em>out</em>. <br/></td></tr>
<tr class="separator:a70c1f2f71433a33bdfbb575bb91231aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c00b66f410f853d1eb219e0adacf5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37c00b66f410f853d1eb219e0adacf5a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a37c00b66f410f853d1eb219e0adacf5a">get_head_string</a> () const </td></tr>
<tr class="memdesc:a37c00b66f410f853d1eb219e0adacf5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the distribution head as a string. <br/></td></tr>
<tr class="separator:a37c00b66f410f853d1eb219e0adacf5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c082c3527d5550b10cba0f44046621"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38c082c3527d5550b10cba0f44046621"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a38c082c3527d5550b10cba0f44046621">write_body</a> (std::ostream &amp;out=std::cout) const </td></tr>
<tr class="memdesc:a38c082c3527d5550b10cba0f44046621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the distribution body at the output stream <em>out</em>. <br/></td></tr>
<tr class="separator:a38c082c3527d5550b10cba0f44046621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1564028feb606c92058f622315c41d33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1564028feb606c92058f622315c41d33"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a1564028feb606c92058f622315c41d33">get_body_string</a> () const </td></tr>
<tr class="memdesc:a1564028feb606c92058f622315c41d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the distribution body as a string. <br/></td></tr>
<tr class="separator:a1564028feb606c92058f622315c41d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801220a9678efe54967703fd4b6e8d12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a801220a9678efe54967703fd4b6e8d12"></a>
<a class="el" href="a00037.html">plComputableObjectList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a801220a9678efe54967703fd4b6e8d12">operator*</a> (const <a class="el" href="a00036.html">plComputableObject</a> &amp;f2) const </td></tr>
<tr class="memdesc:a801220a9678efe54967703fd4b6e8d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation with another computable object operator. <br/></td></tr>
<tr class="separator:a801220a9678efe54967703fd4b6e8d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63183160c7a50f85c62bdc4c2c9857ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63183160c7a50f85c62bdc4c2c9857ed"></a>
<a class="el" href="a00037.html">plComputableObjectList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a63183160c7a50f85c62bdc4c2c9857ed">concatenate</a> (const <a class="el" href="a00036.html">plComputableObject</a> &amp;f2) const </td></tr>
<tr class="memdesc:a63183160c7a50f85c62bdc4c2c9857ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation with another computable object operator. <br/></td></tr>
<tr class="separator:a63183160c7a50f85c62bdc4c2c9857ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7d111720e006ea4189dea2f8a56be4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a7d111720e006ea4189dea2f8a56be4"></a>
<a class="el" href="a00037.html">plComputableObjectList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a6a7d111720e006ea4189dea2f8a56be4">operator*</a> (const <a class="el" href="a00037.html">plComputableObjectList</a> &amp;v_list) const </td></tr>
<tr class="memdesc:a6a7d111720e006ea4189dea2f8a56be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation with a computable objects list operator. <br/></td></tr>
<tr class="separator:a6a7d111720e006ea4189dea2f8a56be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7354428574f2f08c4bbb05b94cac06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b7354428574f2f08c4bbb05b94cac06"></a>
<a class="el" href="a00037.html">plComputableObjectList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a5b7354428574f2f08c4bbb05b94cac06">concatenate</a> (const <a class="el" href="a00037.html">plComputableObjectList</a> &amp;v_list) const </td></tr>
<tr class="memdesc:a5b7354428574f2f08c4bbb05b94cac06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenation with a computable objects list operator. <br/></td></tr>
<tr class="separator:a5b7354428574f2f08c4bbb05b94cac06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab25fd555daa11cb53116356b6f2934"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#afab25fd555daa11cb53116356b6f2934">replace</a> (const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;left_vars, const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;right_vars, const <a class="el" href="a00036.html">plComputableObject</a> &amp;new_co)</td></tr>
<tr class="memdesc:afab25fd555daa11cb53116356b6f2934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the referenced distribution P(left_vars | right_vars) by another distribution <em>new_co</em>.  <a href="#afab25fd555daa11cb53116356b6f2934">More...</a><br/></td></tr>
<tr class="separator:afab25fd555daa11cb53116356b6f2934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18dbe09cc9f09d557dfeea2ca8adf7b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a18dbe09cc9f09d557dfeea2ca8adf7b1">replace</a> (const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;left_vars, const <a class="el" href="a00049.html">plDistribution</a> &amp;new_distribution)</td></tr>
<tr class="memdesc:a18dbe09cc9f09d557dfeea2ca8adf7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the distribution P(left_vars ) by another distribution <em>new_distribution</em>.  <a href="#a18dbe09cc9f09d557dfeea2ca8adf7b1">More...</a><br/></td></tr>
<tr class="separator:a18dbe09cc9f09d557dfeea2ca8adf7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba966e79d2df6be24ebf3be9b42e1421"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#aba966e79d2df6be24ebf3be9b42e1421">operator==</a> (const <a class="el" href="a00036.html">plComputableObject</a> &amp;other) const </td></tr>
<tr class="memdesc:aba966e79d2df6be24ebf3be9b42e1421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <em>true</em> if this and the other object are the same.  <a href="#aba966e79d2df6be24ebf3be9b42e1421">More...</a><br/></td></tr>
<tr class="separator:aba966e79d2df6be24ebf3be9b42e1421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff774caa1dff478df4e71099ac6fd03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#acff774caa1dff478df4e71099ac6fd03">equal</a> (const <a class="el" href="a00036.html">plComputableObject</a> &amp;other) const </td></tr>
<tr class="memdesc:acff774caa1dff478df4e71099ac6fd03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <em>true</em> if this and the other object are the same.  <a href="#acff774caa1dff478df4e71099ac6fd03">More...</a><br/></td></tr>
<tr class="separator:acff774caa1dff478df4e71099ac6fd03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3da5b54159e65680112bccae59ae6b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#af3da5b54159e65680112bccae59ae6b1">operator!=</a> (const <a class="el" href="a00036.html">plComputableObject</a> &amp;other) const </td></tr>
<tr class="memdesc:af3da5b54159e65680112bccae59ae6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <em>true</em> if this and the other object are not the same.  <a href="#af3da5b54159e65680112bccae59ae6b1">More...</a><br/></td></tr>
<tr class="separator:af3da5b54159e65680112bccae59ae6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1102e6b7f99b3bb123518b31a38c93d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#ac1102e6b7f99b3bb123518b31a38c93d">not_equal</a> (const <a class="el" href="a00036.html">plComputableObject</a> &amp;other) const </td></tr>
<tr class="memdesc:ac1102e6b7f99b3bb123518b31a38c93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <em>true</em> if this and the other object are not the same.  <a href="#ac1102e6b7f99b3bb123518b31a38c93d">More...</a><br/></td></tr>
<tr class="separator:ac1102e6b7f99b3bb123518b31a38c93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605d03931ddead4740a6f9dd5ffebbc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a605d03931ddead4740a6f9dd5ffebbc8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a605d03931ddead4740a6f9dd5ffebbc8">is_builtin</a> () const </td></tr>
<tr class="memdesc:a605d03931ddead4740a6f9dd5ffebbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <em>true</em> if and only if the computable object is a ProBT builtin one. <br/></td></tr>
<tr class="separator:a605d03931ddead4740a6f9dd5ffebbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a29ccef4eb038dc7fbcb5716a5f6f83"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a3a29ccef4eb038dc7fbcb5716a5f6f83">print_evaluation_tree_infos</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a3a29ccef4eb038dc7fbcb5716a5f6f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the evaluation tree corresponding to the computable object.  <a href="#a3a29ccef4eb038dc7fbcb5716a5f6f83">More...</a><br/></td></tr>
<tr class="separator:a3a29ccef4eb038dc7fbcb5716a5f6f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734ea7cb3c281887e8817af5be79acd4"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a734ea7cb3c281887e8817af5be79acd4">get_exhaustive_compilation_complexity</a> () const </td></tr>
<tr class="memdesc:a734ea7cb3c281887e8817af5be79acd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sum of the number of sums and the number of products required to compile the corresponding expression.  <a href="#a734ea7cb3c281887e8817af5be79acd4">More...</a><br/></td></tr>
<tr class="separator:a734ea7cb3c281887e8817af5be79acd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2910c5154800b42812ef3ec5221abb95"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a2910c5154800b42812ef3ec5221abb95">get_exhaustive_update_complexity</a> () const </td></tr>
<tr class="memdesc:a2910c5154800b42812ef3ec5221abb95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sum of the number of sums and the number of products required to update the corresponding expression for a new given evidence value.  <a href="#a2910c5154800b42812ef3ec5221abb95">More...</a><br/></td></tr>
<tr class="separator:a2910c5154800b42812ef3ec5221abb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251f806cf5b6db484356c49ea1eaf236"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a251f806cf5b6db484356c49ea1eaf236">is_mutable</a> () const </td></tr>
<tr class="memdesc:a251f806cf5b6db484356c49ea1eaf236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mutability property.  <a href="#a251f806cf5b6db484356c49ea1eaf236">More...</a><br/></td></tr>
<tr class="separator:a251f806cf5b6db484356c49ea1eaf236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44a04b4879bc1fded76401170f108ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#ad44a04b4879bc1fded76401170f108ca">tabulate</a> (std::vector&lt; <a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> &gt; &amp;output) const </td></tr>
<tr class="memdesc:ad44a04b4879bc1fded76401170f108ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tabulates the computable object in the 'output' vector.  <a href="#ad44a04b4879bc1fded76401170f108ca">More...</a><br/></td></tr>
<tr class="separator:ad44a04b4879bc1fded76401170f108ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248aa42fc6d5353e4d9134a0badf6701"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a248aa42fc6d5353e4d9134a0badf6701"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a248aa42fc6d5353e4d9134a0badf6701">n_tabulate</a> (std::vector&lt; <a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> &gt; &amp;output, long unsigned int n) const </td></tr>
<tr class="memdesc:a248aa42fc6d5353e4d9134a0badf6701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as tabulate(vector &lt;plProbValue&gt; &amp;output) but using limited sampling iterations <em>n</em>. <br/></td></tr>
<tr class="separator:a248aa42fc6d5353e4d9134a0badf6701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad66128cf7cf9521bc9a1a3dd9ccf2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ad66128cf7cf9521bc9a1a3dd9ccf2e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a2ad66128cf7cf9521bc9a1a3dd9ccf2e">time_tabulate</a> (std::vector&lt; <a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> &gt; &amp;output, double time_in_seconds) const </td></tr>
<tr class="memdesc:a2ad66128cf7cf9521bc9a1a3dd9ccf2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as tabulate(vector &lt;plProbValue&gt; &amp;output) but using limited sampling time <em>time_in_seconds</em>. <br/></td></tr>
<tr class="separator:a2ad66128cf7cf9521bc9a1a3dd9ccf2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76989d6e4e1588a93d6bf24468a39596"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76989d6e4e1588a93d6bf24468a39596"></a>
<a class="el" href="a00037.html">plComputableObjectList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a76989d6e4e1588a93d6bf24468a39596">get_factors</a> () const </td></tr>
<tr class="memdesc:a76989d6e4e1588a93d6bf24468a39596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the independant factors of a product computable object. <br/></td></tr>
<tr class="separator:a76989d6e4e1588a93d6bf24468a39596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec3e198b025796ae3249fc4c1869f45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afec3e198b025796ae3249fc4c1869f45"></a>
<a class="el" href="a00037.html">plComputableObjectList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#afec3e198b025796ae3249fc4c1869f45">get_children</a> () const </td></tr>
<tr class="memdesc:afec3e198b025796ae3249fc4c1869f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get expression children. <br/></td></tr>
<tr class="separator:afec3e198b025796ae3249fc4c1869f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b426f352866648927cc199f6e09eb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71b426f352866648927cc199f6e09eb2"></a>
<a class="el" href="a00150.html">plVariablesConjunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a71b426f352866648927cc199f6e09eb2">get_marginalized_variables</a> () const </td></tr>
<tr class="memdesc:a71b426f352866648927cc199f6e09eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get expression marginalized variables. <br/></td></tr>
<tr class="separator:a71b426f352866648927cc199f6e09eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_a00123"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_a00123')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="a00123.html">plObject</a></td></tr>
<tr class="memitem:ae56b362a1e46e4a0c217e260324fb28a inherit pub_methods_a00123"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae56b362a1e46e4a0c217e260324fb28a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#ae56b362a1e46e4a0c217e260324fb28a">plObject</a> ()</td></tr>
<tr class="memdesc:ae56b362a1e46e4a0c217e260324fb28a inherit pub_methods_a00123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="separator:ae56b362a1e46e4a0c217e260324fb28a inherit pub_methods_a00123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9c71b1b5085c527269ffa5bdd87522 inherit pub_methods_a00123"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#a5a9c71b1b5085c527269ffa5bdd87522">~plObject</a> ()</td></tr>
<tr class="memdesc:a5a9c71b1b5085c527269ffa5bdd87522 inherit pub_methods_a00123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the object.  <a href="#a5a9c71b1b5085c527269ffa5bdd87522">More...</a><br/></td></tr>
<tr class="separator:a5a9c71b1b5085c527269ffa5bdd87522 inherit pub_methods_a00123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b86aedf034cce26568c14020bd6c6d inherit pub_methods_a00123"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#ad6b86aedf034cce26568c14020bd6c6d">to_string</a> (std::ostringstream *s=0) const </td></tr>
<tr class="memdesc:ad6b86aedf034cce26568c14020bd6c6d inherit pub_methods_a00123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object as a string.  <a href="#ad6b86aedf034cce26568c14020bd6c6d">More...</a><br/></td></tr>
<tr class="separator:ad6b86aedf034cce26568c14020bd6c6d inherit pub_methods_a00123"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3f679ba06f427cd27d83b2660c7847fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f679ba06f427cd27d83b2660c7847fc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a3f679ba06f427cd27d83b2660c7847fc">Output</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a3f679ba06f427cd27d83b2660c7847fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the object at the output given by "out". <br/></td></tr>
<tr class="separator:a3f679ba06f427cd27d83b2660c7847fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <em>computable</em> <em>object</em> on <img class="formulaInl" alt="$ \omega $" src="form_40.png"/> is defined as an abstract object provided with a probability measure function <em>compute</em>( <img class="formulaInl" alt="$ \omega $" src="form_40.png"/>). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac4a2eecd3f7b7ba2e0dedc90e97d9ec3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">plComputableObject::plComputableObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empty constructor. </p>
<p>The resulting object is invalid for most operations, except for being assigned to, or used as a return value. </p>

</div>
</div>
<a class="anchor" id="a201dc2483848f17a1edb7f41727684dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">plComputableObject::plComputableObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00037.html">plComputableObjectList</a> &amp;&#160;</td>
          <td class="paramname"><em>func_lis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a conditional or non conditional distribution as a product of a conditional and non conditional distributions. </p>
<p>The left variables of the constructed computable object are the concatenation (in the same order) of the left variables of all the terms of the list. Its right variables are the concatenation of the right variables of all the terms and that are not in left one above. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac875aa862861dae7c5e33e4acc602dda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> plComputableObject::compute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00147.html">plValues</a> &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the value of the function for the input parameter <em>values</em>. </p>
<p>ATTENTION: the returned value is guaranteed to be NORMALIZED for and only for:</p>
<ul>
<li>builtin distributions (basic distributions provided directly by ProBT),</li>
<li>compiled distributions (obtained by using the compile() method).</li>
<li>distributions obtained with <em>instantiate</em> called with parameter <em>ensure_normalization_on_compute</em> = <em>true</em>.</li>
</ul>
<p>Calling the 'compute' method on distributions resulting from the ask and/or instantiate methods is not guaranteed to return a normalized value unless the instantiate method is called with parameter <em>ensure_normalization_on_compute</em> = <em>true</em>. To be sure to obtain normalized values, consider compiling these distributions using the 'compile' method.</p>
<p>However, this method is useful if you just want to compare the relative magnitudes of several probability values. </p>

</div>
</div>
<a class="anchor" id="aa9e391b00c9279cf4fb2349b27472688"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> plComputableObject::compute </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the value of the function for the array input parameter <em>values</em>. </p>
<p>ATTENTION: the returned value is guaranteed to be NORMALIZED for and only for:</p>
<ul>
<li>builtin distributions (basics distributions provided by ProBT),</li>
<li>compiled distributions (obtained by using the <em>compile</em> method).</li>
<li>distributions obtained with <em>instantiate</em> called with parameter <em>ensure_normalization_on_compute</em> = <em>true</em>.</li>
</ul>
<p>Calling the <em>compute</em> method on distributions resulting from the ask and/or instantiate methods is not guaranteed to return a normalized value unless the instantiate method is called with parameter <em>ensure_normalization_on_compute</em> = true. To be sure to obtain normalized values, consider compiling these distributions using the 'compile' method. </p>

</div>
</div>
<a class="anchor" id="a21fcc65c43c3e92b3230634c7a16b80d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> plComputableObject::compute </td>
          <td>(</td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the value of the function for the array input parameter <em>values</em>. </p>
<p>ATTENTION: the returned value is guaranteed to be NORMALIZED for and only for:</p>
<ul>
<li>builtin distributions (basics distributions provided by ProBT),</li>
<li>compiled distributions (obtained by using the <em>compile</em> method).</li>
<li>distributions obtained with <em>instantiate</em> called with parameter <em>ensure_normalization_on_compute</em> = <em>true</em>.</li>
</ul>
<p>Calling the <em>compute</em> method on distributions resulting from the ask and/or instantiate methods is not guaranteed to return a normalized value unless the instantiate method is called with parameter <em>ensure_normalization_on_compute</em> = true. To be sure to obtain normalized values, consider compiling these distributions using the 'compile' method. </p>

</div>
</div>
<a class="anchor" id="ac7e87f4251e574b8c057958f33245001"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> plComputableObject::compute </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the value of the function for the array input parameter <em>values</em>. </p>
<p>ATTENTION: the returned value is guaranteed to be NORMALIZED for and only for:</p>
<ul>
<li>builtin distributions (basics distributions provided by ProBT),</li>
<li>compiled distributions (obtained by using the <em>compile</em> method).</li>
<li>distributions obtained with <em>instantiate</em> called with parameter <em>ensure_normalization_on_compute</em> = <em>true</em>.</li>
</ul>
<p>Calling the <em>compute</em> method on distributions resulting from the ask and/or instantiate methods is not guaranteed to return a normalized value unless the instantiate method is called with parameter <em>ensure_normalization_on_compute</em> = true. To be sure to obtain normalized values, consider compiling these distributions using the 'compile' method. </p>

</div>
</div>
<a class="anchor" id="ab3c8ffca06205ab9de5996c86012391d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> plComputableObject::compute </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the value of the function for the array input parameter <em>values</em>. </p>
<p>ATTENTION: the returned value is guaranteed to be NORMALIZED for and only for:</p>
<ul>
<li>builtin distributions (basics distributions provided by ProBT),</li>
<li>compiled distributions (obtained by using the <em>compile</em> method).</li>
<li>distributions obtained with <em>instantiate</em> called with parameter <em>ensure_normalization_on_compute</em> = <em>true</em>.</li>
</ul>
<p>Calling the <em>compute</em> method on distributions resulting from the ask and/or instantiate methods is not guaranteed to return a normalized value unless the instantiate method is called with parameter <em>ensure_normalization_on_compute</em> = true. To be sure to obtain normalized values, consider compiling these distributions using the 'compile' method. </p>

</div>
</div>
<a class="anchor" id="a9acae407bb514e68404015e3409626b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> plComputableObject::compute </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the value of the function for the STL vector input parameter 'values'. </p>
<p>ATTENTION: the returned value is guaranteed to be NORMALIZED for and only for:</p>
<ul>
<li>builtin distributions (basics distributions provided by ProBT),</li>
<li>the compiled distributions (obtained by using the <em>compile</em> method).</li>
<li>distributions obtained with <em>instantiate</em> called with parameter <em>ensure_normalization_on_compute</em> = true.</li>
</ul>
<p>Calling the 'compute' method on distributions resulting from the ask and/or instantiate methods is not guaranteed to return a normalized value unless the instantiate method is called with parameter <em>ensure_normalization_on_compute</em> = <em>true</em>. To be sure to obtain normalized values, consider compiling these distributions using the <em>compile</em> method. </p>

</div>
</div>
<a class="anchor" id="af1265e5c7812f6b64e3aa83b24a88f19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> plComputableObject::compute </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the value of the function for the STL vector input parameter 'values'. </p>
<p>ATTENTION: the returned value is guaranteed to be NORMALIZED for and only for:</p>
<ul>
<li>builtin distributions (basics distributions provided by ProBT),</li>
<li>the compiled distributions (obtained by using the <em>compile</em> method).</li>
<li>distributions obtained with <em>instantiate</em> called with parameter <em>ensure_normalization_on_compute</em> = true.</li>
</ul>
<p>Calling the 'compute' method on distributions resulting from the ask and/or instantiate methods is not guaranteed to return a normalized value unless the instantiate method is called with parameter <em>ensure_normalization_on_compute</em> = <em>true</em>. To be sure to obtain normalized values, consider compiling these distributions using the <em>compile</em> method. </p>

</div>
</div>
<a class="anchor" id="a1861cd268512d85a6aa91f363809953a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> plComputableObject::compute </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the value of the function for the STL vector input parameter 'values'. </p>
<p>ATTENTION: the returned value is guaranteed to be NORMALIZED for and only for:</p>
<ul>
<li>builtin distributions (basics distributions provided by ProBT),</li>
<li>the compiled distributions (obtained by using the <em>compile</em> method).</li>
<li>distributions obtained with <em>instantiate</em> called with parameter <em>ensure_normalization_on_compute</em> = true.</li>
</ul>
<p>Calling the 'compute' method on distributions resulting from the ask and/or instantiate methods is not guaranteed to return a normalized value unless the instantiate method is called with parameter <em>ensure_normalization_on_compute</em> = <em>true</em>. To be sure to obtain normalized values, consider compiling these distributions using the <em>compile</em> method. </p>

</div>
</div>
<a class="anchor" id="a006e193a6ba42c38245cc35d9b94a148"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> plComputableObject::compute </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the value of the function for the STL vector input parameter 'values'. </p>
<p>ATTENTION: the returned value is guaranteed to be NORMALIZED for and only for:</p>
<ul>
<li>builtin distributions (basics distributions provided by ProBT),</li>
<li>the compiled distributions (obtained by using the <em>compile</em> method).</li>
<li>distributions obtained with <em>instantiate</em> called with parameter <em>ensure_normalization_on_compute</em> = true.</li>
</ul>
<p>Calling the 'compute' method on distributions resulting from the ask and/or instantiate methods is not guaranteed to return a normalized value unless the instantiate method is called with parameter <em>ensure_normalization_on_compute</em> = <em>true</em>. To be sure to obtain normalized values, consider compiling these distributions using the <em>compile</em> method. </p>

</div>
</div>
<a class="anchor" id="acff774caa1dff478df4e71099ac6fd03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool plComputableObject::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00036.html">plComputableObject</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <em>true</em> if this and the other object are the same. </p>

</div>
</div>
<a class="anchor" id="afd05a723760fa24a64202b188726b6a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00278.html#a9edc51edaa4a10e2ecfea399e94bfd27">plComputableObjectType</a> plComputableObject::get_computable_object_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the object actual (most derived) type. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00036.html#a62e46fb956c7fedf0b50e45315e3420c" title="Get the object full signature (e.g its actual type and parent classes) ">get_signature()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a734ea7cb3c281887e8817af5be79acd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double plComputableObject::get_exhaustive_compilation_complexity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sum of the number of sums and the number of products required to compile the corresponding expression. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00036.html#a2910c5154800b42812ef3ec5221abb95" title="Get the sum of the number of sums and the number of products required to update the corresponding exp...">get_exhaustive_update_complexity</a> <a class="el" href="a00036.html#a3a29ccef4eb038dc7fbcb5716a5f6f83" title="Displays the evaluation tree corresponding to the computable object. ">print_evaluation_tree_infos</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2910c5154800b42812ef3ec5221abb95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double plComputableObject::get_exhaustive_update_complexity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sum of the number of sums and the number of products required to update the corresponding expression for a new given evidence value. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00036.html#a734ea7cb3c281887e8817af5be79acd4" title="Get the sum of the number of sums and the number of products required to compile the corresponding ex...">get_exhaustive_compilation_complexity</a> <a class="el" href="a00036.html#a3a29ccef4eb038dc7fbcb5716a5f6f83" title="Displays the evaluation tree corresponding to the computable object. ">print_evaluation_tree_infos</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a11292d79d09bf7af0136db1ecb2fdcef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00150.html">plVariablesConjunction</a> plComputableObject::get_left_variables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the left variables of the computable object. </p>
<p>For instance, for a distribution representing P(A B | C D), this would return A B. </p>

<p>Referenced by <a class="el" href="a00050.html#abf86fc630f32e6a4dc18527b4dc05ec7">plDistributionTable::plDistributionTable()</a>.</p>

</div>
</div>
<a class="anchor" id="ac21dc5841ed3c12c2638feab0b9fd4fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00150.html">plVariablesConjunction</a> plComputableObject::get_right_variables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the right variables of the computable object. </p>
<p>For instance, for a conditional distribution representing P(A B | C D), this would return C D. This returns an empty <a class="el" href="a00150.html" title="The plVariablesConjunction class implements the conjunction of a set of variables. ">plVariablesConjunction</a> for a non-conditional distribution. </p>

<p>Referenced by <a class="el" href="a00050.html#abf86fc630f32e6a4dc18527b4dc05ec7">plDistributionTable::plDistributionTable()</a>.</p>

</div>
</div>
<a class="anchor" id="a3318e9b147450d0159587e4371ab708c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00150.html">plVariablesConjunction</a> plComputableObject::get_variables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all the variables (left and right) of the computable object. </p>
<p>This is equivalent to <a class="el" href="a00036.html#a11292d79d09bf7af0136db1ecb2fdcef" title="Returns the left variables of the computable object. ">get_left_variables()</a> ^ <a class="el" href="a00036.html#ac21dc5841ed3c12c2638feab0b9fd4fd" title="Returns the right variables of the computable object. ">get_right_variables()</a>. </p>

</div>
</div>
<a class="anchor" id="ad05d53d474ca8282099606f8246dd964"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool plComputableObject::is_conditional </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the distribution really is conditional. </p>

</div>
</div>
<a class="anchor" id="a8890f32f991d15122120dbc14d6fe9c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool plComputableObject::is_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the object is default-constructed (as opposed to full-initialized). </p>

</div>
</div>
<a class="anchor" id="a251f806cf5b6db484356c49ea1eaf236"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool plComputableObject::is_mutable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the mutability property. </p>
<dl class="section return"><dt>Returns</dt><dd>'true' if the computable object is mutable. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1102e6b7f99b3bb123518b31a38c93d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool plComputableObject::not_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00036.html">plComputableObject</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <em>true</em> if this and the other object are not the same. </p>

</div>
</div>
<a class="anchor" id="af3da5b54159e65680112bccae59ae6b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool plComputableObject::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00036.html">plComputableObject</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <em>true</em> if this and the other object are not the same. </p>

</div>
</div>
<a class="anchor" id="aba966e79d2df6be24ebf3be9b42e1421"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool plComputableObject::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00036.html">plComputableObject</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <em>true</em> if this and the other object are the same. </p>

</div>
</div>
<a class="anchor" id="a3a29ccef4eb038dc7fbcb5716a5f6f83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; plComputableObject::print_evaluation_tree_infos </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the evaluation tree corresponding to the computable object. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00036.html#a734ea7cb3c281887e8817af5be79acd4" title="Get the sum of the number of sums and the number of products required to compile the corresponding ex...">get_exhaustive_compilation_complexity</a> <a class="el" href="a00036.html#a2910c5154800b42812ef3ec5221abb95" title="Get the sum of the number of sums and the number of products required to update the corresponding exp...">get_exhaustive_update_complexity</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae4df0b55bd356d06d31b50720e5c1d20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00036.html">plComputableObject</a>&amp; plComputableObject::rename </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>new_variables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renames the head variables of a function and returns a reference to it . </p>

<p>Referenced by <a class="el" href="a00005.html#a551527fc5c354fc30fbfbae00b91e1e3">plBayesianFilter::get_estimation()</a>.</p>

</div>
</div>
<a class="anchor" id="afab25fd555daa11cb53116356b6f2934"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plComputableObject::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>left_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>right_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00036.html">plComputableObject</a> &amp;&#160;</td>
          <td class="paramname"><em>new_co</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the referenced distribution P(left_vars | right_vars) by another distribution <em>new_co</em>. </p>
<p><em>new_cnd_distribution</em> must have the same left and right variables.</p>
<p>This method is intended to be used especially on non-compiled computable objects such as:</p>
<ul>
<li>Expressions obtained using the <em>ask</em> method (see <em><a class="el" href="a00079.html" title="The plJointDistribution class is used to describe a probabilistic model by providing a decomposition ...">plJointDistribution</a></em> class) and non-conditional expressions obtained using the <em>instantiate</em> method on the conditional expressions above.</li>
<li>Joint distribution objects (<em><a class="el" href="a00079.html" title="The plJointDistribution class is used to describe a probabilistic model by providing a decomposition ...">plJointDistribution</a></em>).</li>
</ul>
<p>Using <em>replace</em> affects only the computable object on which is called. To get a global effect, use <em>mutate</em> instead.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00112.html#a4b3b3995888aead14ae473dad268afce" title="Mutate the object to the new value new_object. ">plMutableComputableObject::mutate</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a18dbe09cc9f09d557dfeea2ca8adf7b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plComputableObject::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>left_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00049.html">plDistribution</a> &amp;&#160;</td>
          <td class="paramname"><em>new_distribution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the distribution P(left_vars ) by another distribution <em>new_distribution</em>. </p>
<p><em>new_distribution</em> must have the same left variables.</p>
<p>This method is intended to be used especially on non-compiled computable objects such as:</p>
<ul>
<li>Expressions obtained using the <em>ask</em> method (see <em><a class="el" href="a00079.html" title="The plJointDistribution class is used to describe a probabilistic model by providing a decomposition ...">plJointDistribution</a></em> class) and non-conditional expressions obtained using the <em>instantiate</em> method on the conditional expressions above.</li>
<li>Joint distribution objects (<em><a class="el" href="a00079.html" title="The plJointDistribution class is used to describe a probabilistic model by providing a decomposition ...">plJointDistribution</a></em>).</li>
</ul>
<p>Using <em>replace</em> affects only the computable object on which is called. To get a global effect, use <em>mutate</em> instead.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00112.html#a4b3b3995888aead14ae473dad268afce" title="Mutate the object to the new value new_object. ">plMutableComputableObject::mutate</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad44a04b4879bc1fded76401170f108ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plComputableObject::tabulate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tabulates the computable object in the 'output' vector. </p>
<p>The value <img class="formulaInl" alt="$ P(X) $" src="form_41.png"/> is computed for each possible value of the <img class="formulaInl" alt="$ X $" src="form_42.png"/> variables and stored in the output vector 'output. Calling this method on computable objects with non-discretized continuous variables throws a <a class="el" href="a00063.html" title="A plError is an exception thrown when a fatal error is encountered in ProBT. ">plError(27)</a> exception.</p>
<p>In multi-dimensional cases <img class="formulaInl" alt="$ X = X_1 X_2 $" src="form_43.png"/>, where <img class="formulaInl" alt="$ X_1 $" src="form_44.png"/> and <img class="formulaInl" alt="$ X_2 $" src="form_45.png"/> can take, for example, <img class="formulaInl" alt="$ 1 \cdots n_1 $" src="form_46.png"/> and <img class="formulaInl" alt="$ 1 \cdots n_2 $" src="form_47.png"/> values respectively, it constructs the probability table on <img class="formulaInl" alt="$ P(X)$" src="form_48.png"/> as follows:<br/>
</p>
<ul>
<li>output[0] = <img class="formulaInl" alt="$ P([X_1=1, X_2=1]) $" src="form_49.png"/> <br/>
</li>
<li>output[1] = <img class="formulaInl" alt="$ P([X_1=1, X_2=2]) $" src="form_50.png"/> <br/>
. <br/>
 . <br/>
 . <br/>
</li>
<li>output[ <img class="formulaInl" alt="$ n_2-1$" src="form_51.png"/>] = <img class="formulaInl" alt="$ P([X_1=1, X_2=n_2]) $" src="form_52.png"/> <br/>
<br/>
</li>
<li>output[ <img class="formulaInl" alt="$ n_2 $" src="form_53.png"/>] = <img class="formulaInl" alt="$ P([X_1=2, X_2=1]) $" src="form_54.png"/> <br/>
</li>
<li>output[ <img class="formulaInl" alt="$ n_2+1 $" src="form_55.png"/>] = <img class="formulaInl" alt="$ P([X_1=2, X_2=2]) $" src="form_56.png"/> <br/>
 . <br/>
 . <br/>
 . <br/>
</li>
<li>output[ <img class="formulaInl" alt="$ 2 n_2 - 1 $" src="form_57.png"/>] = <img class="formulaInl" alt="$ P([X_1=2, X_2=n_2]) $" src="form_58.png"/> <br/>
 . <br/>
 . <br/>
 . <br/>
</li>
<li>output[ <img class="formulaInl" alt="$ n_1 n_2-1 $" src="form_59.png"/>] = <img class="formulaInl" alt="$ P([X_1=n_1, X_2=n_2]) $" src="form_60.png"/> <br/>
 The same tabulation scheme is used for conditional distributions (eg., <img class="formulaInl" alt="$ P(X_1 X_2 | Y_1 Y_2)$" src="form_61.png"/>). </li>
</ul>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jan 31 2015 01:13:27 for ProBT by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
