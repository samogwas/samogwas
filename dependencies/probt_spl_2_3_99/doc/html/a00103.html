<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ProBT: plLearnObject Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ProBT
   &#160;<span id="projectnumber">2.3.99</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="a00647.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">plLearnObject Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the base class of all incremental (adaptive) learning objects.  
 <a href="a00103.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for plLearnObject:</div>
<div class="dyncontent">
<div class="center"><img src="a00648.png" border="0" usemap="#pl_learn_object_inherit__map" alt="Inheritance graph"/></div>
<map name="pl_learn_object_inherit__map" id="pl_learn_object_inherit__map">
<area shape="rect" id="node4" href="a00086.html" title="This is an abstract class for all conditional learning objects. " alt="" coords="422,181,549,208"/><area shape="rect" id="node12" href="a00088.html" title="This class allows to learn a set of conditional and non&#45;conditional distributions in the same time..." alt="" coords="415,265,555,292"/><area shape="rect" id="node13" href="a00091.html" title="This class implements a learning object that learns nothing. " alt="" coords="400,316,571,343"/><area shape="rect" id="node14" href="a00121.html" title="This is the base class of all Non&#45;conditional incremental (adaptive) learning objects. " alt="" coords="410,479,561,505"/><area shape="rect" id="node2" href="a00089.html" title="This is the base class of all learning objects. " alt="" coords="125,291,200,317"/><area shape="rect" id="node3" href="a00123.html" title="Used as the base class of all ProBT API objects. " alt="" coords="6,291,77,317"/><area shape="rect" id="node5" href="a00087.html" title="This class implements conditional learning objects as a map. " alt="" coords="640,11,803,37"/><area shape="rect" id="node7" href="a00097.html" title="This implements the learning part of the linear regression model (aka Linear Gaussian). " alt="" coords="639,80,804,107"/><area shape="rect" id="node8" href="a00098.html" title="Implements a family of linear regressions (over a set of quantitative variables), indexed by a set of..." alt="" coords="619,131,823,157"/><area shape="rect" id="node9" href="a00102.html" title="This class implements the learning part of the NoisyOR discrimination model. " alt="" coords="662,181,781,208"/><area shape="rect" id="node10" href="a00105.html" title="This implements the learning part of the Softmax (aka multinomial logistic or multinomial logit) regr..." alt="" coords="665,232,778,259"/><area shape="rect" id="node11" href="a00106.html" title="Implements a family of softmax regressions (over a set of quantitative variables), indexed by a set of categorical variables. " alt="" coords="645,283,797,309"/><area shape="rect" id="node6" href="a00028.html" title="This template class implements conditional learning objects. " alt="" coords="889,5,1047,32"/><area shape="rect" id="node15" href="a00014.html" title="This is the base class of all non&#45;conditional incremental (adaptive) learning objects using a Bayesia..." alt="" coords="652,343,791,369"/><area shape="rect" id="node27" href="a00100.html" title="This class implements the Mixture Model unsupervised learning. " alt="" coords="650,512,793,539"/><area shape="rect" id="node29" href="a00111.html" title="This is the base class of all Non&#45;conditional incremental (adaptive) learning objects using the Maxim..." alt="" coords="661,801,781,828"/><area shape="rect" id="node16" href="a00007.html" title="This class allows to make a Bayesian estimation of a one&#45;dimensional Normal distribution with fixed m..." alt="" coords="876,57,1060,98"/><area shape="rect" id="node17" href="a00008.html" title="This class allows to make a Bayesian estimation of a one&#45;dimensional Normal distribution with fixed s..." alt="" coords="876,122,1060,163"/><area shape="rect" id="node18" href="a00009.html" title="This class allows to make a Bayesian estimation of a Binomial distribution when the prior distributio..." alt="" coords="893,188,1043,215"/><area shape="rect" id="node19" href="a00010.html" title="This class allows to make a Bayesian estimation of an Exponential distribution when the prior distrib..." alt="" coords="883,239,1053,265"/><area shape="rect" id="node20" href="a00011.html" title="This class allows to make a Bayesian estimation of Gamma distributions. " alt="" coords="895,289,1041,316"/><area shape="rect" id="node21" href="a00012.html" title="This class allows to make a Bayesian estimation of a log&#45;normal distribution with fixed shape paramet..." alt="" coords="873,341,1063,382"/><area shape="rect" id="node22" href="a00013.html" title="This class allows to make a Bayesian estimation of a n&#45;dimensional Normal distribution with fixed cov..." alt="" coords="875,406,1061,447"/><area shape="rect" id="node23" href="a00015.html" title="This class allows to make a Bayesian estimation of Poisson distributions. " alt="" coords="894,472,1042,499"/><area shape="rect" id="node24" href="a00016.html" title="This class allows to make a Bayesian estimation of multinomial (ProbTable) distributions using Multin..." alt="" coords="888,523,1048,549"/><area shape="rect" id="node25" href="a00096.html" title="This class allows to make a Bayesian estimation of multinomial (ProbTable) distributions using Lidsto..." alt="" coords="1113,523,1226,549"/><area shape="rect" id="node26" href="a00095.html" title="This class allows to make a Bayesian estimation of multinomial (ProbTable) distributions using Laplac..." alt="" coords="1275,523,1384,549"/><area shape="rect" id="node28" href="a00093.html" title="This class implements the Gaussian Mixture Model unsupervised learning. " alt="" coords="920,573,1016,600"/><area shape="rect" id="node30" href="a00084.html" title="This class allows to learn one&#45;dimensional Normal (Gaussian) distributions. " alt="" coords="908,624,1028,651"/><area shape="rect" id="node31" href="a00085.html" title="This class allows to learn Beta distributions. " alt="" coords="923,675,1013,701"/><area shape="rect" id="node32" href="a00090.html" title="This class allows to learn exponential distributions. " alt="" coords="902,725,1034,752"/><area shape="rect" id="node33" href="a00092.html" title="This class implements Gamma distributions ML learning. " alt="" coords="913,776,1023,803"/><area shape="rect" id="node34" href="a00094.html" title="The class for learning n dimensionnal histograms. " alt="" coords="906,827,1030,853"/><area shape="rect" id="node35" href="a00099.html" title="This class allows to learn log&#45;normal distributions. " alt="" coords="905,877,1031,904"/><area shape="rect" id="node36" href="a00101.html" title="This class allows to learn multi&#45;dimensional Normal (Gaussian) distributions. " alt="" coords="907,928,1029,955"/><area shape="rect" id="node37" href="a00104.html" title="This class allows to learn Poisson distributions. " alt="" coords="913,979,1023,1005"/><area shape="rect" id="node38" href="a00107.html" title="A class for learning sparse histograms. " alt="" coords="885,1029,1051,1056"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for plLearnObject:</div>
<div class="dyncontent">
<div class="center"><img src="a00649.png" border="0" usemap="#pl_learn_object_coll__map" alt="Collaboration graph"/></div>
<map name="pl_learn_object_coll__map" id="pl_learn_object_coll__map">
<area shape="rect" id="node2" href="a00089.html" title="This is the base class of all learning objects. " alt="" coords="5,133,79,160"/><area shape="rect" id="node3" href="a00123.html" title="Used as the base class of all ProBT API objects. " alt="" coords="43,5,113,32"/><area shape="rect" id="node5" href="a00132.html" title="A State Space Object. " alt="" coords="81,83,231,109"/><area shape="rect" id="node4" href="a00150.html" title="The plVariablesConjunction class implements the conjunction of a set of variables. " alt="" coords="80,184,233,211"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a32eb3b5401e5ee340912723ed1a60e8f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#a32eb3b5401e5ee340912723ed1a60e8f">plLearnObject</a> (const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;variables)</td></tr>
<tr class="memdesc:a32eb3b5401e5ee340912723ed1a60e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor using a set of variables.  <a href="#a32eb3b5401e5ee340912723ed1a60e8f">More...</a><br/></td></tr>
<tr class="separator:a32eb3b5401e5ee340912723ed1a60e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c64d0ef2f9ec1692664a5dc42b50495"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#a6c64d0ef2f9ec1692664a5dc42b50495">plLearnObject</a> ()</td></tr>
<tr class="memdesc:a6c64d0ef2f9ec1692664a5dc42b50495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a6c64d0ef2f9ec1692664a5dc42b50495">More...</a><br/></td></tr>
<tr class="separator:a6c64d0ef2f9ec1692664a5dc42b50495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a64b54669eaf4d9e009569776e5c74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09a64b54669eaf4d9e009569776e5c74"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#a09a64b54669eaf4d9e009569776e5c74">plLearnObject</a> (const <a class="el" href="a00103.html">plLearnObject</a> &amp;obj)</td></tr>
<tr class="memdesc:a09a64b54669eaf4d9e009569776e5c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr class="separator:a09a64b54669eaf4d9e009569776e5c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab705685c19712406d4d91eb13a5c382d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab705685c19712406d4d91eb13a5c382d"></a>
<a class="el" href="a00103.html">plLearnObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#ab705685c19712406d4d91eb13a5c382d">operator=</a> (const <a class="el" href="a00103.html">plLearnObject</a> &amp;obj)</td></tr>
<tr class="memdesc:ab705685c19712406d4d91eb13a5c382d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br/></td></tr>
<tr class="separator:ab705685c19712406d4d91eb13a5c382d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bc849a657415e96f2103c1d979f775"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93bc849a657415e96f2103c1d979f775"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#a93bc849a657415e96f2103c1d979f775">~plLearnObject</a> ()</td></tr>
<tr class="memdesc:a93bc849a657415e96f2103c1d979f775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a93bc849a657415e96f2103c1d979f775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab938048d12396abd762a7a0983b97dca"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#ab938048d12396abd762a7a0983b97dca">get_nsamples</a> () const </td></tr>
<tr class="memdesc:ab938048d12396abd762a7a0983b97dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of the points used in learning (i.e.  <a href="#ab938048d12396abd762a7a0983b97dca">More...</a><br/></td></tr>
<tr class="separator:ab938048d12396abd762a7a0983b97dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e1a79f986fbd5eb549a602cc3f8e06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#a40e1a79f986fbd5eb549a602cc3f8e06">get_total_weight</a> () const </td></tr>
<tr class="memdesc:a40e1a79f986fbd5eb549a602cc3f8e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of weights of the points used in learning (i.e.  <a href="#a40e1a79f986fbd5eb549a602cc3f8e06">More...</a><br/></td></tr>
<tr class="separator:a40e1a79f986fbd5eb549a602cc3f8e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18572847fbb6612558e452c63baae61"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#ad18572847fbb6612558e452c63baae61">get_total_weight</a> (std::vector&lt; <a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> &gt; &amp;w) const </td></tr>
<tr class="memdesc:ad18572847fbb6612558e452c63baae61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of weights of the points used in learning (i.e.  <a href="#ad18572847fbb6612558e452c63baae61">More...</a><br/></td></tr>
<tr class="separator:ad18572847fbb6612558e452c63baae61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5384ab2a14c85d11d5138c1e2ffab7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c5384ab2a14c85d11d5138c1e2ffab7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#a1c5384ab2a14c85d11d5138c1e2ffab7">reset</a> ()</td></tr>
<tr class="memdesc:a1c5384ab2a14c85d11d5138c1e2ffab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets learning (forgets all learned data). <br/></td></tr>
<tr class="separator:a1c5384ab2a14c85d11d5138c1e2ffab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e8e04d6debea72bc319abeb68ee130"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00036.html">plComputableObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#a90e8e04d6debea72bc319abeb68ee130">get_computable_object</a> () const =0</td></tr>
<tr class="memdesc:a90e8e04d6debea72bc319abeb68ee130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the computable object corresponding to the learnt distribution.  <a href="#a90e8e04d6debea72bc319abeb68ee130">More...</a><br/></td></tr>
<tr class="separator:a90e8e04d6debea72bc319abeb68ee130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a76a2cd1a2ddf0a151950cbe625f94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#a33a76a2cd1a2ddf0a151950cbe625f94">add_point</a> (const <a class="el" href="a00147.html">plValues</a> &amp;point, <a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> weight=PL_ONE)</td></tr>
<tr class="memdesc:a33a76a2cd1a2ddf0a151950cbe625f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a data point with a given weight.  <a href="#a33a76a2cd1a2ddf0a151950cbe625f94">More...</a><br/></td></tr>
<tr class="separator:a33a76a2cd1a2ddf0a151950cbe625f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01c365472c59e3947b4732e389e4b6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#ad01c365472c59e3947b4732e389e4b6d">add_point</a> (const int *point, <a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> weight=PL_ONE)</td></tr>
<tr class="memdesc:ad01c365472c59e3947b4732e389e4b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a multidimensional data point with a given weight.  <a href="#ad01c365472c59e3947b4732e389e4b6d">More...</a><br/></td></tr>
<tr class="separator:ad01c365472c59e3947b4732e389e4b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a011ce64e6e56a73c0bef15b3473a4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#a6a011ce64e6e56a73c0bef15b3473a4d">add_point</a> (const std::vector&lt; int &gt; &amp;point, <a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> weight=PL_ONE)</td></tr>
<tr class="memdesc:a6a011ce64e6e56a73c0bef15b3473a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a multidimensional data point with a given weight.  <a href="#a6a011ce64e6e56a73c0bef15b3473a4d">More...</a><br/></td></tr>
<tr class="separator:a6a011ce64e6e56a73c0bef15b3473a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac406ba0e9bb82e2b690fe17eeca9ef84"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#ac406ba0e9bb82e2b690fe17eeca9ef84">add_point</a> (int point, <a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> weight=PL_ONE)</td></tr>
<tr class="memdesc:ac406ba0e9bb82e2b690fe17eeca9ef84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a unidimensional data point with a given weight.  <a href="#ac406ba0e9bb82e2b690fe17eeca9ef84">More...</a><br/></td></tr>
<tr class="separator:ac406ba0e9bb82e2b690fe17eeca9ef84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff66825a127c919f20174d00b667481"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#a2ff66825a127c919f20174d00b667481">add_point</a> (const <a class="el" href="a00147.html">plValues</a> &amp;point, const std::vector&lt; bool &gt; &amp;is_defined, <a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> weight=PL_ONE)</td></tr>
<tr class="memdesc:a2ff66825a127c919f20174d00b667481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a multidimensional data point with a given weight; the components of the point are specified in non-contiguously.  <a href="#a2ff66825a127c919f20174d00b667481">More...</a><br/></td></tr>
<tr class="separator:a2ff66825a127c919f20174d00b667481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35264cdc2fb9b20903f2fa41b3b1158"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#ac35264cdc2fb9b20903f2fa41b3b1158">add_point</a> (const int *point, const std::vector&lt; bool &gt; &amp;is_defined, <a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> weight=PL_ONE)</td></tr>
<tr class="memdesc:ac35264cdc2fb9b20903f2fa41b3b1158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a multidimensional data point with a given weight; the components of the point are specified in order but non-contiguously.  <a href="#ac35264cdc2fb9b20903f2fa41b3b1158">More...</a><br/></td></tr>
<tr class="separator:ac35264cdc2fb9b20903f2fa41b3b1158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637311b31b56e023f9d76497399a85a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#a637311b31b56e023f9d76497399a85a9">add_point</a> (const std::vector&lt; int &gt; &amp;point, const std::vector&lt; bool &gt; &amp;is_defined, <a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> weight=PL_ONE)</td></tr>
<tr class="memdesc:a637311b31b56e023f9d76497399a85a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a multidimensional data point with a given weight; the components of the point are specified in order but non-contiguously.  <a href="#a637311b31b56e023f9d76497399a85a9">More...</a><br/></td></tr>
<tr class="separator:a637311b31b56e023f9d76497399a85a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e861cd95a14c69287f67e71d1452e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#a51e861cd95a14c69287f67e71d1452e2">learn</a> (<a class="el" href="a00044.html">plDataDescriptor</a> &amp;data_descriptor, unsigned int n=std::numeric_limits&lt; unsigned int &gt;::max())</td></tr>
<tr class="memdesc:a51e861cd95a14c69287f67e71d1452e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Learn using the data set defined by the container 'data_descriptor'.  <a href="#a51e861cd95a14c69287f67e71d1452e2">More...</a><br/></td></tr>
<tr class="separator:a51e861cd95a14c69287f67e71d1452e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c26ed31bd4618bc7ed3d78b7868330"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#a38c26ed31bd4618bc7ed3d78b7868330">learn</a> (<a class="el" href="a00044.html">plDataDescriptor</a> &amp;data_descriptor, <a class="el" href="a00150.html">plVariablesConjunction</a> const &amp;variables, bool rewind_before_use=true)</td></tr>
<tr class="memdesc:a38c26ed31bd4618bc7ed3d78b7868330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated method, kept temporarily for compatibility purposes.  <a href="#a38c26ed31bd4618bc7ed3d78b7868330">More...</a><br/></td></tr>
<tr class="separator:a38c26ed31bd4618bc7ed3d78b7868330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0e369f876798ace9a150d6ac712bb5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b0e369f876798ace9a150d6ac712bb5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#a9b0e369f876798ace9a150d6ac712bb5">learn</a> (const std::vector&lt; int &gt; &amp;vals)</td></tr>
<tr class="memdesc:a9b0e369f876798ace9a150d6ac712bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Learn using a set of one-dimensional values. <br/></td></tr>
<tr class="separator:a9b0e369f876798ace9a150d6ac712bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f35f927dbe2b10850da1b2f3bf0f5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82f35f927dbe2b10850da1b2f3bf0f5e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#a82f35f927dbe2b10850da1b2f3bf0f5e">learn</a> (const std::vector&lt; int &gt; &amp;vals, const std::vector&lt; bool &gt; &amp;def)</td></tr>
<tr class="memdesc:a82f35f927dbe2b10850da1b2f3bf0f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Learn using a set of one-dimensional values with their definition information. <br/></td></tr>
<tr class="separator:a82f35f927dbe2b10850da1b2f3bf0f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f43a6ae034c0f55a2e924cdc898c729"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f43a6ae034c0f55a2e924cdc898c729"></a>
virtual const <br class="typebreak"/>
<a class="el" href="a00150.html">plVariablesConjunction</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#a0f43a6ae034c0f55a2e924cdc898c729">get_left_variables</a> () const =0</td></tr>
<tr class="memdesc:a0f43a6ae034c0f55a2e924cdc898c729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the left variables. <br/></td></tr>
<tr class="separator:a0f43a6ae034c0f55a2e924cdc898c729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b310e4c1b92f83e6c4562262b0f8fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07b310e4c1b92f83e6c4562262b0f8fd"></a>
virtual const <br class="typebreak"/>
<a class="el" href="a00150.html">plVariablesConjunction</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#a07b310e4c1b92f83e6c4562262b0f8fd">get_right_variables</a> () const =0</td></tr>
<tr class="memdesc:a07b310e4c1b92f83e6c4562262b0f8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the right variables. <br/></td></tr>
<tr class="separator:a07b310e4c1b92f83e6c4562262b0f8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace27aa81a912c618246bb2e8dfb5df5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace27aa81a912c618246bb2e8dfb5df5f"></a>
const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#ace27aa81a912c618246bb2e8dfb5df5f">get_variables</a> () const </td></tr>
<tr class="memdesc:ace27aa81a912c618246bb2e8dfb5df5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all variables. <br/></td></tr>
<tr class="separator:ace27aa81a912c618246bb2e8dfb5df5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466a3c6f73647ecd840ceccd0947facc"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#a466a3c6f73647ecd840ceccd0947facc">get_n_parameters</a> () const =0</td></tr>
<tr class="memdesc:a466a3c6f73647ecd840ceccd0947facc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ACTUAL number of parameters.  <a href="#a466a3c6f73647ecd840ceccd0947facc">More...</a><br/></td></tr>
<tr class="separator:a466a3c6f73647ecd840ceccd0947facc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1a461aac87a6e8752709615227dd31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a1a461aac87a6e8752709615227dd31"></a>
virtual <a class="el" href="a00103.html">plLearnObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#a2a1a461aac87a6e8752709615227dd31">clone</a> () const =0</td></tr>
<tr class="memdesc:a2a1a461aac87a6e8752709615227dd31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone the learning object. <br/></td></tr>
<tr class="separator:a2a1a461aac87a6e8752709615227dd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_a00123"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_a00123')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="a00123.html">plObject</a></td></tr>
<tr class="memitem:ae56b362a1e46e4a0c217e260324fb28a inherit pub_methods_a00123"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae56b362a1e46e4a0c217e260324fb28a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#ae56b362a1e46e4a0c217e260324fb28a">plObject</a> ()</td></tr>
<tr class="memdesc:ae56b362a1e46e4a0c217e260324fb28a inherit pub_methods_a00123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="separator:ae56b362a1e46e4a0c217e260324fb28a inherit pub_methods_a00123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9c71b1b5085c527269ffa5bdd87522 inherit pub_methods_a00123"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#a5a9c71b1b5085c527269ffa5bdd87522">~plObject</a> ()</td></tr>
<tr class="memdesc:a5a9c71b1b5085c527269ffa5bdd87522 inherit pub_methods_a00123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the object.  <a href="#a5a9c71b1b5085c527269ffa5bdd87522">More...</a><br/></td></tr>
<tr class="separator:a5a9c71b1b5085c527269ffa5bdd87522 inherit pub_methods_a00123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b86aedf034cce26568c14020bd6c6d inherit pub_methods_a00123"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#ad6b86aedf034cce26568c14020bd6c6d">to_string</a> (std::ostringstream *s=0) const </td></tr>
<tr class="memdesc:ad6b86aedf034cce26568c14020bd6c6d inherit pub_methods_a00123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object as a string.  <a href="#ad6b86aedf034cce26568c14020bd6c6d">More...</a><br/></td></tr>
<tr class="separator:ad6b86aedf034cce26568c14020bd6c6d inherit pub_methods_a00123"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_a00089"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_a00089')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="a00089.html">plLearner</a></td></tr>
<tr class="memitem:a07b91d94adf4d51741f784b160425de8 inherit pub_static_methods_a00089"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00079.html">plJointDistribution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00089.html#a07b91d94adf4d51741f784b160425de8">learn_model_parameters</a> (const std::vector&lt; <a class="el" href="a00103.html">plLearnObject</a> * &gt; &amp;learn_objects, <a class="el" href="a00044.html">plDataDescriptor</a> &amp;data_descriptor)</td></tr>
<tr class="memdesc:a07b91d94adf4d51741f784b160425de8 inherit pub_static_methods_a00089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Learns the parameters of a model.  <a href="#a07b91d94adf4d51741f784b160425de8">More...</a><br/></td></tr>
<tr class="separator:a07b91d94adf4d51741f784b160425de8 inherit pub_static_methods_a00089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369f40ceb5fadfb03e61cea54f2229c2 inherit pub_static_methods_a00089"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00079.html">plJointDistribution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00089.html#a369f40ceb5fadfb03e61cea54f2229c2">learn_model_parameters</a> (const std::vector&lt; <a class="el" href="a00103.html">plLearnObject</a> * &gt; &amp;learn_objects, const <a class="el" href="a00037.html">plComputableObjectList</a> &amp;init_distribs, <a class="el" href="a00044.html">plDataDescriptor</a> &amp;data_descriptor)</td></tr>
<tr class="memdesc:a369f40ceb5fadfb03e61cea54f2229c2 inherit pub_static_methods_a00089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Learns the parameters of a model.  <a href="#a369f40ceb5fadfb03e61cea54f2229c2">More...</a><br/></td></tr>
<tr class="separator:a369f40ceb5fadfb03e61cea54f2229c2 inherit pub_static_methods_a00089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_a00123"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_a00123')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="a00123.html">plObject</a></td></tr>
<tr class="memitem:af418d39625a6f1175e573f059bcdf3f9 inherit pro_methods_a00123"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#af418d39625a6f1175e573f059bcdf3f9">Output</a> (std::ostream &amp;out) const =0</td></tr>
<tr class="memdesc:af418d39625a6f1175e573f059bcdf3f9 inherit pro_methods_a00123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the object at the <em>out</em> stream.  <a href="#af418d39625a6f1175e573f059bcdf3f9">More...</a><br/></td></tr>
<tr class="separator:af418d39625a6f1175e573f059bcdf3f9 inherit pro_methods_a00123"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the base class of all incremental (adaptive) learning objects. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a32eb3b5401e5ee340912723ed1a60e8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">plLearnObject::plLearnObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>variables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor using a set of variables. </p>

</div>
</div>
<a class="anchor" id="a6c64d0ef2f9ec1692664a5dc42b50495"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">plLearnObject::plLearnObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a33a76a2cd1a2ddf0a151950cbe625f94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool plLearnObject::add_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00147.html">plValues</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td>
          <td class="paramname"><em>weight</em> = <code>PL_ONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a data point with a given weight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>Data point to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>Weight of the added point. If <em>weight</em> is an integer, add_point(x, weight) is equivalent to doing <em>weight</em> times add_point(x).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if and only if the point could be added. </dd></dl>

</div>
</div>
<a class="anchor" id="ad01c365472c59e3947b4732e389e4b6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool plLearnObject::add_point </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td>
          <td class="paramname"><em>weight</em> = <code>PL_ONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a multidimensional data point with a given weight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>Data point to add, as a C array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>Weight of the added point. If <em>weight</em> is an integer, add_point(x, weight) is equivalent to doing <em>weight</em> times add_point(x).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if and only if the point could be added. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a011ce64e6e56a73c0bef15b3473a4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool plLearnObject::add_point </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td>
          <td class="paramname"><em>weight</em> = <code>PL_ONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a multidimensional data point with a given weight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>Data point to add, as an STL vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>Weight of the added point. If <em>weight</em> is an integer, add_point(x, weight) is equivalent to doing <em>weight</em> times add_point(x).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if and only if the point could be added. </dd></dl>

</div>
</div>
<a class="anchor" id="ac406ba0e9bb82e2b690fe17eeca9ef84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool plLearnObject::add_point </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td>
          <td class="paramname"><em>weight</em> = <code>PL_ONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a unidimensional data point with a given weight. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>Data point to add. It must be convertible to the type of data of the variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>Weight of the added point. If <em>weight</em> is an integer, add_point(x, weight) is equivalent to doing <em>weight</em> times add_point(x).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if and only if the point could be added. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ff66825a127c919f20174d00b667481"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool plLearnObject::add_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00147.html">plValues</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>is_defined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td>
          <td class="paramname"><em>weight</em> = <code>PL_ONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a multidimensional data point with a given weight; the components of the point are specified in non-contiguously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>Data point to add, as a <em><a class="el" href="a00147.html" title="A plValues is an object storing the values of a set of variables. ">plValues</a></em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_defined</td><td>Indicates which components should be used for learning. is_defined[i] should be <em>true</em> if and only if point[i] is to be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>Weight of the added point. If <em>weight</em> is an integer, add_point(x, weight) is equivalent to doing <em>weight</em> times add_point(x).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if and only if the point could be added. </dd></dl>

</div>
</div>
<a class="anchor" id="ac35264cdc2fb9b20903f2fa41b3b1158"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool plLearnObject::add_point </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>is_defined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td>
          <td class="paramname"><em>weight</em> = <code>PL_ONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a multidimensional data point with a given weight; the components of the point are specified in order but non-contiguously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>Data point to add, as a C array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_defined</td><td>Indicates which components should be used for learning. is_defined[i] should be <em>true</em> if and only if point[i] is to be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>Weight of the added point. If <em>weight</em> is an integer, add_point(x, weight) is equivalent to doing <em>weight</em> times add_point(x).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if and only if the point could be added. </dd></dl>

</div>
</div>
<a class="anchor" id="a637311b31b56e023f9d76497399a85a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool plLearnObject::add_point </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>is_defined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td>
          <td class="paramname"><em>weight</em> = <code>PL_ONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a multidimensional data point with a given weight; the components of the point are specified in order but non-contiguously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>Data point to add, as an STL vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_defined</td><td>Indicates which components should be used for learning. is_defined[i] should be <em>true</em> if and only if point[i] is to be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>Weight of the added point. If <em>weight</em> is an integer, add_point(x, weight) is equivalent to doing <em>weight</em> times add_point(x).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if and only if the point could be added. </dd></dl>

</div>
</div>
<a class="anchor" id="a90e8e04d6debea72bc319abeb68ee130"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00036.html">plComputableObject</a> plLearnObject::get_computable_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the computable object corresponding to the learnt distribution. </p>
<p>Constructs and returns the computable object (conditional or non conditional distribution) corresponding to the current state of this learner </p>

<p>Implemented in <a class="el" href="a00091.html#a30e7ee8585a4d7c93ed2a7d04fef676a">plLearnFrozenDistribution</a>, <a class="el" href="a00088.html#a276b04ce01efe523d197794d02dfc9ac">plLearnDistribVector</a>, <a class="el" href="a00086.html#a01fb6a45037d081ceaca6117f3d57b4d">plLearnCndObject</a>, and <a class="el" href="a00121.html#a278ed57b4813f9584cc24c1d63319863">plNonCndLearnObject</a>.</p>

<p>Referenced by <a class="el" href="a00091.html#a0f0069ddd6661158c0b25bb3ad54061d">plLearnFrozenDistribution::Output()</a>.</p>

</div>
</div>
<a class="anchor" id="a466a3c6f73647ecd840ceccd0947facc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int plLearnObject::get_n_parameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ACTUAL number of parameters. </p>
<p>It could be different from the number of parameters returned by get_parameters.</p>
<p>For example, the actual number of parameters of a N dimensional normal distribution is N + N*(N+1)/2 because the covariance matrix is symmetric. </p>

<p>Implemented in <a class="el" href="a00091.html#a24f40b57e10210f53d419619eb6ed208">plLearnFrozenDistribution</a>, <a class="el" href="a00088.html#affdced03c3824540b3f49381406e8692">plLearnDistribVector</a>, <a class="el" href="a00012.html#afda1d1921d8b9e03515ca21f2b476e2a">plBayesLearnLogNormalWithKnownShape</a>, <a class="el" href="a00013.html#aa1f5827405675f45b698476bc66e928c">plBayesLearnNdNormalWithKnownVariance</a>, <a class="el" href="a00094.html#a4993629388a2abbb15887ffb2ea28eb7">plLearnHistogram</a>, <a class="el" href="a00007.html#acab714cbc288a3244bf078799d28e535">plBayesLearn1dNormalWithKnownMean</a>, <a class="el" href="a00010.html#a8c624c3776e879f1d4da3d884b5fdc7c">plBayesLearnExponential</a>, <a class="el" href="a00102.html#a7d4a9eec33b23a703750c4a90bbfcd06">plLearnNoisyOR</a>, <a class="el" href="a00016.html#a5c7b8bc4634fb6aaf1ab9ce7b46ace3f">plBayesLearnProbTable</a>, <a class="el" href="a00009.html#a48d5b4921331643706f44b6d620d8bee">plBayesLearnBinomial</a>, <a class="el" href="a00087.html#a993e7176365c2b5d86b7a1e464e8db20">plLearnDistributionTable</a>, <a class="el" href="a00008.html#adbc2724eba2b48be97f75dc296d6cbc8">plBayesLearn1dNormalWithKnownStandardDeviation</a>, <a class="el" href="a00084.html#aeace39d4cbc4cfcadd07e2ddff5a6b4b">plLearn1dNormal</a>, <a class="el" href="a00105.html#afef528ddfd067819e0662e1ef1b8265a">plLearnSoftmax</a>, <a class="el" href="a00011.html#a47710234d9649a38ca759d491c2aeac6">plBayesLearnGamma</a>, <a class="el" href="a00015.html#ac384247eadfa2417f48ff3e073ece762">plBayesLearnPoisson</a>, <a class="el" href="a00100.html#a229f4cd77b44cd6687d4c8c75e7bb1f5">plLearnMixtureModel</a>, <a class="el" href="a00101.html#a6ac7920ef8a0e56777e2e7e93cec5d2f">plLearnNdNormal</a>, <a class="el" href="a00090.html#a954319fd13477eb68d3538bd62a39760">plLearnExponential</a>, <a class="el" href="a00104.html#a9924cb71a1ee088ce96a06691629c1f6">plLearnPoisson</a>, <a class="el" href="a00097.html#a6168730df7d21b39ff4c28d4940379d8">plLearnLinearRegression</a>, <a class="el" href="a00085.html#a24804c125a5c1faa36cfe8dd8357365e">plLearnBeta</a>, <a class="el" href="a00099.html#a2b608e6ad648075165144b964268e94c">plLearnLogNormal</a>, <a class="el" href="a00106.html#ae5025e7163d639fc8e3863226ff91b98">plLearnSoftmaxFamily</a>, <a class="el" href="a00098.html#a71cb7fb0bb81b755725d05893becee06">plLearnLinearRegressionFamily</a>, <a class="el" href="a00092.html#a284f5b5134599993cb9447529bf32428">plLearnGamma</a>, and <a class="el" href="a00107.html#a4df838d726be8595caddc7697888ca65">plLearnSparseHistogram</a>.</p>

</div>
</div>
<a class="anchor" id="ab938048d12396abd762a7a0983b97dca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int plLearnObject::get_nsamples </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of the points used in learning (i.e. </p>
<p>added using the <em>add_point</em> methods). </p>

</div>
</div>
<a class="anchor" id="a40e1a79f986fbd5eb549a602cc3f8e06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> plLearnObject::get_total_weight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sum of weights of the points used in learning (i.e. </p>
<p>added using <a class="el" href="a00103.html#a33a76a2cd1a2ddf0a151950cbe625f94" title="Adds a data point with a given weight. ">add_point()</a>). </p>

</div>
</div>
<a class="anchor" id="ad18572847fbb6612558e452c63baae61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void plLearnObject::get_total_weight </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sum of weights of the points used in learning (i.e. </p>
<p>added using the <em>add_point</em> methods). </p>

<p>Reimplemented in <a class="el" href="a00088.html#a330e4fb1b691162a0f0f8408b8c74cdd">plLearnDistribVector</a>.</p>

</div>
</div>
<a class="anchor" id="a51e861cd95a14c69287f67e71d1452e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int plLearnObject::learn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html">plDataDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>data_descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em> = <code>std::numeric_limits&lt;&#160;unsigned&#160;int&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Learn using the data set defined by the container 'data_descriptor'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_descriptor</td><td>the data set to be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number of data rows to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of the inserted points on success. Returns a negative value if the data descriptor is not OK (eg, CSV file does not exist, mysql server is not responding,...).</dd></dl>
<p>It is the responsibility of the caller to setup the data descriptor properly before calling this method, for instance by calling rewind() on it if necessary. Also, this method does not attempt to rewind() the data descriptor before returning. </p>

</div>
</div>
<a class="anchor" id="a38c26ed31bd4618bc7ed3d78b7868330"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int plLearnObject::learn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html">plDataDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>data_descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00150.html">plVariablesConjunction</a> const &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rewind_before_use</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated method, kept temporarily for compatibility purposes. </p>
<p>Identical in function to the above <a class="el" href="a00103.html#a51e861cd95a14c69287f67e71d1452e2" title="Learn using the data set defined by the container &#39;data_descriptor&#39;. ">learn()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_descriptor</td><td>The data set to use for learning. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">variables</td><td>Variables in the data set. This should be equal to data_descriptor.observed_variables(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rewind_before_use</td><td>Whether the method should rewind the data descriptor before using it. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="a00044.html#a2fe471cafd783589838cdd036009d303">plDataDescriptor::observed_variables()</a>, <a class="el" href="a00044.html#a4b13c4da8b662b756dbcfd9e3c5b796a">plDataDescriptor::rewind()</a>, and <a class="el" href="a00063.html#a11e178312849e6102a88165b1a5ea82a">plError::warn()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jan 31 2015 01:13:28 for ProBT by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
