<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ProBT: plEMLearner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ProBT
   &#160;<span id="projectnumber">2.3.99</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="a00525.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">plEMLearner Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class implements a generic EM (Expectation-Maximization) learning algorithm (using incomplete data sets).  
 <a href="a00061.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for plEMLearner:</div>
<div class="dyncontent">
<div class="center"><img src="a00526.png" border="0" usemap="#pl_e_m_learner_inherit__map" alt="Inheritance graph"/></div>
<map name="pl_e_m_learner_inherit__map" id="pl_e_m_learner_inherit__map">
<area shape="rect" id="node2" href="a00089.html" title="This is the base class of all learning objects. " alt="" coords="15,80,88,107"/><area shape="rect" id="node3" href="a00123.html" title="Used as the base class of all ProBT API objects. " alt="" coords="17,5,87,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for plEMLearner:</div>
<div class="dyncontent">
<div class="center"><img src="a00527.png" border="0" usemap="#pl_e_m_learner_coll__map" alt="Collaboration graph"/></div>
<map name="pl_e_m_learner_coll__map" id="pl_e_m_learner_coll__map">
<area shape="rect" id="node2" href="a00089.html" title="This is the base class of all learning objects. " alt="" coords="15,80,88,107"/><area shape="rect" id="node3" href="a00123.html" title="Used as the base class of all ProBT API objects. " alt="" coords="17,5,87,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae368406ac1cfa24034fb564c022d517a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#ae368406ac1cfa24034fb564c022d517a">plEMLearner</a> (const <a class="el" href="a00037.html">plComputableObjectList</a> &amp;init_distribs, const std::vector&lt; <a class="el" href="a00103.html">plLearnObject</a> * &gt; &amp;learn_objects)</td></tr>
<tr class="memdesc:ae368406ac1cfa24034fb564c022d517a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ae368406ac1cfa24034fb564c022d517a">More...</a><br/></td></tr>
<tr class="separator:ae368406ac1cfa24034fb564c022d517a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f174d140130eedd998d440bc1324738"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a6f174d140130eedd998d440bc1324738">plEMLearner</a> (const std::vector&lt; <a class="el" href="a00103.html">plLearnObject</a> * &gt; &amp;learn_objects)</td></tr>
<tr class="memdesc:a6f174d140130eedd998d440bc1324738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a6f174d140130eedd998d440bc1324738">More...</a><br/></td></tr>
<tr class="separator:a6f174d140130eedd998d440bc1324738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00d7b73cd53c6df11b0a3026df750ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab00d7b73cd53c6df11b0a3026df750ae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#ab00d7b73cd53c6df11b0a3026df750ae">plEMLearner</a> (const <a class="el" href="a00061.html">plEMLearner</a> &amp;other)</td></tr>
<tr class="memdesc:ab00d7b73cd53c6df11b0a3026df750ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr class="separator:ab00d7b73cd53c6df11b0a3026df750ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2548fbee3ad9a83dd89035fdac7d1802"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2548fbee3ad9a83dd89035fdac7d1802"></a>
<a class="el" href="a00061.html">plEMLearner</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a2548fbee3ad9a83dd89035fdac7d1802">operator=</a> (const <a class="el" href="a00061.html">plEMLearner</a> &amp;other)</td></tr>
<tr class="memdesc:a2548fbee3ad9a83dd89035fdac7d1802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment. <br/></td></tr>
<tr class="separator:a2548fbee3ad9a83dd89035fdac7d1802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a7c97b3920dbc8e9804d3db50fcd8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47a7c97b3920dbc8e9804d3db50fcd8f"></a>
<a class="el" href="a00061.html">plEMLearner</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a47a7c97b3920dbc8e9804d3db50fcd8f">assign_from</a> (const <a class="el" href="a00061.html">plEMLearner</a> &amp;other)</td></tr>
<tr class="memdesc:a47a7c97b3920dbc8e9804d3db50fcd8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="a00061.html#a2548fbee3ad9a83dd89035fdac7d1802" title="Assignment. ">operator=()</a> <br/></td></tr>
<tr class="separator:a47a7c97b3920dbc8e9804d3db50fcd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f2655fa64ba92d5969bd70b467dd69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a82f2655fa64ba92d5969bd70b467dd69">plEMLearner</a> (const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;data_descriptor_vars, const std::vector&lt; <a class="el" href="a00103.html">plLearnObject</a> * &gt; &amp;learn_objects)</td></tr>
<tr class="memdesc:a82f2655fa64ba92d5969bd70b467dd69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated constructor, kept temporarily for compatibility purposes.  <a href="#a82f2655fa64ba92d5969bd70b467dd69">More...</a><br/></td></tr>
<tr class="separator:a82f2655fa64ba92d5969bd70b467dd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a355302e91059aeb83a620562c7cec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#af4a355302e91059aeb83a620562c7cec">plEMLearner</a> (const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;data_descriptor_vars, const <a class="el" href="a00037.html">plComputableObjectList</a> &amp;init_distribs, const std::vector&lt; <a class="el" href="a00103.html">plLearnObject</a> * &gt; &amp;learn_objects)</td></tr>
<tr class="memdesc:af4a355302e91059aeb83a620562c7cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated constructor, kept temporarily for compatibility purposes.  <a href="#af4a355302e91059aeb83a620562c7cec">More...</a><br/></td></tr>
<tr class="separator:af4a355302e91059aeb83a620562c7cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64413bb30745df78605999a144eada5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#aa64413bb30745df78605999a144eada5">plEMLearner</a> ()</td></tr>
<tr class="memdesc:aa64413bb30745df78605999a144eada5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#aa64413bb30745df78605999a144eada5">More...</a><br/></td></tr>
<tr class="separator:aa64413bb30745df78605999a144eada5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fd9657afbef40ac3b574eadf2930b8"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#ad1fd9657afbef40ac3b574eadf2930b8">~plEMLearner</a> ()</td></tr>
<tr class="memdesc:ad1fd9657afbef40ac3b574eadf2930b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ad1fd9657afbef40ac3b574eadf2930b8">More...</a><br/></td></tr>
<tr class="separator:ad1fd9657afbef40ac3b574eadf2930b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42ceed1b8ce27f565257e3ee3cde3bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af42ceed1b8ce27f565257e3ee3cde3bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#af42ceed1b8ce27f565257e3ee3cde3bd">reset</a> ()</td></tr>
<tr class="memdesc:af42ceed1b8ce27f565257e3ee3cde3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the learner to its initial state. <br/></td></tr>
<tr class="separator:af42ceed1b8ce27f565257e3ee3cde3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63364534b4ab6b0af9647873833f820"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#ac63364534b4ab6b0af9647873833f820">run</a> (<a class="el" href="a00044.html">plDataDescriptor</a> &amp;data_descriptor, unsigned int nit)</td></tr>
<tr class="memdesc:ac63364534b4ab6b0af9647873833f820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the EM algorithm for a given number of iterations.  <a href="#ac63364534b4ab6b0af9647873833f820">More...</a><br/></td></tr>
<tr class="separator:ac63364534b4ab6b0af9647873833f820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8979643fb182b7a1a0502bc0bf440046"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a8979643fb182b7a1a0502bc0bf440046">run</a> (<a class="el" href="a00044.html">plDataDescriptor</a> &amp;data_descriptor, int nit)</td></tr>
<tr class="memdesc:a8979643fb182b7a1a0502bc0bf440046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the EM algorithm for a given number of iterations.  <a href="#a8979643fb182b7a1a0502bc0bf440046">More...</a><br/></td></tr>
<tr class="separator:a8979643fb182b7a1a0502bc0bf440046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc21aa0b4ae4602f0281292dbcfbc89"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a9cc21aa0b4ae4602f0281292dbcfbc89">run</a> (<a class="el" href="a00044.html">plDataDescriptor</a> &amp;data_descriptor, double convergence_loglikelihood_threshold=0.0001, unsigned int max_it=std::numeric_limits&lt; unsigned int &gt;::max())</td></tr>
<tr class="memdesc:a9cc21aa0b4ae4602f0281292dbcfbc89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the EM algorithm until convergence:<br/>
 | log-likelihood(t) - log-likelihood(t-1) | / | (log-likelihood(t) + log-likelihood(t-1)/2.0 | &lt; convergence_loglikelihood_threshold.  <a href="#a9cc21aa0b4ae4602f0281292dbcfbc89">More...</a><br/></td></tr>
<tr class="separator:a9cc21aa0b4ae4602f0281292dbcfbc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac6a50be1f56ac7874836277363fe73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a6ac6a50be1f56ac7874836277363fe73">run</a> (<a class="el" href="a00044.html">plDataDescriptor</a> &amp;data_descriptor, unsigned int nit, std::vector&lt; <a class="el" href="a00147.html">plValues</a> &gt; &amp;missing_most_probable_value, std::vector&lt; std::vector&lt; <a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> &gt; &gt; &amp;missing_probability_table)</td></tr>
<tr class="memdesc:a6ac6a50be1f56ac7874836277363fe73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the EM algorithm for a given number of iterations and return the last iteration info.  <a href="#a6ac6a50be1f56ac7874836277363fe73">More...</a><br/></td></tr>
<tr class="separator:a6ac6a50be1f56ac7874836277363fe73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ab6bcbb0081c66131f5b6566d692c8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00036.html">plComputableObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a47ab6bcbb0081c66131f5b6566d692c8">get_distribution</a> (unsigned int n) const </td></tr>
<tr class="memdesc:a47ab6bcbb0081c66131f5b6566d692c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current estimation of the <em>nth</em> distribution.  <a href="#a47ab6bcbb0081c66131f5b6566d692c8">More...</a><br/></td></tr>
<tr class="separator:a47ab6bcbb0081c66131f5b6566d692c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e2c44fb839fa4740cc0e36710ef0b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a70e2c44fb839fa4740cc0e36710ef0b9">set_distribution</a> (unsigned int n, const <a class="el" href="a00036.html">plComputableObject</a> &amp;new_distrib)</td></tr>
<tr class="memdesc:a70e2c44fb839fa4740cc0e36710ef0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <em>nth</em> distribution.  <a href="#a70e2c44fb839fa4740cc0e36710ef0b9">More...</a><br/></td></tr>
<tr class="separator:a70e2c44fb839fa4740cc0e36710ef0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d512889251d5afa38ef2a3aeb5a8baa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00079.html">plJointDistribution</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a6d512889251d5afa38ef2a3aeb5a8baa">get_joint_distribution</a> () const </td></tr>
<tr class="memdesc:a6d512889251d5afa38ef2a3aeb5a8baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the joint distribution (model) with the current learnt parameters.  <a href="#a6d512889251d5afa38ef2a3aeb5a8baa">More...</a><br/></td></tr>
<tr class="separator:a6d512889251d5afa38ef2a3aeb5a8baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f9c022dd7233e81e531d1e89874266"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#ad6f9c022dd7233e81e531d1e89874266">set_same_missing_variables</a> (bool same=true)</td></tr>
<tr class="memdesc:ad6f9c022dd7233e81e531d1e89874266"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 'same' = true, the learning data will contain missing values for the same variables in all data rows (unobserved variables).  <a href="#ad6f9c022dd7233e81e531d1e89874266">More...</a><br/></td></tr>
<tr class="separator:ad6f9c022dd7233e81e531d1e89874266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a5b5a6a8b16891c92ef28ddbb8920e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#aa8a5b5a6a8b16891c92ef28ddbb8920e">output_distributions</a> (std::ostream &amp;out=std::cout) const </td></tr>
<tr class="memdesc:aa8a5b5a6a8b16891c92ef28ddbb8920e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the current learnt distributions on the output stream 'out'.  <a href="#aa8a5b5a6a8b16891c92ef28ddbb8920e">More...</a><br/></td></tr>
<tr class="separator:aa8a5b5a6a8b16891c92ef28ddbb8920e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ebe11ad20fc1d68eba102a7771145f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#ae0ebe11ad20fc1d68eba102a7771145f">set_distributions_display</a> (bool display=true)</td></tr>
<tr class="memdesc:ae0ebe11ad20fc1d68eba102a7771145f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets distributions displaying, after each iteration, to ON or OFF.  <a href="#ae0ebe11ad20fc1d68eba102a7771145f">More...</a><br/></td></tr>
<tr class="separator:ae0ebe11ad20fc1d68eba102a7771145f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb674eba8cf499122f31882a59e38c94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#acb674eba8cf499122f31882a59e38c94">set_distributions_display_stream</a> (std::ostream &amp;out)</td></tr>
<tr class="memdesc:acb674eba8cf499122f31882a59e38c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets distributions displaying stream to 'out'.  <a href="#acb674eba8cf499122f31882a59e38c94">More...</a><br/></td></tr>
<tr class="separator:acb674eba8cf499122f31882a59e38c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e5a86f1b4ed260780af20fb0e1f17d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a69e5a86f1b4ed260780af20fb0e1f17d">distribution_set_frozen</a> (unsigned int n, bool freeze=true)</td></tr>
<tr class="memdesc:a69e5a86f1b4ed260780af20fb0e1f17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Freezes the nth distribution to its current state.  <a href="#a69e5a86f1b4ed260780af20fb0e1f17d">More...</a><br/></td></tr>
<tr class="separator:a69e5a86f1b4ed260780af20fb0e1f17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2261d462365ea936f9e2f65d9a6ece3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a2261d462365ea936f9e2f65d9a6ece3b">use_junction_tree</a> (bool use_jt=true)</td></tr>
<tr class="memdesc:a2261d462365ea936f9e2f65d9a6ece3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or unsets the use of a junction tree for inference.  <a href="#a2261d462365ea936f9e2f65d9a6ece3b">More...</a><br/></td></tr>
<tr class="separator:a2261d462365ea936f9e2f65d9a6ece3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bb9bfd9bd98a018f6dffd80e9844f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a45bb9bfd9bd98a018f6dffd80e9844f2">set_mc_integration_npoints</a> (unsigned int npoints)</td></tr>
<tr class="memdesc:a45bb9bfd9bd98a018f6dffd80e9844f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows to set the marginalization mode to 'monte carlo' using 'npoints' sample points.  <a href="#a45bb9bfd9bd98a018f6dffd80e9844f2">More...</a><br/></td></tr>
<tr class="separator:a45bb9bfd9bd98a018f6dffd80e9844f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1278ff4a46d98969b9c16663371836"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a9e1278ff4a46d98969b9c16663371836">set_approximate_compilation_time</a> (double compilation_time_in_seconds)</td></tr>
<tr class="memdesc:a9e1278ff4a46d98969b9c16663371836"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows to set the compilation mode to 'approximate' using a maximal time of 'compilation_time_in_seconds' (in seconds) when constructing the distribution P(Missing | Observed) in the E step.  <a href="#a9e1278ff4a46d98969b9c16663371836">More...</a><br/></td></tr>
<tr class="separator:a9e1278ff4a46d98969b9c16663371836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35587d45c73272bf8101d002bd3d64e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#af35587d45c73272bf8101d002bd3d64e">set_approximate_compilation_nsamples</a> (unsigned int n)</td></tr>
<tr class="memdesc:af35587d45c73272bf8101d002bd3d64e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows to set the compilation mode to 'approximate' using a number of samples of 'n' when constructing the distribution P(Missing | Observed) in the E step.  <a href="#af35587d45c73272bf8101d002bd3d64e">More...</a><br/></td></tr>
<tr class="separator:af35587d45c73272bf8101d002bd3d64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da434cc62a73430ea2a4839fdc6b94a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a2da434cc62a73430ea2a4839fdc6b94a">set_use_sampling_for_compilation</a> (bool use_it=true)</td></tr>
<tr class="memdesc:a2da434cc62a73430ea2a4839fdc6b94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows to set the methode to be used for constructing the distribution P(Missing | Observed) in the E step when using approximate mode (using set_approximate_compilation_time or set_approximate_compilation_nsamples).  <a href="#a2da434cc62a73430ea2a4839fdc6b94a">More...</a><br/></td></tr>
<tr class="separator:a2da434cc62a73430ea2a4839fdc6b94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4ad968d02e0c811b9073a3b97913c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a7d4ad968d02e0c811b9073a3b97913c8">compute_missing_values_infos</a> (<a class="el" href="a00044.html">plDataDescriptor</a> &amp;data_descriptor, std::vector&lt; <a class="el" href="a00147.html">plValues</a> &gt; &amp;missing_most_probable_value, std::vector&lt; std::vector&lt; <a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> &gt; &gt; &amp;missing_probability_table)</td></tr>
<tr class="memdesc:a7d4ad968d02e0c811b9073a3b97913c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute for each data row: (i) the values with the highest probability for the missing variables argmax P(Missing)  <a href="#a7d4ad968d02e0c811b9073a3b97913c8">More...</a><br/></td></tr>
<tr class="separator:a7d4ad968d02e0c811b9073a3b97913c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3fa082a3045505d48489e1b8218458"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae3fa082a3045505d48489e1b8218458"></a>
<a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#aae3fa082a3045505d48489e1b8218458">compute_loglikelihood</a> (<a class="el" href="a00044.html">plDataDescriptor</a> &amp;data_descriptor, std::vector&lt; <a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> &gt; &amp;data_loglikelihood)</td></tr>
<tr class="memdesc:aae3fa082a3045505d48489e1b8218458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and return, for each data row, the log-likelihood of the data given the current parameters estimation. <br/></td></tr>
<tr class="separator:aae3fa082a3045505d48489e1b8218458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa919eec9977c3d48962135958cd79fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa919eec9977c3d48962135958cd79fe"></a>
<a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#aaa919eec9977c3d48962135958cd79fe">compute_loglikelihood</a> (<a class="el" href="a00044.html">plDataDescriptor</a> &amp;data_descriptor)</td></tr>
<tr class="memdesc:aaa919eec9977c3d48962135958cd79fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the log-likelihood of the data given the current parameters estimation. <br/></td></tr>
<tr class="separator:aaa919eec9977c3d48962135958cd79fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8e36bfe3f188a739495f81a0cbb063"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d8e36bfe3f188a739495f81a0cbb063"></a>
<a class="el" href="a00037.html">plComputableObjectList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a2d8e36bfe3f188a739495f81a0cbb063">get_computable_object_list</a> () const </td></tr>
<tr class="memdesc:a2d8e36bfe3f188a739495f81a0cbb063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of distributions (computable object) corresponding to the current estimation. <br/></td></tr>
<tr class="separator:a2d8e36bfe3f188a739495f81a0cbb063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6aedebdc40b36457393f4aaf583f91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c6aedebdc40b36457393f4aaf583f91"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a4c6aedebdc40b36457393f4aaf583f91">set_trace_loglikelihood</a> (bool trace_it=true)</td></tr>
<tr class="memdesc:a4c6aedebdc40b36457393f4aaf583f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/unset log-likelihood evolution output. <br/></td></tr>
<tr class="separator:a4c6aedebdc40b36457393f4aaf583f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416979cf591d20a5c422d78ff338ddde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00103.html">plLearnObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a416979cf591d20a5c422d78ff338ddde">get_learn_object</a> (unsigned int n) const </td></tr>
<tr class="memdesc:a416979cf591d20a5c422d78ff338ddde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the <em>nth</em> internal learn object in the same order as passed to the constuctor.  <a href="#a416979cf591d20a5c422d78ff338ddde">More...</a><br/></td></tr>
<tr class="separator:a416979cf591d20a5c422d78ff338ddde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8dedf8373a4766e969bb246fd28a484"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8dedf8373a4766e969bb246fd28a484"></a>
const std::vector<br class="typebreak"/>
&lt; <a class="el" href="a00103.html">plLearnObject</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#ae8dedf8373a4766e969bb246fd28a484">get_learn_objects</a> () const </td></tr>
<tr class="memdesc:ae8dedf8373a4766e969bb246fd28a484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of the stored learn objects. <br/></td></tr>
<tr class="separator:ae8dedf8373a4766e969bb246fd28a484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1218189f1eb3cac3c25032c359cfb851"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a1218189f1eb3cac3c25032c359cfb851">iteration</a> (<a class="el" href="a00044.html">plDataDescriptor</a> &amp;data_descriptor)</td></tr>
<tr class="memdesc:a1218189f1eb3cac3c25032c359cfb851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the EM algorithm for one iteration.  <a href="#a1218189f1eb3cac3c25032c359cfb851">More...</a><br/></td></tr>
<tr class="separator:a1218189f1eb3cac3c25032c359cfb851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad8d2d22a608ba82e1ebf3325ebcb9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a6ad8d2d22a608ba82e1ebf3325ebcb9c">iteration</a> (<a class="el" href="a00044.html">plDataDescriptor</a> &amp;data_descriptor, std::vector&lt; <a class="el" href="a00147.html">plValues</a> &gt; &amp;missing_most_probable_value, std::vector&lt; std::vector&lt; <a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> &gt; &gt; &amp;missing_probability_table)</td></tr>
<tr class="memdesc:a6ad8d2d22a608ba82e1ebf3325ebcb9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the EM algorithm for oneiterations and return this last iteration info.  <a href="#a6ad8d2d22a608ba82e1ebf3325ebcb9c">More...</a><br/></td></tr>
<tr class="separator:a6ad8d2d22a608ba82e1ebf3325ebcb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1664cffe982cc8c9852fd34049fca438"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a1664cffe982cc8c9852fd34049fca438">get_last_computed_loglikelihood</a> () const </td></tr>
<tr class="memdesc:a1664cffe982cc8c9852fd34049fca438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last cached loglikelihood value.  <a href="#a1664cffe982cc8c9852fd34049fca438">More...</a><br/></td></tr>
<tr class="separator:a1664cffe982cc8c9852fd34049fca438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05bc8e10c711679febda8a00d3d161c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab05bc8e10c711679febda8a00d3d161c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#ab05bc8e10c711679febda8a00d3d161c">set_trace_observation_and_inference_info</a> (bool set_it=true)</td></tr>
<tr class="memdesc:ab05bc8e10c711679febda8a00d3d161c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/unset observation and inference information for each data record. <br/></td></tr>
<tr class="separator:ab05bc8e10c711679febda8a00d3d161c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c0d0d32bd148697f00b1716b749e54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0c0d0d32bd148697f00b1716b749e54"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#aa0c0d0d32bd148697f00b1716b749e54">get_n_parameters</a> () const </td></tr>
<tr class="memdesc:aa0c0d0d32bd148697f00b1716b749e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of parameters to be learnt. <br/></td></tr>
<tr class="separator:aa0c0d0d32bd148697f00b1716b749e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_a00123"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_a00123')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="a00123.html">plObject</a></td></tr>
<tr class="memitem:ae56b362a1e46e4a0c217e260324fb28a inherit pub_methods_a00123"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae56b362a1e46e4a0c217e260324fb28a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#ae56b362a1e46e4a0c217e260324fb28a">plObject</a> ()</td></tr>
<tr class="memdesc:ae56b362a1e46e4a0c217e260324fb28a inherit pub_methods_a00123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="separator:ae56b362a1e46e4a0c217e260324fb28a inherit pub_methods_a00123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9c71b1b5085c527269ffa5bdd87522 inherit pub_methods_a00123"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#a5a9c71b1b5085c527269ffa5bdd87522">~plObject</a> ()</td></tr>
<tr class="memdesc:a5a9c71b1b5085c527269ffa5bdd87522 inherit pub_methods_a00123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the object.  <a href="#a5a9c71b1b5085c527269ffa5bdd87522">More...</a><br/></td></tr>
<tr class="separator:a5a9c71b1b5085c527269ffa5bdd87522 inherit pub_methods_a00123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b86aedf034cce26568c14020bd6c6d inherit pub_methods_a00123"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#ad6b86aedf034cce26568c14020bd6c6d">to_string</a> (std::ostringstream *s=0) const </td></tr>
<tr class="memdesc:ad6b86aedf034cce26568c14020bd6c6d inherit pub_methods_a00123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object as a string.  <a href="#ad6b86aedf034cce26568c14020bd6c6d">More...</a><br/></td></tr>
<tr class="separator:ad6b86aedf034cce26568c14020bd6c6d inherit pub_methods_a00123"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a525e0d7b1468ceb911418575aa268fad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html#a525e0d7b1468ceb911418575aa268fad">Output</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a525e0d7b1468ceb911418575aa268fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the object at the <em>out</em> stream.  <a href="#a525e0d7b1468ceb911418575aa268fad">More...</a><br/></td></tr>
<tr class="separator:a525e0d7b1468ceb911418575aa268fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_a00089"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_a00089')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="a00089.html">plLearner</a></td></tr>
<tr class="memitem:a07b91d94adf4d51741f784b160425de8 inherit pub_static_methods_a00089"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00079.html">plJointDistribution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00089.html#a07b91d94adf4d51741f784b160425de8">learn_model_parameters</a> (const std::vector&lt; <a class="el" href="a00103.html">plLearnObject</a> * &gt; &amp;learn_objects, <a class="el" href="a00044.html">plDataDescriptor</a> &amp;data_descriptor)</td></tr>
<tr class="memdesc:a07b91d94adf4d51741f784b160425de8 inherit pub_static_methods_a00089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Learns the parameters of a model.  <a href="#a07b91d94adf4d51741f784b160425de8">More...</a><br/></td></tr>
<tr class="separator:a07b91d94adf4d51741f784b160425de8 inherit pub_static_methods_a00089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369f40ceb5fadfb03e61cea54f2229c2 inherit pub_static_methods_a00089"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00079.html">plJointDistribution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00089.html#a369f40ceb5fadfb03e61cea54f2229c2">learn_model_parameters</a> (const std::vector&lt; <a class="el" href="a00103.html">plLearnObject</a> * &gt; &amp;learn_objects, const <a class="el" href="a00037.html">plComputableObjectList</a> &amp;init_distribs, <a class="el" href="a00044.html">plDataDescriptor</a> &amp;data_descriptor)</td></tr>
<tr class="memdesc:a369f40ceb5fadfb03e61cea54f2229c2 inherit pub_static_methods_a00089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Learns the parameters of a model.  <a href="#a369f40ceb5fadfb03e61cea54f2229c2">More...</a><br/></td></tr>
<tr class="separator:a369f40ceb5fadfb03e61cea54f2229c2 inherit pub_static_methods_a00089"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements a generic EM (Expectation-Maximization) learning algorithm (using incomplete data sets). </p>
<p>There can be arbitrary missing data in the learning observations provided to the EM algorithm by a data descriptor.</p>
<p>An example of estimating a Gaussian mixture using the EM algorithm with a BIC (Bayesian Information Criterion) score is as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;pl.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Output a given mixture</span></div>
<div class="line"><span class="comment">//========================================================</span></div>
<div class="line"><span class="keywordtype">void</span> output_mixture(<span class="keyword">const</span> <a class="code" href="a00079.html">plJointDistribution</a> &amp;mixture)</div>
<div class="line">{</div>
<div class="line">std::cout &lt;&lt; mixture.<a class="code" href="a00079.html#a898a86a0478f8962d3f147cb7c55e487">get_computable_object_list</a>()[0] &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; mixture.<a class="code" href="a00079.html#a898a86a0478f8962d3f147cb7c55e487">get_computable_object_list</a>()[1] &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Simulate and generate a 2-components (kernels) Gaussian mixture data. This data will be used for learning using EM based on a BIC score </span></div>
<div class="line"><span class="comment">//========================================================</span></div>
<div class="line"><span class="keywordtype">void</span> generate_data(<span class="keyword">const</span> std::string &amp;file, </div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ndata)</div>
<div class="line">{</div>
<div class="line">std::ofstream data(file.c_str());</div>
<div class="line"><span class="keywordflow">if</span>(!data) {</div>
<div class="line">std::cerr &lt;&lt; <span class="stringliteral">&quot;failed to open &#39;&quot;</span> &lt;&lt; file &lt;&lt; <span class="stringliteral">&quot;&#39; for output&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">exit(-1);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Class latent variable (actual number of classes = 2)</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nc = 2;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="a00140.html">plSymbol</a> C(<span class="stringliteral">&quot;C&quot;</span>, <a class="code" href="a00078.html">plIntegerType</a>(0, nc-1));</div>
<div class="line"></div>
<div class="line"><span class="comment">// X observed variable</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="a00140.html">plSymbol</a> X(<span class="stringliteral">&quot;X&quot;</span>, <a class="code" href="a00131.html">plRealType</a>(-100.0, 100.0));</div>
<div class="line"></div>
<div class="line"><span class="comment">// Actual (PC) table</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> pr[] = {0.3, 0.7};</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="a00129.html">plProbTable</a> PC(C, pr);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Actual P(X | C) distributions</span></div>
<div class="line"><a class="code" href="a00050.html">plDistributionTable</a> PX(X, C);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> mean[] = {-10.0, 10.0};</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> sd[] = {1.0, 3.0};</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; nc; ++i) {</div>
<div class="line">PX.push( <a class="code" href="a00122.html">plNormal</a>(X, mean[i], sd[i]), <span class="keywordtype">int</span>(i));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Constructing the model</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="a00079.html">plJointDistribution</a> mixture(C^X, PC*PX);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Simulating data by drawing from P(X)</span></div>
<div class="line">data &lt;&lt; <span class="stringliteral">&quot;C;X&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a class="code" href="a00147.html">plValues</a> val_CX(C^X);</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; ndata; ++i) {</div>
<div class="line">mixture.<a class="code" href="a00049.html#a0bc52e5b6370e1c6bf77cc1505e00355">draw</a>(val_CX);</div>
<div class="line">data &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; val_CX[X] &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">data.close();</div>
<div class="line"></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Simulation mixture:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">output_mixture(mixture);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;==================================&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run an EM for a given number nc of mixture components (kernels)</span></div>
<div class="line"><span class="comment">//========================================================</span></div>
<div class="line"><span class="keywordtype">void</span> run_em(<span class="keyword">const</span> std::string &amp;file, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nc,</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nparams, <a class="code" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> &amp;llk,</div>
<div class="line"><a class="code" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> &amp;bic, <a class="code" href="a00079.html">plJointDistribution</a> &amp;model)</div>
<div class="line">{</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="a00140.html">plSymbol</a> C(<span class="stringliteral">&quot;C&quot;</span>, <a class="code" href="a00078.html">plIntegerType</a>(0, nc-1));</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="a00140.html">plSymbol</a> X(<span class="stringliteral">&quot;X&quot;</span>, <a class="code" href="a00131.html">plRealType</a>(-100.0, 100.0));</div>
<div class="line"></div>
<div class="line"><span class="comment">// EM Initial distribution on the class (kernel) variable: P(C)</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">bool</span> random_prob = <span class="keyword">true</span>;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="a00129.html">plProbTable</a> pc_init(C, random_prob);</div>
<div class="line"></div>
<div class="line"><span class="comment">// EM Initial Gaussians : P(X | C)</span></div>
<div class="line"><a class="code" href="a00050.html">plDistributionTable</a> px_init(X, C);</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; nc; ++i) {</div>
<div class="line">px_init.push( <a class="code" href="a00122.html">plNormal</a>(X, -10 + <a class="code" href="a00273.html#a11a922c4715fe62f5db75cdc5906cab0">plRandomFloat</a>(20.), 1.0), </div>
<div class="line"><span class="keywordtype">int</span>(i));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// P(C) is learnt as an histogram</span></div>
<div class="line"><a class="code" href="a00094.html">plLearnHistogram</a> LC(C);</div>
<div class="line"><span class="comment">// P(X | C) is learnt as a set of gaussians (a gaussian for each value of C)</span></div>
<div class="line"><a class="code" href="a00028.html">plCndLearnObject &lt;plLearn1dNormal&gt;</a> LX(X, C);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Creating the EM learner instance</span></div>
<div class="line"><a class="code" href="a00042.html">plCSVFileDataDescriptor&lt;double&gt;</a> myCSVdata(file, C^X);</div>
<div class="line">std::vector &lt;plLearnObject*&gt; learn_objs(2); learn_objs[0] = &amp;LC; learn_objs[1] = &amp;LX;</div>
<div class="line"><a class="code" href="a00061.html">plEMLearner</a> myEM(pc_init*px_init, learn_objs);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run untill convergence</span></div>
<div class="line">myEM.run(myCSVdata, 0.0001);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Fill the output parameters</span></div>
<div class="line">nparams = myEM.get_n_parameters();</div>
<div class="line">llk = myEM.get_last_computed_loglikelihood();</div>
<div class="line">bic = llk - 0.5*nparams*std::log(myCSVdata.get_n_records());</div>
<div class="line">model = myEM.get_joint_distribution();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run an EM for each candidate number of components (kernels) </span></div>
<div class="line"><span class="comment">//========================================================</span></div>
<div class="line"><span class="keywordtype">void</span> run_em(<span class="keyword">const</span> std::string &amp;file, </div>
<div class="line"><span class="keyword">const</span> std::vector&lt;unsigned int&gt; &amp;n_mixture_candidates,</div>
<div class="line">std::vector&lt;unsigned int&gt; &amp;nparams,</div>
<div class="line">std::vector&lt;plFloat&gt; &amp;llk,</div>
<div class="line">std::vector&lt;plFloat&gt; &amp;bic,</div>
<div class="line">std::vector&lt;plJointDistribution&gt; &amp;model)</div>
<div class="line">{  </div>
<div class="line">nparams.resize( n_mixture_candidates.size() );</div>
<div class="line">llk.resize( n_mixture_candidates.size() );</div>
<div class="line">bic.resize( n_mixture_candidates.size() );</div>
<div class="line">model.resize( n_mixture_candidates.size() );</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_mixture_candidates.size(); ++i) {</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nc = n_mixture_candidates[i];</div>
<div class="line">run_em(file, nc,</div>
<div class="line">nparams[i], llk[i], bic[i], model[i]);</div>
<div class="line">}</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//========================================================</span></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line"><span class="comment">//  DATA SIMULATION/GENERATION</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="keyword">const</span> std::string file = <span class="stringliteral">&quot;gaussian_mixture_data.csv&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ndata = 5000;</div>
<div class="line">generate_data(file, ndata);</div>
<div class="line"></div>
<div class="line"><span class="comment">//  EM-BIC BASED LEARNING</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">// Number of components (kernels) candidates</span></div>
<div class="line">std::vector&lt;unsigned int&gt; n_mixture_candidates;</div>
<div class="line">n_mixture_candidates.push_back(1); </div>
<div class="line">n_mixture_candidates.push_back(2); </div>
<div class="line">n_mixture_candidates.push_back(3);</div>
<div class="line">n_mixture_candidates.push_back(4);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Output parameters for each number of components (kernels) candidate</span></div>
<div class="line">std::vector&lt;unsigned int&gt; nparams; <span class="comment">// The number of parameters</span></div>
<div class="line">std::vector&lt;plFloat&gt; llk; <span class="comment">// The log-likelihood</span></div>
<div class="line">std::vector&lt;plFloat&gt; bic; <span class="comment">// The bic score</span></div>
<div class="line">std::vector&lt;plJointDistribution&gt; model; <span class="comment">// the learnt model</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Run an EM for each number of components (kernels) candidate</span></div>
<div class="line">run_em(file, n_mixture_candidates, </div>
<div class="line">nparams, llk, bic, model);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//  OUTPUT THE LEARNING RESULTS</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">// Output the estimate results of each number of components (kernels) candidate</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_mixture_candidates.size(); ++i) {</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;NC:\t&quot;</span>                     &lt;&lt; n_mixture_candidates[i] &lt;&lt; std::endl</div>
<div class="line">&lt;&lt; <span class="stringliteral">&quot;--BIC:\t&quot;</span>                  &lt;&lt; bic[i]                  &lt;&lt; std::endl</div>
<div class="line">&lt;&lt; <span class="stringliteral">&quot;--Log_likelihood:\t&quot;</span>       &lt;&lt; llk[i]                  &lt;&lt; std::endl</div>
<div class="line">&lt;&lt; <span class="stringliteral">&quot;--Number of parameters:\t&quot;</span> &lt;&lt; nparams[i]              &lt;&lt; std::endl;</div>
<div class="line">output_mixture(model[i]);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;==================================&quot;</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Get the model with the best BIC score</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> best_candidate_index = std::max_element(bic.begin(), bic.end()) - bic.begin();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Output the best BIC-based estimate</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;\n\nBest NC:\t&quot;</span>            &lt;&lt; n_mixture_candidates[best_candidate_index] &lt;&lt; std::endl</div>
<div class="line">&lt;&lt; <span class="stringliteral">&quot;--Best BIC:\t&quot;</span>             &lt;&lt; bic[best_candidate_index]                  &lt;&lt; std::endl</div>
<div class="line">&lt;&lt; <span class="stringliteral">&quot;--Log_llk:\t&quot;</span>              &lt;&lt; llk[best_candidate_index]                  &lt;&lt; std::endl</div>
<div class="line">&lt;&lt; <span class="stringliteral">&quot;--Number of parameters:\t&quot;</span> &lt;&lt; nparams[best_candidate_index]              &lt;&lt; std::endl</div>
<div class="line">&lt;&lt; std::endl;</div>
<div class="line">output_mixture(model[best_candidate_index]);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>for which the output will be: </p>
<pre class="fragment">Simultation mixture:
P(C) = 
C   Probability
0   0.3
1   0.7

P(X|C) = plDistributionTable {
C = 0: 
plNormal(X, -10,  1)

C = 1: 
plNormal(X, 10, 3)


}
==================================
NC: 1
--BIC:  -18359.7
--Log_likelihood: -18351.2
--Number of parameters: 2
P(C) = 
C   Probability
0   1

P(X|C) = plCndDistribution {
C = 0: 
plNormal(X, 4.12168,  9.50011)


}
==================================

NC: 2
--BIC:  -13973.8
--Log_likelihood: -13952.5
--Number of parameters: 5
P(C) = 
C   Probability
0   0.705
1   0.295

P(X|C) = plCndDistribution {
C = 0: 
plNormal(X, 10.0453,  2.93926)

C = 1: 
plNormal(X, -10.0347, 1.01676)


}
==================================

NC: 3
--BIC:  -13987.1
--Log_likelihood: -13953
--Number of parameters: 8
P(C) = 
C   Probability
0   0.295
1   0.70297
2   0.00203016

P(X|C) = plCndDistribution {
C = 0: 
plNormal(X, -10.0347, 1.01676)

C = 1: 
plNormal(X, 10.0678,  2.91296)

C = 2: 
plNormal(X, 2.23893,  0.90511)


}
==================================

NC: 4
--BIC:  -14000.3
--Log_likelihood: -13953.5
--Number of parameters: 11
P(C) = 
C   Probability
0   0.295
1   0.154698
2   0.486083
3   0.0642189

P(X|C) = plCndDistribution {
C = 0: 
plNormal(X, -10.0347, 1.01676)

C = 1: 
plNormal(X, 8.06023,  1.73133)

C = 2: 
plNormal(X, 11.2608,  2.40052)

C = 3: 
plNormal(X, 5.62642,  1.94988)


}
==================================



Best NC:  2
--Best BIC: -13973.8
--Log_llk:  -13952.5
--Number of parameters: 5

P(C) = 
C   Probability
0   0.705
1   0.295

P(X|C) = plCndDistribution {
C = 0: 
plNormal(X, 10.0453,  2.93926)

C = 1: 
plNormal(X, -10.0347, 1.01676)


}
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00044.html" title="This abstract template class defines a sequential data container. ">plDataDescriptor</a> </dd>
<dd>
<a class="el" href="a00089.html#a07b91d94adf4d51741f784b160425de8" title="Learns the parameters of a model. ">plLearner::learn_model_parameters()</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae368406ac1cfa24034fb564c022d517a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">plEMLearner::plEMLearner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00037.html">plComputableObjectList</a> &amp;&#160;</td>
          <td class="paramname"><em>init_distribs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a00103.html">plLearnObject</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>learn_objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">init_distribs</td><td>initial distributions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">learn_objects</td><td>a vector of learning objects allowing to provide the structure (dependencies), the parametrical form of each distribution, and the corresponding prior. The constructor clones the passed <em>learn_objects</em> and stores them internally (i.e. with no side-effect on the passed <em>learn_objects</em>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f174d140130eedd998d440bc1324738"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">plEMLearner::plEMLearner </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a00103.html">plLearnObject</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>learn_objects</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Initial distributions are determined from the initial state of the <em>learn_objects</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">learn_objects</td><td>a vector of learning objects allowing to provide the structure (dependencies), the parametrical form of each distribution, and the corresponding prior. The constructor clones the passed <em>learn_objects</em> and stores them internally (i.e. with no side-effect on the passed <em>learn_objects</em>).</td></tr>
  </table>
  </dd>
</dl>
<p>ATTENTION: If the initial state of the <em>learn_objects</em> is uniform (it's the case for default constructed <a class="el" href="a00103.html" title="This is the base class of all incremental (adaptive) learning objects. ">plLearnObject</a>), the EM algorithm can fail to converge because it will stay at the initial non-informative state. So, consider using the constructor: </p>
<div class="fragment"><div class="line"><a class="code" href="a00061.html#aa64413bb30745df78605999a144eada5">plEMLearner</a>(<span class="keyword">const</span> <a class="code" href="a00037.html">plComputableObjectList</a> &amp;init_distribs, </div>
<div class="line"><span class="keyword">const</span> std::vector &lt;plLearnObject*&gt; &amp;learn_objects);</div>
</div><!-- fragment --><p> even with random initialized <em>init_distribs</em>. </p>

</div>
</div>
<a class="anchor" id="a82f2655fa64ba92d5969bd70b467dd69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">plEMLearner::plEMLearner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>data_descriptor_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a00103.html">plLearnObject</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>learn_objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated constructor, kept temporarily for compatibility purposes. </p>
<p>Identical in function to the above <a class="el" href="a00061.html" title="This class implements a generic EM (Expectation-Maximization) learning algorithm (using incomplete da...">plEMLearner</a>(const std::vector &lt;plLearnObject*&gt; &amp;learn_objects).</p>
<p>Initial distributions are determined from the initial state of the <em>learn_objects</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_descriptor_vars</td><td>the data descriptor variables. It represents the order in which the data is arranged in a given row of the data descriptor used for learning. It should be a subset of all the variables found in the <em>learn_objects</em> learning objects.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">learn_objects</td><td>a vector of learning objects allowing to provide the structure (dependencies), the parametrical form of each distribution, and the corresponding prior. The constructor clones the passed <em>learn_objects</em> and stores them internally (i.e. with no side-effect on the passed <em>learn_objects</em>).</td></tr>
  </table>
  </dd>
</dl>
<p>ATTENTION: If the initial state of the <em>learn_objects</em> is uniform (it's the case for default constructed <a class="el" href="a00103.html" title="This is the base class of all incremental (adaptive) learning objects. ">plLearnObject</a>), the EM algorithm can fail to converge because it will stay at the initial non-informative state. So, consider using the constructor: </p>
<div class="fragment"><div class="line"><a class="code" href="a00061.html#aa64413bb30745df78605999a144eada5">plEMLearner</a>(<span class="keyword">const</span> <a class="code" href="a00037.html">plComputableObjectList</a> &amp;init_distribs, </div>
<div class="line"><span class="keyword">const</span> std::vector &lt;plLearnObject*&gt; &amp;learn_objects);</div>
</div><!-- fragment --><p> even with random initialized <em>init_distribs</em>. </p>

</div>
</div>
<a class="anchor" id="af4a355302e91059aeb83a620562c7cec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">plEMLearner::plEMLearner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>data_descriptor_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00037.html">plComputableObjectList</a> &amp;&#160;</td>
          <td class="paramname"><em>init_distribs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a00103.html">plLearnObject</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>learn_objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated constructor, kept temporarily for compatibility purposes. </p>
<p>Identical in function to the above <a class="el" href="a00061.html" title="This class implements a generic EM (Expectation-Maximization) learning algorithm (using incomplete da...">plEMLearner</a>(const <a class="el" href="a00037.html" title="A plComputableObjectList is an STL-like list of plComputableObjects. ">plComputableObjectList</a> &amp;init_distribs, const std::vector &lt;plLearnObject*&gt; &amp;learn_objects).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_descriptor_vars</td><td>the data descriptor variables. It represents the order in which the data is arranged in a given row of the data descriptor used for learning. It should be a subset of all the variables found in the <em>learn_objects</em> learning objects.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init_distribs</td><td>initial distributions.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">learn_objects</td><td>a vector of learning objects allowing to provide the structure (dependencies), the parametrical form of each distribution, and the corresponding prior. The constructor clones the passed <em>learn_objects</em> and stores them internally (i.e. with no side-effect on the passed <em>learn_objects</em>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa64413bb30745df78605999a144eada5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">plEMLearner::plEMLearner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>The resulting object is invalid for most operations, except for being assigned to. </p>

</div>
</div>
<a class="anchor" id="ad1fd9657afbef40ac3b574eadf2930b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual plEMLearner::~plEMLearner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7d4ad968d02e0c811b9073a3b97913c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plEMLearner::compute_missing_values_infos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html">plDataDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>data_descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a00147.html">plValues</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>missing_most_probable_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>missing_probability_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute for each data row: (i) the values with the highest probability for the missing variables argmax P(Missing) </p>
<p>(ii) the current probability table on the missing variables P(Missing). </p>

</div>
</div>
<a class="anchor" id="a69e5a86f1b4ed260780af20fb0e1f17d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plEMLearner::distribution_set_frozen </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>freeze</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Freezes the nth distribution to its current state. </p>

</div>
</div>
<a class="anchor" id="a47ab6bcbb0081c66131f5b6566d692c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00036.html">plComputableObject</a>&amp; plEMLearner::get_distribution </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current estimation of the <em>nth</em> distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the position of the distribution to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current estimation of the <em>nth</em> distribution. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d512889251d5afa38ef2a3aeb5a8baa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00079.html">plJointDistribution</a>&amp; plEMLearner::get_joint_distribution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the joint distribution (model) with the current learnt parameters. </p>
<dl class="section return"><dt>Returns</dt><dd>the joint distribution with the current learnt parameters. </dd></dl>

</div>
</div>
<a class="anchor" id="a1664cffe982cc8c9852fd34049fca438"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> plEMLearner::get_last_computed_loglikelihood </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last cached loglikelihood value. </p>
<p>Throws an exception if this value is not available or made obsolete. </p>

</div>
</div>
<a class="anchor" id="a416979cf591d20a5c422d78ff338ddde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00103.html">plLearnObject</a>* plEMLearner::get_learn_object </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the <em>nth</em> internal learn object in the same order as passed to the constuctor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the position of the distribution to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the <em>nth</em> internal learn object in the same order as passed to the constuctor. </dd></dl>

</div>
</div>
<a class="anchor" id="a1218189f1eb3cac3c25032c359cfb851"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plEMLearner::iteration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html">plDataDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>data_descriptor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the EM algorithm for one iteration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_descriptor</td><td>the data set on which the EM algorithm will iterate. It can contain arbitrary missing data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ad8d2d22a608ba82e1ebf3325ebcb9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plEMLearner::iteration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html">plDataDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>data_descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a00147.html">plValues</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>missing_most_probable_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>missing_probability_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the EM algorithm for oneiterations and return this last iteration info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_descriptor</td><td>the data set on which the EM algorithm will iterate. It can contain arbitrary missing data.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">missing_most_probable_value</td><td>the values with the highest probability for the missing variables argmax P(Missing). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">missing_probability_table</td><td>the current probability table on the missing variables P(Missing). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a525e0d7b1468ceb911418575aa268fad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void plEMLearner::Output </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the object at the <em>out</em> stream. </p>

<p>Implements <a class="el" href="a00123.html#af418d39625a6f1175e573f059bcdf3f9">plObject</a>.</p>

</div>
</div>
<a class="anchor" id="aa8a5b5a6a8b16891c92ef28ddbb8920e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plEMLearner::output_distributions </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs the current learnt distributions on the output stream 'out'. </p>

</div>
</div>
<a class="anchor" id="ac63364534b4ab6b0af9647873833f820"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plEMLearner::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html">plDataDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>data_descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the EM algorithm for a given number of iterations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_descriptor</td><td>the data set on which the EM algorithm will iterate. It can contain arbitrary missing data.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nit</td><td>the number of iterations for which the EM algorithm will be run. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8979643fb182b7a1a0502bc0bf440046"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plEMLearner::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html">plDataDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>data_descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run the EM algorithm for a given number of iterations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_descriptor</td><td>the data set on which the EM algorithm will iterate. It can contain arbitrary missing data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nit</td><td>the number of iterations for which the EM algorithm will be run. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9cc21aa0b4ae4602f0281292dbcfbc89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int plEMLearner::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html">plDataDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>data_descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>convergence_loglikelihood_threshold</em> = <code>0.0001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_it</em> = <code>std::numeric_limits&lt;&#160;unsigned&#160;int&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the EM algorithm until convergence:<br/>
 | log-likelihood(t) - log-likelihood(t-1) | / | (log-likelihood(t) + log-likelihood(t-1)/2.0 | &lt; convergence_loglikelihood_threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_descriptor</td><td>the data set on which the EM algorithm will iterate. It can contain arbitrary missing data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">convergence_loglikelihood_threshold</td><td>convergence threshold corresponding to data log-likelihood change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_it</td><td>the maximal number of iterations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of iterations needed to reach the convergence </dd></dl>

</div>
</div>
<a class="anchor" id="a6ac6a50be1f56ac7874836277363fe73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plEMLearner::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html">plDataDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>data_descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a00147.html">plValues</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>missing_most_probable_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>missing_probability_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the EM algorithm for a given number of iterations and return the last iteration info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_descriptor</td><td>the data set on which the EM algorithm will iterate. It can contain arbitrary missing data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nit</td><td>the number of iterations for which the EM algorithm will be run. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">missing_most_probable_value</td><td>the values with the highest probability for the missing variables. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">missing_probability_table</td><td>the current probability table on the missing variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af35587d45c73272bf8101d002bd3d64e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plEMLearner::set_approximate_compilation_nsamples </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method allows to set the compilation mode to 'approximate' using a number of samples of 'n' when constructing the distribution P(Missing | Observed) in the E step. </p>
<p>It sets the compilation mode to 'exact' if 'n' is null.</p>
<p>Calling this function (or <a class="el" href="a00061.html#a9e1278ff4a46d98969b9c16663371836" title="This method allows to set the compilation mode to &#39;approximate&#39; using a maximal time of &#39;compilation_...">set_approximate_compilation_time()</a>) is mondatory if at least one of the missing variables is continuous.</p>
<p>Calling this function changes the stop criterion for constructing the distribution P(Missing | Observed) to 'number of samples'.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00061.html#a9e1278ff4a46d98969b9c16663371836" title="This method allows to set the compilation mode to &#39;approximate&#39; using a maximal time of &#39;compilation_...">set_approximate_compilation_time</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9e1278ff4a46d98969b9c16663371836"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plEMLearner::set_approximate_compilation_time </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>compilation_time_in_seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method allows to set the compilation mode to 'approximate' using a maximal time of 'compilation_time_in_seconds' (in seconds) when constructing the distribution P(Missing | Observed) in the E step. </p>
<p>It sets the compilation mode to 'exact' if 'compilation_time_in_seconds' is null.</p>
<p>Calling this function (or <a class="el" href="a00061.html#af35587d45c73272bf8101d002bd3d64e" title="This method allows to set the compilation mode to &#39;approximate&#39; using a number of samples of &#39;n&#39; when...">set_approximate_compilation_nsamples()</a>) is mondatory if at least one of the missing variables is continuous.</p>
<p>Calling this function changes the stop criterion for constructing the distribution P(Missing | Observed) to 'time'.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00061.html#af35587d45c73272bf8101d002bd3d64e" title="This method allows to set the compilation mode to &#39;approximate&#39; using a number of samples of &#39;n&#39; when...">set_approximate_compilation_nsamples</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a70e2c44fb839fa4740cc0e36710ef0b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plEMLearner::set_distribution </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00036.html">plComputableObject</a> &amp;&#160;</td>
          <td class="paramname"><em>new_distrib</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <em>nth</em> distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the position of the distribution to be changed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_distrib</td><td>the new distribution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0ebe11ad20fc1d68eba102a7771145f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plEMLearner::set_distributions_display </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>display</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets distributions displaying, after each iteration, to ON or OFF. </p>

</div>
</div>
<a class="anchor" id="acb674eba8cf499122f31882a59e38c94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plEMLearner::set_distributions_display_stream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets distributions displaying stream to 'out'. </p>

</div>
</div>
<a class="anchor" id="a45bb9bfd9bd98a018f6dffd80e9844f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plEMLearner::set_mc_integration_npoints </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>npoints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method allows to set the marginalization mode to 'monte carlo' using 'npoints' sample points. </p>
<p>It sets the integration mode to 'exact' if 'npoints' is null.</p>
<p>This is only used for computing the likelihood of the data (given the model) P(Observed) because this computation requires the marginalization over the missing variables. Calling this function is mondatory if at least one of the missing variables is continuous. </p>

</div>
</div>
<a class="anchor" id="ad6f9c022dd7233e81e531d1e89874266"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plEMLearner::set_same_missing_variables </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>same</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If 'same' = true, the learning data will contain missing values for the same variables in all data rows (unobserved variables). </p>
<p>If 'same' = false, missing values may concern different variables.</p>
<p>This method is used just to speed up the algorithm. </p>

</div>
</div>
<a class="anchor" id="a2da434cc62a73430ea2a4839fdc6b94a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plEMLearner::set_use_sampling_for_compilation </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_it</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method allows to set the methode to be used for constructing the distribution P(Missing | Observed) in the E step when using approximate mode (using set_approximate_compilation_time or set_approximate_compilation_nsamples). </p>
<p>If set to <em>true</em>, P(Missing | Observed) will be sampled and the corresponding points will be directly used in the M_step instead to constructing explicitly the corresponding probability table.</p>
<p>The default value of this parameter is <em>false</em>. Do not change this parameter unless you understand exactly its effect. </p>

</div>
</div>
<a class="anchor" id="a2261d462365ea936f9e2f65d9a6ece3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plEMLearner::use_junction_tree </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_jt</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets or unsets the use of a junction tree for inference. </p>
<p>By default, inference is done using the ordinary successive restrictions algorithm as accessed by <a class="el" href="a00079.html" title="The plJointDistribution class is used to describe a probabilistic model by providing a decomposition ...">plJointDistribution</a>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jan 31 2015 01:13:27 for ProBT by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
