<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>ProBT: plBayesianNetwork Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ProBT
   &#160;<span id="projectnumber">2.3.99</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="a00362.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">plBayesianNetwork Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Simple helper for building a Bayesian network and using it for exact inference using discrete variables (continuous variables are allowed only when used as evidence ones).  
 <a href="a00006.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for plBayesianNetwork:</div>
<div class="dyncontent">
<div class="center"><img src="a00363.png" border="0" usemap="#pl_bayesian_network_inherit__map" alt="Inheritance graph"/></div>
<map name="pl_bayesian_network_inherit__map" id="pl_bayesian_network_inherit__map">
<area shape="rect" id="node2" href="a00123.html" title="Used as the base class of all ProBT API objects. " alt="" coords="37,5,107,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for plBayesianNetwork:</div>
<div class="dyncontent">
<div class="center"><img src="a00364.png" border="0" usemap="#pl_bayesian_network_coll__map" alt="Collaboration graph"/></div>
<map name="pl_bayesian_network_coll__map" id="pl_bayesian_network_coll__map">
<area shape="rect" id="node2" href="a00123.html" title="Used as the base class of all ProBT API objects. " alt="" coords="6,72,77,99"/><area shape="rect" id="node5" href="a00036.html" title="A computable object on &#160;is defined as an abstract object provided with a probability measure function..." alt="" coords="134,43,274,69"/><area shape="rect" id="node8" href="a00089.html" title="This is the base class of all learning objects. " alt="" coords="304,93,379,120"/><area shape="rect" id="node10" href="a00132.html" title="A State Space Object. " alt="" coords="129,183,279,209"/><area shape="rect" id="node3" href="a00079.html" title="The plJointDistribution class is used to describe a probabilistic model by providing a decomposition ..." alt="" coords="806,56,933,83"/><area shape="rect" id="node4" href="a00049.html" title="The plDistribution class is the base class of all non&#45;conditional probability (and density) distribut..." alt="" coords="431,43,529,69"/><area shape="rect" id="node6" href="a00088.html" title="This class allows to learn a set of conditional and non&#45;conditional distributions in the same time..." alt="" coords="958,168,1098,195"/><area shape="rect" id="node7" href="a00103.html" title="This is the base class of all incremental (adaptive) learning objects. " alt="" coords="678,101,781,128"/><area shape="rect" id="node9" href="a00150.html" title="The plVariablesConjunction class implements the conjunction of a set of variables. " alt="" coords="403,183,557,209"/><area shape="rect" id="node12" href="a00147.html" title="A plValues is an object storing the values of a set of variables. " alt="" coords="581,293,653,320"/><area shape="rect" id="node11" href="a00081.html" title="Implements exact inference using a junction tree. " alt="" coords="975,275,1081,301"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5c826ed379482d64a4fc0bbb44969c64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c826ed379482d64a4fc0bbb44969c64"></a>
typedef std::vector&lt; std::pair<br class="typebreak"/>
&lt; <a class="el" href="a00140.html">plSymbol</a>, <a class="el" href="a00140.html">plSymbol</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a5c826ed379482d64a4fc0bbb44969c64">bn_edge_list_t</a></td></tr>
<tr class="memdesc:a5c826ed379482d64a4fc0bbb44969c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">An edge list as a vector of node pairs (source, destination) <br/></td></tr>
<tr class="separator:a5c826ed379482d64a4fc0bbb44969c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a879e518761ff567a5e6df7c26bc61eea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a879e518761ff567a5e6df7c26bc61eea">plBayesianNetwork</a> (const std::string &amp;<a class="el" href="a00006.html#a868f151acf96420d882a7267b5023ade">name</a>=&quot;untitled_BN&quot;)</td></tr>
<tr class="memdesc:a879e518761ff567a5e6df7c26bc61eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an empty Bayesian network.  <a href="#a879e518761ff567a5e6df7c26bc61eea">More...</a><br/></td></tr>
<tr class="separator:a879e518761ff567a5e6df7c26bc61eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6482adad2bed1f763d45fac104e3a3a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6482adad2bed1f763d45fac104e3a3a8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a6482adad2bed1f763d45fac104e3a3a8">plBayesianNetwork</a> (const <a class="el" href="a00079.html">plJointDistribution</a> &amp;joint, const std::string &amp;<a class="el" href="a00006.html#a868f151acf96420d882a7267b5023ade">name</a>=&quot;untitled_BN&quot;)</td></tr>
<tr class="memdesc:a6482adad2bed1f763d45fac104e3a3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a Bayesian network from a <a class="el" href="a00079.html" title="The plJointDistribution class is used to describe a probabilistic model by providing a decomposition ...">plJointDistribution</a> object. <br/></td></tr>
<tr class="separator:a6482adad2bed1f763d45fac104e3a3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7facf13bc5fe2cf890b4bbc923f479"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f7facf13bc5fe2cf890b4bbc923f479"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a1f7facf13bc5fe2cf890b4bbc923f479">plBayesianNetwork</a> (const <a class="el" href="a00006.html">plBayesianNetwork</a> &amp;other)</td></tr>
<tr class="memdesc:a1f7facf13bc5fe2cf890b4bbc923f479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr class="separator:a1f7facf13bc5fe2cf890b4bbc923f479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac33c56f64af9937ce669fc1d033c7df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac33c56f64af9937ce669fc1d033c7df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#aac33c56f64af9937ce669fc1d033c7df">~plBayesianNetwork</a> ()</td></tr>
<tr class="memdesc:aac33c56f64af9937ce669fc1d033c7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:aac33c56f64af9937ce669fc1d033c7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c84a224651faf3ea53506638f3fa6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05c84a224651faf3ea53506638f3fa6a"></a>
<a class="el" href="a00006.html">plBayesianNetwork</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a05c84a224651faf3ea53506638f3fa6a">operator=</a> (const <a class="el" href="a00006.html">plBayesianNetwork</a> &amp;other)</td></tr>
<tr class="memdesc:a05c84a224651faf3ea53506638f3fa6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br/></td></tr>
<tr class="separator:a05c84a224651faf3ea53506638f3fa6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef2c7d97b0aeab882a366001daca244"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ef2c7d97b0aeab882a366001daca244"></a>
<a class="el" href="a00006.html">plBayesianNetwork</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a9ef2c7d97b0aeab882a366001daca244">assign_from</a> (const <a class="el" href="a00006.html">plBayesianNetwork</a> &amp;other)</td></tr>
<tr class="memdesc:a9ef2c7d97b0aeab882a366001daca244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="a00006.html#a05c84a224651faf3ea53506638f3fa6a" title="Assignment operator. ">operator=()</a> <br/></td></tr>
<tr class="separator:a9ef2c7d97b0aeab882a366001daca244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d5204db586df56de765b701effba43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28d5204db586df56de765b701effba43"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a28d5204db586df56de765b701effba43">add_node</a> (const std::string &amp;<a class="el" href="a00006.html#a868f151acf96420d882a7267b5023ade">name</a>, const <a class="el" href="a00142.html">plType</a> &amp;type)</td></tr>
<tr class="memdesc:a28d5204db586df56de765b701effba43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node with name <em>name</em> and of type <em>type</em>. <br/></td></tr>
<tr class="separator:a28d5204db586df56de765b701effba43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb5c8f203f34bea7408be3731a13983"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a9eb5c8f203f34bea7408be3731a13983">add_node</a> (const <a class="el" href="a00140.html">plSymbol</a> &amp;node)</td></tr>
<tr class="memdesc:a9eb5c8f203f34bea7408be3731a13983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a node in the network.  <a href="#a9eb5c8f203f34bea7408be3731a13983">More...</a><br/></td></tr>
<tr class="separator:a9eb5c8f203f34bea7408be3731a13983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70079e571f638d0dbe2f751c0b7287c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70079e571f638d0dbe2f751c0b7287c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a70079e571f638d0dbe2f751c0b7287c0">remove_node</a> (const <a class="el" href="a00140.html">plSymbol</a> &amp;node)</td></tr>
<tr class="memdesc:a70079e571f638d0dbe2f751c0b7287c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the node <em>node</em> if exists. <br/></td></tr>
<tr class="separator:a70079e571f638d0dbe2f751c0b7287c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fd285b02b1917319ebca776d30122d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32fd285b02b1917319ebca776d30122d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a32fd285b02b1917319ebca776d30122d">remove_node</a> (const std::string &amp;<a class="el" href="a00006.html#a868f151acf96420d882a7267b5023ade">name</a>)</td></tr>
<tr class="memdesc:a32fd285b02b1917319ebca776d30122d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the node with the name <em>name</em> if exists. <br/></td></tr>
<tr class="separator:a32fd285b02b1917319ebca776d30122d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5a0b88158c358886e9e957473e3732"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a5a0b88158c358886e9e957473e3732"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a9a5a0b88158c358886e9e957473e3732">set_nodes</a> (const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;<a class="el" href="a00006.html#a13834e9a2098ae1c7f2205c7280402d0">nodes</a>)</td></tr>
<tr class="memdesc:a9a5a0b88158c358886e9e957473e3732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the network and set its nodes. <br/></td></tr>
<tr class="separator:a9a5a0b88158c358886e9e957473e3732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4921f921d01dac7257dcb040400bc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f4921f921d01dac7257dcb040400bc3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a1f4921f921d01dac7257dcb040400bc3">set_nodes</a> (const std::vector&lt; <a class="el" href="a00140.html">plSymbol</a> &gt; &amp;<a class="el" href="a00006.html#a13834e9a2098ae1c7f2205c7280402d0">nodes</a>)</td></tr>
<tr class="memdesc:a1f4921f921d01dac7257dcb040400bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the network and set its nodes. <br/></td></tr>
<tr class="separator:a1f4921f921d01dac7257dcb040400bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93b27925fb28aa4587c3ffe724a501e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad93b27925fb28aa4587c3ffe724a501e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ad93b27925fb28aa4587c3ffe724a501e">add_edge</a> (const <a class="el" href="a00140.html">plSymbol</a> &amp;source, const <a class="el" href="a00140.html">plSymbol</a> &amp;destination)</td></tr>
<tr class="memdesc:ad93b27925fb28aa4587c3ffe724a501e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an edge to the network. <br/></td></tr>
<tr class="separator:ad93b27925fb28aa4587c3ffe724a501e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1970b0b8b2b7471653c90ddbda9f5963"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1970b0b8b2b7471653c90ddbda9f5963"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a1970b0b8b2b7471653c90ddbda9f5963">add_edge</a> (const std::string &amp;source_name, const std::string &amp;destination_name)</td></tr>
<tr class="memdesc:a1970b0b8b2b7471653c90ddbda9f5963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an edge to the network. <br/></td></tr>
<tr class="separator:a1970b0b8b2b7471653c90ddbda9f5963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1c8da77d176a56bc840f962fcc3b5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e1c8da77d176a56bc840f962fcc3b5f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a4e1c8da77d176a56bc840f962fcc3b5f">remove_edge</a> (const <a class="el" href="a00140.html">plSymbol</a> &amp;source, const <a class="el" href="a00140.html">plSymbol</a> &amp;destination)</td></tr>
<tr class="memdesc:a4e1c8da77d176a56bc840f962fcc3b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an edge from the network. <br/></td></tr>
<tr class="separator:a4e1c8da77d176a56bc840f962fcc3b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb48834cc5986ba5159bc7a2198d6e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcb48834cc5986ba5159bc7a2198d6e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#afcb48834cc5986ba5159bc7a2198d6e8">remove_edge</a> (const std::string &amp;source_name, const std::string &amp;destination_name)</td></tr>
<tr class="memdesc:afcb48834cc5986ba5159bc7a2198d6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an edge from the network. <br/></td></tr>
<tr class="separator:afcb48834cc5986ba5159bc7a2198d6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25c077d94f5b2d08f953cec933241ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#aa25c077d94f5b2d08f953cec933241ef">set_distribution</a> (const <a class="el" href="a00036.html">plComputableObject</a> &amp;distribution)</td></tr>
<tr class="memdesc:aa25c077d94f5b2d08f953cec933241ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the distribution associated to a given node.  <a href="#aa25c077d94f5b2d08f953cec933241ef">More...</a><br/></td></tr>
<tr class="separator:aa25c077d94f5b2d08f953cec933241ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90eeca551c3c5628380936269ded918"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#aa90eeca551c3c5628380936269ded918">set_distribution</a> (const <a class="el" href="a00103.html">plLearnObject</a> &amp;learnable_distribution)</td></tr>
<tr class="memdesc:aa90eeca551c3c5628380936269ded918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the distribution associated to a given node to be a learnable distribution.  <a href="#aa90eeca551c3c5628380936269ded918">More...</a><br/></td></tr>
<tr class="separator:aa90eeca551c3c5628380936269ded918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13834e9a2098ae1c7f2205c7280402d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13834e9a2098ae1c7f2205c7280402d0"></a>
const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a13834e9a2098ae1c7f2205c7280402d0">nodes</a> () const </td></tr>
<tr class="memdesc:a13834e9a2098ae1c7f2205c7280402d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the BN nodes. <br/></td></tr>
<tr class="separator:a13834e9a2098ae1c7f2205c7280402d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fee8cdcf6e417045dc2cac762f0f567"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fee8cdcf6e417045dc2cac762f0f567"></a>
<a class="el" href="a00006.html#a5c826ed379482d64a4fc0bbb44969c64">bn_edge_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a0fee8cdcf6e417045dc2cac762f0f567">edges</a> () const </td></tr>
<tr class="memdesc:a0fee8cdcf6e417045dc2cac762f0f567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the BN edges as a set of pairs (source, destination) <br/></td></tr>
<tr class="separator:a0fee8cdcf6e417045dc2cac762f0f567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe65048f21b41ca7c2486bea06501d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fe65048f21b41ca7c2486bea06501d9"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a0fe65048f21b41ca7c2486bea06501d9">get_n_nodes</a> () const </td></tr>
<tr class="memdesc:a0fe65048f21b41ca7c2486bea06501d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of nodes. <br/></td></tr>
<tr class="separator:a0fe65048f21b41ca7c2486bea06501d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26687da821b349bb7ec49bb694f3e238"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26687da821b349bb7ec49bb694f3e238"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a26687da821b349bb7ec49bb694f3e238">get_nth_node_name</a> (unsigned int n) const </td></tr>
<tr class="memdesc:a26687da821b349bb7ec49bb694f3e238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth node name. <br/></td></tr>
<tr class="separator:a26687da821b349bb7ec49bb694f3e238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c37f7a9d34937505aa988a6fd0f13d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75c37f7a9d34937505aa988a6fd0f13d"></a>
<a class="el" href="a00140.html">plSymbol</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a75c37f7a9d34937505aa988a6fd0f13d">get_node</a> (unsigned int n) const </td></tr>
<tr class="memdesc:a75c37f7a9d34937505aa988a6fd0f13d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nth node. <br/></td></tr>
<tr class="separator:a75c37f7a9d34937505aa988a6fd0f13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84d927881293b9e13f5a4be467b8b37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac84d927881293b9e13f5a4be467b8b37"></a>
<a class="el" href="a00140.html">plSymbol</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ac84d927881293b9e13f5a4be467b8b37">get_node</a> (const std::string &amp;node_name) const </td></tr>
<tr class="memdesc:ac84d927881293b9e13f5a4be467b8b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node having <em>node_name</em> as name. <br/></td></tr>
<tr class="separator:ac84d927881293b9e13f5a4be467b8b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1310c1352ce70821e81d0b5da4495a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c1310c1352ce70821e81d0b5da4495a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a1c1310c1352ce70821e81d0b5da4495a">clear</a> ()</td></tr>
<tr class="memdesc:a1c1310c1352ce70821e81d0b5da4495a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all BN's nodes and the associated distributions/learnable_distributions. <br/></td></tr>
<tr class="separator:a1c1310c1352ce70821e81d0b5da4495a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e33c56ff1576b5927e6aaa12577db0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ac6e33c56ff1576b5927e6aaa12577db0">set_evidence</a> (const <a class="el" href="a00147.html">plValues</a> &amp;evidence, bool check_validity=true)</td></tr>
<tr class="memdesc:ac6e33c56ff1576b5927e6aaa12577db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the evidence in the network.  <a href="#ac6e33c56ff1576b5927e6aaa12577db0">More...</a><br/></td></tr>
<tr class="separator:ac6e33c56ff1576b5927e6aaa12577db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7cf86ce9dba3d30028e98738bb60a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a4f7cf86ce9dba3d30028e98738bb60a3">add_evidence</a> (const <a class="el" href="a00147.html">plValues</a> &amp;added_evidence, bool check_validity=true)</td></tr>
<tr class="memdesc:a4f7cf86ce9dba3d30028e98738bb60a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addes a evidence in the network.  <a href="#a4f7cf86ce9dba3d30028e98738bb60a3">More...</a><br/></td></tr>
<tr class="separator:a4f7cf86ce9dba3d30028e98738bb60a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba61fac6848d11b1d53ece173069816"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acba61fac6848d11b1d53ece173069816"></a>
const <a class="el" href="a00147.html">plValues</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#acba61fac6848d11b1d53ece173069816">get_evidence</a> () const </td></tr>
<tr class="memdesc:acba61fac6848d11b1d53ece173069816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current evidence. <br/></td></tr>
<tr class="separator:acba61fac6848d11b1d53ece173069816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7310ea07d4506ddedab953b0d7dec481"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7310ea07d4506ddedab953b0d7dec481"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a7310ea07d4506ddedab953b0d7dec481">clear_evidence</a> ()</td></tr>
<tr class="memdesc:a7310ea07d4506ddedab953b0d7dec481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears evidence previously inserted in the network. <br/></td></tr>
<tr class="separator:a7310ea07d4506ddedab953b0d7dec481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c01d2f5864e916bee74c1b552415507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a7c01d2f5864e916bee74c1b552415507">learn_parameters</a> (const std::string &amp;csv_file, int em_iterations=-1, bool csv_file_has_header=true, const std::string &amp;csv_file_undefined_field=&quot; &quot;, const std::string &amp;csv_file_field_separators=&quot;,;&quot;, const std::string &amp;csv_file_quotes=&quot;'\&quot;&quot;, bool no_em=false)</td></tr>
<tr class="memdesc:a7c01d2f5864e916bee74c1b552415507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Learns the parameters of learnable distributions in the network.  <a href="#a7c01d2f5864e916bee74c1b552415507">More...</a><br/></td></tr>
<tr class="separator:a7c01d2f5864e916bee74c1b552415507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811e8c96e61a38505d21aa8a69c9b32e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a811e8c96e61a38505d21aa8a69c9b32e">learn_parameters</a> (<a class="el" href="a00044.html">plDataDescriptor</a> &amp;data_set, int em_iterations=-1, bool no_em=false)</td></tr>
<tr class="memdesc:a811e8c96e61a38505d21aa8a69c9b32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Learns the parameters of learnable distributions in the network.  <a href="#a811e8c96e61a38505d21aa8a69c9b32e">More...</a><br/></td></tr>
<tr class="separator:a811e8c96e61a38505d21aa8a69c9b32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412205d25ecbce40b34ff720bb4c4aa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a412205d25ecbce40b34ff720bb4c4aa7">learn_parameters_em</a> (<a class="el" href="a00044.html">plDataDescriptor</a> &amp;data_set, int em_iterations=-1, bool same_missing_variables=false)</td></tr>
<tr class="memdesc:a412205d25ecbce40b34ff720bb4c4aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Learns the parameters of learnable distributions in the network.  <a href="#a412205d25ecbce40b34ff720bb4c4aa7">More...</a><br/></td></tr>
<tr class="separator:a412205d25ecbce40b34ff720bb4c4aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaafcf82e897edd5ee924133c75ab2fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#abaafcf82e897edd5ee924133c75ab2fd">learn_parameters_no_em</a> (<a class="el" href="a00044.html">plDataDescriptor</a> &amp;data_set)</td></tr>
<tr class="memdesc:abaafcf82e897edd5ee924133c75ab2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Learns the parameters of learnable distributions in the network.  <a href="#abaafcf82e897edd5ee924133c75ab2fd">More...</a><br/></td></tr>
<tr class="separator:abaafcf82e897edd5ee924133c75ab2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ae87bd11b7329e2eca1c99e59b5e8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51ae87bd11b7329e2eca1c99e59b5e8b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a51ae87bd11b7329e2eca1c99e59b5e8b">learn_parameters_add_point</a> (const <a class="el" href="a00147.html">plValues</a> &amp;data_row, <a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> weight=PL_ONE)</td></tr>
<tr class="memdesc:a51ae87bd11b7329e2eca1c99e59b5e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a learning point and adjust the parameters of the BN. <br/></td></tr>
<tr class="separator:a51ae87bd11b7329e2eca1c99e59b5e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1237816834387fa95ed0c21e2189260d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1237816834387fa95ed0c21e2189260d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a1237816834387fa95ed0c21e2189260d">learn_parameters_add_point</a> (const <a class="el" href="a00147.html">plValues</a> &amp;data_row, const std::vector&lt; bool &gt; &amp;definitions, <a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> weight=PL_ONE)</td></tr>
<tr class="memdesc:a1237816834387fa95ed0c21e2189260d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a learning point and adjust the parameters of the BN. <br/></td></tr>
<tr class="separator:a1237816834387fa95ed0c21e2189260d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb20d3e64cd21e44315b03d069e4134"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6eb20d3e64cd21e44315b03d069e4134"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a6eb20d3e64cd21e44315b03d069e4134">reset_learned_parameters</a> ()</td></tr>
<tr class="memdesc:a6eb20d3e64cd21e44315b03d069e4134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the learned distributions to their initial values. <br/></td></tr>
<tr class="separator:a6eb20d3e64cd21e44315b03d069e4134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0560bc96583b027f1a88e105d42816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a0d0560bc96583b027f1a88e105d42816">learn_structure</a> (<a class="el" href="a00044.html">plDataDescriptor</a> &amp;data, bool use_current_structure_as_starting_point=true, bool keep_current_edges=true, <a class="el" href="a00160.html#af3353c07f22f33cc74530cf82dafb90c">plStructureLearningScore</a> edge_score=<a class="el" href="a00160.html#af3353c07f22f33cc74530cf82dafb90cae1afff89ba0469aee4389fb7950fdca9">PL_MI</a>, <a class="el" href="a00160.html#af3353c07f22f33cc74530cf82dafb90c">plStructureLearningScore</a> node_score=<a class="el" href="a00160.html#af3353c07f22f33cc74530cf82dafb90ca3139c717e277ac7e3adbe2bd703ebc79">PL_AIC</a>, const <a class="el" href="a00140.html">plSymbol</a> &amp;root_node=<a class="el" href="a00140.html">plSymbol</a>(), unsigned int maxp=10, unsigned int maxpc=1000, const <a class="el" href="a00006.html#a5c826ed379482d64a4fc0bbb44969c64">bn_edge_list_t</a> &amp;edges_to_exclude=<a class="el" href="a00006.html#a5c826ed379482d64a4fc0bbb44969c64">bn_edge_list_t</a>())</td></tr>
<tr class="memdesc:a0d0560bc96583b027f1a88e105d42816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Learns the structure of the network.  <a href="#a0d0560bc96583b027f1a88e105d42816">More...</a><br/></td></tr>
<tr class="separator:a0d0560bc96583b027f1a88e105d42816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045eafe9974ad5f4a29d475b33865b11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a045eafe9974ad5f4a29d475b33865b11">learn_structure_tree_augmented_naive_bayes</a> (<a class="el" href="a00044.html">plDataDescriptor</a> &amp;data, const <a class="el" href="a00140.html">plSymbol</a> &amp;class_node, <a class="el" href="a00160.html#af3353c07f22f33cc74530cf82dafb90c">plStructureLearningScore</a> edge_score=<a class="el" href="a00160.html#af3353c07f22f33cc74530cf82dafb90ca3139c717e277ac7e3adbe2bd703ebc79">PL_AIC</a>, <a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> score_threshold=PL_ZERO, bool keep_current_edges=true, const <a class="el" href="a00006.html#a5c826ed379482d64a4fc0bbb44969c64">bn_edge_list_t</a> &amp;edges_to_exclude=<a class="el" href="a00006.html#a5c826ed379482d64a4fc0bbb44969c64">bn_edge_list_t</a>())</td></tr>
<tr class="memdesc:a045eafe9974ad5f4a29d475b33865b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Learns the structure of the network as a tree augmented naive bayes (TANB)  <a href="#a045eafe9974ad5f4a29d475b33865b11">More...</a><br/></td></tr>
<tr class="separator:a045eafe9974ad5f4a29d475b33865b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da182420191068f7887677c9521b76c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a6da182420191068f7887677c9521b76c">learn_naive_bayes</a> (<a class="el" href="a00044.html">plDataDescriptor</a> &amp;data, const <a class="el" href="a00140.html">plSymbol</a> &amp;class_node, <a class="el" href="a00160.html#af3353c07f22f33cc74530cf82dafb90c">plStructureLearningScore</a> edge_score=<a class="el" href="a00160.html#af3353c07f22f33cc74530cf82dafb90cae1afff89ba0469aee4389fb7950fdca9">PL_MI</a>, <a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> score_threshold=-std::numeric_limits&lt; <a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> &gt;::infinity())</td></tr>
<tr class="memdesc:a6da182420191068f7887677c9521b76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the structure to naive bayes and learn the parameters using a data set while removing the edges having a value for score less than a given threshold.  <a href="#a6da182420191068f7887677c9521b76c">More...</a><br/></td></tr>
<tr class="separator:a6da182420191068f7887677c9521b76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe747c946eb5995250d53363d4dcaddb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00049.html">plDistribution</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#abe747c946eb5995250d53363d4dcaddb">get_belief</a> (const <a class="el" href="a00140.html">plSymbol</a> &amp;node) const </td></tr>
<tr class="memdesc:abe747c946eb5995250d53363d4dcaddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the belief associated to a given node, knowing the currently inserted evidence.  <a href="#abe747c946eb5995250d53363d4dcaddb">More...</a><br/></td></tr>
<tr class="separator:abe747c946eb5995250d53363d4dcaddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e35495d129f23581de903465608ffa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00049.html">plDistribution</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a99e35495d129f23581de903465608ffa">get_belief</a> (const std::string &amp;node_name) const </td></tr>
<tr class="memdesc:a99e35495d129f23581de903465608ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the belief associated to a given node with name <em>node_name</em>, knowing the currently inserted evidence.  <a href="#a99e35495d129f23581de903465608ffa">More...</a><br/></td></tr>
<tr class="separator:a99e35495d129f23581de903465608ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc8fa2788355cb757048066b3f5952f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00049.html">plDistribution</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a9dc8fa2788355cb757048066b3f5952f">get_belief</a> (const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;node_conjunction) const </td></tr>
<tr class="memdesc:a9dc8fa2788355cb757048066b3f5952f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the belief associated to a given conjunction of nodes, knowing the currently inserted evidence.  <a href="#a9dc8fa2788355cb757048066b3f5952f">More...</a><br/></td></tr>
<tr class="separator:a9dc8fa2788355cb757048066b3f5952f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2445ebf41adcb06e83a978ca8e8d73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa2445ebf41adcb06e83a978ca8e8d73"></a>
const std::vector&lt; <a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#afa2445ebf41adcb06e83a978ca8e8d73">get_belief_table</a> (const <a class="el" href="a00140.html">plSymbol</a> &amp;node) const </td></tr>
<tr class="memdesc:afa2445ebf41adcb06e83a978ca8e8d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the belief table associated to a given node, knowing the currently inserted evidence. <br/></td></tr>
<tr class="separator:afa2445ebf41adcb06e83a978ca8e8d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e55732fd56dce7655c6a7b6e960bb7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e55732fd56dce7655c6a7b6e960bb7e"></a>
const std::vector&lt; <a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a9e55732fd56dce7655c6a7b6e960bb7e">get_belief_table</a> (const std::string &amp;node_name) const </td></tr>
<tr class="memdesc:a9e55732fd56dce7655c6a7b6e960bb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the belief table associated to a given node with name <em>node_name</em>, knowing the currently inserted evidence. <br/></td></tr>
<tr class="separator:a9e55732fd56dce7655c6a7b6e960bb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababca1e65ad85e9c8073ac3ea7390dad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ababca1e65ad85e9c8073ac3ea7390dad"></a>
const std::vector&lt; <a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ababca1e65ad85e9c8073ac3ea7390dad">get_belief_table</a> (const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;node_conjunction) const </td></tr>
<tr class="memdesc:ababca1e65ad85e9c8073ac3ea7390dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the belief table associated to a given conjunction of nodes, knowing the currently inserted evidence. <br/></td></tr>
<tr class="separator:ababca1e65ad85e9c8073ac3ea7390dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01e35f67440493411bdcb7ac3022158"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa01e35f67440493411bdcb7ac3022158"></a>
const <a class="el" href="a00079.html">plJointDistribution</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#aa01e35f67440493411bdcb7ac3022158">get_joint_distribution</a> () const </td></tr>
<tr class="memdesc:aa01e35f67440493411bdcb7ac3022158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="a00079.html" title="The plJointDistribution class is used to describe a probabilistic model by providing a decomposition ...">plJointDistribution</a> object built from this Bayesian network. <br/></td></tr>
<tr class="separator:aa01e35f67440493411bdcb7ac3022158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77187c71f4b338dbe87f55c71d41abcb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77187c71f4b338dbe87f55c71d41abcb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a77187c71f4b338dbe87f55c71d41abcb">save</a> (const std::string &amp;file_name) const </td></tr>
<tr class="memdesc:a77187c71f4b338dbe87f55c71d41abcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the BN in a file. <br/></td></tr>
<tr class="separator:a77187c71f4b338dbe87f55c71d41abcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b58ff6b84e37610e46a5164ef620345"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b58ff6b84e37610e46a5164ef620345"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a8b58ff6b84e37610e46a5164ef620345">load</a> (const std::string &amp;file_name)</td></tr>
<tr class="memdesc:a8b58ff6b84e37610e46a5164ef620345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the BN from a file. <br/></td></tr>
<tr class="separator:a8b58ff6b84e37610e46a5164ef620345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868f151acf96420d882a7267b5023ade"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a868f151acf96420d882a7267b5023ade"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a868f151acf96420d882a7267b5023ade">name</a> () const </td></tr>
<tr class="memdesc:a868f151acf96420d882a7267b5023ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return BN's name. <br/></td></tr>
<tr class="separator:a868f151acf96420d882a7267b5023ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99233ddfe1840ac48fe99a17efbf5337"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99233ddfe1840ac48fe99a17efbf5337"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a99233ddfe1840ac48fe99a17efbf5337">set_name</a> (const std::string &amp;<a class="el" href="a00006.html#a868f151acf96420d882a7267b5023ade">name</a>)</td></tr>
<tr class="memdesc:a99233ddfe1840ac48fe99a17efbf5337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets BN's name. <br/></td></tr>
<tr class="separator:a99233ddfe1840ac48fe99a17efbf5337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4759d3791c84f97eaa9d81e6c5872d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a6b4759d3791c84f97eaa9d81e6c5872d">set_inference_algorithm</a> (<a class="el" href="a00160.html#ac22bfeef2ef8c3e3a219937530b8edee">plInferenceAlgorithm</a> algo)</td></tr>
<tr class="memdesc:a6b4759d3791c84f97eaa9d81e6c5872d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the inference algorithm to be used.  <a href="#a6b4759d3791c84f97eaa9d81e6c5872d">More...</a><br/></td></tr>
<tr class="separator:a6b4759d3791c84f97eaa9d81e6c5872d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3115b9846e7f2bc280d49cf1843619ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a3115b9846e7f2bc280d49cf1843619ed">draw_graph</a> (const std::string &amp;file_name, <a class="el" href="a00204.html#a17b03ddeaa84a29fde5bf564298cafbb">plDrawingLanguage</a> drawing_language=<a class="el" href="a00204.html#a17b03ddeaa84a29fde5bf564298cafbba3d932b4569cdbd6f1882ec17919dd937">PL_XFIG_GRAPH</a>) const </td></tr>
<tr class="memdesc:a3115b9846e7f2bc280d49cf1843619ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the drawing instructions to represent the Graph of the net in <em>file_name</em>.  <a href="#a3115b9846e7f2bc280d49cf1843619ed">More...</a><br/></td></tr>
<tr class="separator:a3115b9846e7f2bc280d49cf1843619ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d1baeb070ffd538e16469caa875702"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ae5d1baeb070ffd538e16469caa875702">draw_graph_dot</a> (const std::string &amp;file_name, const std::string &amp;dot_node_shape=&quot;&quot;, const std::string &amp;dot_node_color=&quot;&quot;, const std::string &amp;dot_node_fill_color=&quot;&quot;, const std::string &amp;dot_background_color=&quot;&quot;, const std::string &amp;dot_rankdir=&quot;&quot;) const </td></tr>
<tr class="memdesc:ae5d1baeb070ffd538e16469caa875702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the graphviz dot drawing instructions to represent the graph of the joint distribution in <em>file_name</em>.  <a href="#ae5d1baeb070ffd538e16469caa875702">More...</a><br/></td></tr>
<tr class="separator:ae5d1baeb070ffd538e16469caa875702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cb00941b7acfbdde29d8e410518fe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a00cb00941b7acfbdde29d8e410518fe7">sample</a> (const std::string &amp;file, unsigned int nsamples, const std::vector&lt; <a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> &gt; &amp;missing_probabilities=std::vector&lt; <a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> &gt;()) const </td></tr>
<tr class="memdesc:a00cb00941b7acfbdde29d8e410518fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate <em>nsamples</em> data in a CSV output file <em>file</em> according to the model defined by the net.  <a href="#a00cb00941b7acfbdde29d8e410518fe7">More...</a><br/></td></tr>
<tr class="separator:a00cb00941b7acfbdde29d8e410518fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7385c10132f7e2f54d90897d390ee7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7385c10132f7e2f54d90897d390ee7b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#aa7385c10132f7e2f54d90897d390ee7b">exists_node</a> (const <a class="el" href="a00140.html">plSymbol</a> &amp;node) const </td></tr>
<tr class="memdesc:aa7385c10132f7e2f54d90897d390ee7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <em>true</em> iff the node exists. <br/></td></tr>
<tr class="separator:aa7385c10132f7e2f54d90897d390ee7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c23e99995987ff245989416efbcbec8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c23e99995987ff245989416efbcbec8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a9c23e99995987ff245989416efbcbec8">exists_node</a> (const std::string &amp;<a class="el" href="a00006.html#a868f151acf96420d882a7267b5023ade">name</a>) const </td></tr>
<tr class="memdesc:a9c23e99995987ff245989416efbcbec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <em>true</em> iff a node with name <em>name</em> exists. <br/></td></tr>
<tr class="separator:a9c23e99995987ff245989416efbcbec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f9bd26d3c922e0982af7322ab137b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0f9bd26d3c922e0982af7322ab137b9"></a>
<a class="el" href="a00150.html">plVariablesConjunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ad0f9bd26d3c922e0982af7322ab137b9">node_parents</a> (const <a class="el" href="a00140.html">plSymbol</a> &amp;node) const </td></tr>
<tr class="memdesc:ad0f9bd26d3c922e0982af7322ab137b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return node's parents. <br/></td></tr>
<tr class="separator:ad0f9bd26d3c922e0982af7322ab137b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f536fcae8ab1312299f1e38d0bf0d38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f536fcae8ab1312299f1e38d0bf0d38"></a>
<a class="el" href="a00150.html">plVariablesConjunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a6f536fcae8ab1312299f1e38d0bf0d38">node_parents</a> (const std::string &amp;<a class="el" href="a00006.html#a868f151acf96420d882a7267b5023ade">name</a>) const </td></tr>
<tr class="memdesc:a6f536fcae8ab1312299f1e38d0bf0d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the parents of the node having the name <em>name</em>. <br/></td></tr>
<tr class="separator:a6f536fcae8ab1312299f1e38d0bf0d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0e41227a79de1c34efacfad19dd6f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e0e41227a79de1c34efacfad19dd6f1"></a>
<a class="el" href="a00150.html">plVariablesConjunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a9e0e41227a79de1c34efacfad19dd6f1">node_children</a> (const <a class="el" href="a00140.html">plSymbol</a> &amp;node) const </td></tr>
<tr class="memdesc:a9e0e41227a79de1c34efacfad19dd6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return node's children. <br/></td></tr>
<tr class="separator:a9e0e41227a79de1c34efacfad19dd6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e38a47c302909045346bcbd35b7a943"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e38a47c302909045346bcbd35b7a943"></a>
<a class="el" href="a00150.html">plVariablesConjunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a4e38a47c302909045346bcbd35b7a943">node_children</a> (const std::string &amp;<a class="el" href="a00006.html#a868f151acf96420d882a7267b5023ade">name</a>) const </td></tr>
<tr class="memdesc:a4e38a47c302909045346bcbd35b7a943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the children of the node having the name <em>name</em>. <br/></td></tr>
<tr class="separator:a4e38a47c302909045346bcbd35b7a943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62ee25ce5a964014ec249fb7437a809"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ae62ee25ce5a964014ec249fb7437a809">apply_prediction</a> (const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;target_variables, <a class="el" href="a00044.html">plDataDescriptor</a> &amp;data, const std::string &amp;output_file, bool output_probability_table=false, unsigned int nrows=std::numeric_limits&lt; unsigned int &gt;::max()) const </td></tr>
<tr class="memdesc:ae62ee25ce5a964014ec249fb7437a809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask a query to the BN and apply it to a data set.  <a href="#ae62ee25ce5a964014ec249fb7437a809">More...</a><br/></td></tr>
<tr class="separator:ae62ee25ce5a964014ec249fb7437a809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c6463c967af76cdbb8fc87ecfeff87"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a00147.html">plValues</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a21c6463c967af76cdbb8fc87ecfeff87">apply_prediction</a> (const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;target_variables, <a class="el" href="a00044.html">plDataDescriptor</a> &amp;data, unsigned int nrows=std::numeric_limits&lt; unsigned int &gt;::max()) const </td></tr>
<tr class="memdesc:a21c6463c967af76cdbb8fc87ecfeff87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask a query to the BN and apply it to a data set.  <a href="#a21c6463c967af76cdbb8fc87ecfeff87">More...</a><br/></td></tr>
<tr class="separator:a21c6463c967af76cdbb8fc87ecfeff87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df55f9b152a56a6fd59efb6bd686ce1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00147.html">plValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a0df55f9b152a56a6fd59efb6bd686ce1">prediction</a> (const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;target_variables, const <a class="el" href="a00147.html">plValues</a> &amp;evidence) const </td></tr>
<tr class="memdesc:a0df55f9b152a56a6fd59efb6bd686ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of <em>target_variables</em> that maximises the probabilit given the evidence <em>evidence</em> P(target_variables | evidence).  <a href="#a0df55f9b152a56a6fd59efb6bd686ce1">More...</a><br/></td></tr>
<tr class="separator:a0df55f9b152a56a6fd59efb6bd686ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79eb712479af21542c628bfa9b788d60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a79eb712479af21542c628bfa9b788d60">validate_prediction</a> (const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;target_variables, <a class="el" href="a00044.html">plDataDescriptor</a> &amp;data, const std::string &amp;output_file, bool output_probability_table=false, unsigned int nrows=std::numeric_limits&lt; unsigned int &gt;::max()) const </td></tr>
<tr class="memdesc:a79eb712479af21542c628bfa9b788d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask a query to the model, apply it to a data set, and provide validation statistics.  <a href="#a79eb712479af21542c628bfa9b788d60">More...</a><br/></td></tr>
<tr class="separator:a79eb712479af21542c628bfa9b788d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d69eb6f6f50ea545f91c4cb6905b071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a1d69eb6f6f50ea545f91c4cb6905b071">validate_prediction</a> (const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;target_variables, <a class="el" href="a00044.html">plDataDescriptor</a> &amp;data, const std::string &amp;output_file, std::vector&lt; unsigned int &gt; &amp;hard_confusion_matrix, bool output_probability_table=false, unsigned int nrows=std::numeric_limits&lt; unsigned int &gt;::max()) const </td></tr>
<tr class="memdesc:a1d69eb6f6f50ea545f91c4cb6905b071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask a query to the model, apply it to a data set, and provide validation statistics.  <a href="#a1d69eb6f6f50ea545f91c4cb6905b071">More...</a><br/></td></tr>
<tr class="separator:a1d69eb6f6f50ea545f91c4cb6905b071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c47fd826608bafee3ece4891ed19cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#af4c47fd826608bafee3ece4891ed19cc">validate_prediction</a> (const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;target_variables, <a class="el" href="a00044.html">plDataDescriptor</a> &amp;data, const std::string &amp;output_file, std::vector&lt; unsigned int &gt; &amp;hard_confusion_matrix, std::vector&lt; <a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> &gt; &amp;soft_confusion_matrix, bool output_probability_table=false, unsigned int nrows=std::numeric_limits&lt; unsigned int &gt;::max()) const </td></tr>
<tr class="memdesc:af4c47fd826608bafee3ece4891ed19cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask a query to the model, apply it to a data set, and provide validation statistics.  <a href="#af4c47fd826608bafee3ece4891ed19cc">More...</a><br/></td></tr>
<tr class="separator:af4c47fd826608bafee3ece4891ed19cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b75b464d6554318a21046de1d2029d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54b75b464d6554318a21046de1d2029d"></a>
<a class="el" href="a00150.html">plVariablesConjunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a54b75b464d6554318a21046de1d2029d">get_markov_blanket</a> (const <a class="el" href="a00140.html">plSymbol</a> &amp;node) const </td></tr>
<tr class="memdesc:a54b75b464d6554318a21046de1d2029d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Markov blanket for a given node. <br/></td></tr>
<tr class="separator:a54b75b464d6554318a21046de1d2029d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62fee1c4e70b7ac4c5da93c792da62dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a62fee1c4e70b7ac4c5da93c792da62dc">set_verbose_structure_learning</a> (bool verbose=true)</td></tr>
<tr class="memdesc:a62fee1c4e70b7ac4c5da93c792da62dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/unset verbose mode for structure learning.  <a href="#a62fee1c4e70b7ac4c5da93c792da62dc">More...</a><br/></td></tr>
<tr class="separator:a62fee1c4e70b7ac4c5da93c792da62dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d946108e5cccbf8ea799c3a63afd5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ad2d946108e5cccbf8ea799c3a63afd5f">set_verbose_em_learning</a> (bool verbose=true)</td></tr>
<tr class="memdesc:ad2d946108e5cccbf8ea799c3a63afd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/unset verbose mode for parameter learning using EM.  <a href="#ad2d946108e5cccbf8ea799c3a63afd5f">More...</a><br/></td></tr>
<tr class="separator:ad2d946108e5cccbf8ea799c3a63afd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5a707ef30b1944d44e466183262443"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a9f5a707ef30b1944d44e466183262443">set_compiled_belief_distribution</a> (bool compile_it)</td></tr>
<tr class="memdesc:a9f5a707ef30b1944d44e466183262443"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set to 'true' (the default value), the distributions returned by <a class="el" href="a00006.html#abe747c946eb5995250d53363d4dcaddb" title="Returns the belief associated to a given node, knowing the currently inserted evidence. ">get_belief()</a> are compiled.  <a href="#a9f5a707ef30b1944d44e466183262443">More...</a><br/></td></tr>
<tr class="separator:a9f5a707ef30b1944d44e466183262443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84c1c08e56749c6637a7b6f295c6af0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae84c1c08e56749c6637a7b6f295c6af0"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ae84c1c08e56749c6637a7b6f295c6af0">learned_parameters_number</a> () const </td></tr>
<tr class="memdesc:ae84c1c08e56749c6637a7b6f295c6af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of parameters to learn. <br/></td></tr>
<tr class="separator:ae84c1c08e56749c6637a7b6f295c6af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcb6129115cffdce02fe5bb85f1a6ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bcb6129115cffdce02fe5bb85f1a6ce"></a>
<a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a3bcb6129115cffdce02fe5bb85f1a6ce">compute_data_record_log_likelihood</a> (const <a class="el" href="a00147.html">plValues</a> &amp;data_record) const </td></tr>
<tr class="memdesc:a3bcb6129115cffdce02fe5bb85f1a6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the log-likelihood of a given record. <br/></td></tr>
<tr class="separator:a3bcb6129115cffdce02fe5bb85f1a6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74de80104f12fc4a65b7c3c34d85b303"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a74de80104f12fc4a65b7c3c34d85b303">compute_data_set_log_likelihood</a> (<a class="el" href="a00044.html">plDataDescriptor</a> &amp;data_set, unsigned int nrows=std::numeric_limits&lt; unsigned int &gt;::max()) const </td></tr>
<tr class="memdesc:a74de80104f12fc4a65b7c3c34d85b303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the log-likelihood of a given data set.  <a href="#a74de80104f12fc4a65b7c3c34d85b303">More...</a><br/></td></tr>
<tr class="separator:a74de80104f12fc4a65b7c3c34d85b303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6d6f02d3d073d2090a0e4d3840392a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a8b6d6f02d3d073d2090a0e4d3840392a">compute_data_set_log_likelihood</a> (const std::vector&lt; <a class="el" href="a00147.html">plValues</a> &gt; &amp;data_records) const </td></tr>
<tr class="memdesc:a8b6d6f02d3d073d2090a0e4d3840392a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the log-likelihood of a given vector of data records.  <a href="#a8b6d6f02d3d073d2090a0e4d3840392a">More...</a><br/></td></tr>
<tr class="separator:a8b6d6f02d3d073d2090a0e4d3840392a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6520eb8973ec20f77e221e7513ae143a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6520eb8973ec20f77e221e7513ae143a"></a>
<a class="el" href="a00036.html">plComputableObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a6520eb8973ec20f77e221e7513ae143a">get_node_distribution</a> (const <a class="el" href="a00140.html">plSymbol</a> &amp;node) const </td></tr>
<tr class="memdesc:a6520eb8973ec20f77e221e7513ae143a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the input distribution over the node <em>node</em>. <br/></td></tr>
<tr class="separator:a6520eb8973ec20f77e221e7513ae143a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae227e2b1fc95dadefc266c0072ad44ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae227e2b1fc95dadefc266c0072ad44ac"></a>
<a class="el" href="a00103.html">plLearnObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#ae227e2b1fc95dadefc266c0072ad44ac">get_node_learnable_distribution</a> (const <a class="el" href="a00140.html">plSymbol</a> &amp;node) const </td></tr>
<tr class="memdesc:ae227e2b1fc95dadefc266c0072ad44ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the input learnable distribution over the node <em>node</em>. <br/></td></tr>
<tr class="separator:ae227e2b1fc95dadefc266c0072ad44ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113eb72f19b451ce60ea6194bf159882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a113eb72f19b451ce60ea6194bf159882">add_time_transition_edge</a> (const <a class="el" href="a00140.html">plSymbol</a> &amp;node_prec_timeslice, const <a class="el" href="a00140.html">plSymbol</a> &amp;node_current_timeslice)</td></tr>
<tr class="memdesc:a113eb72f19b451ce60ea6194bf159882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a time-transition edge.  <a href="#a113eb72f19b451ce60ea6194bf159882">More...</a><br/></td></tr>
<tr class="separator:a113eb72f19b451ce60ea6194bf159882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee05426d13eb89f73cb2f798f96d61f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#aee05426d13eb89f73cb2f798f96d61f6">set_time_transition_distribution</a> (const <a class="el" href="a00024.html">plCndDistribution</a> &amp;transition)</td></tr>
<tr class="memdesc:aee05426d13eb89f73cb2f798f96d61f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a time-transition edge.  <a href="#aee05426d13eb89f73cb2f798f96d61f6">More...</a><br/></td></tr>
<tr class="separator:aee05426d13eb89f73cb2f798f96d61f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72614b2ed61f98f106ee9415b2845429"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a72614b2ed61f98f106ee9415b2845429">set_time_transition_learnable_distribution</a> (const <a class="el" href="a00103.html">plLearnObject</a> &amp;learnable_transition)</td></tr>
<tr class="memdesc:a72614b2ed61f98f106ee9415b2845429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a time-transition learnable distribution.  <a href="#a72614b2ed61f98f106ee9415b2845429">More...</a><br/></td></tr>
<tr class="separator:a72614b2ed61f98f106ee9415b2845429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7efe5f890fa4372f3f19d50ab21b4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a2d7efe5f890fa4372f3f19d50ab21b4e">next_time_slice</a> ()</td></tr>
<tr class="memdesc:a2d7efe5f890fa4372f3f19d50ab21b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update all the time-slice distributions if the BN is dynamic.  <a href="#a2d7efe5f890fa4372f3f19d50ab21b4e">More...</a><br/></td></tr>
<tr class="separator:a2d7efe5f890fa4372f3f19d50ab21b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c821509d262895bac4377c068571775"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c821509d262895bac4377c068571775"></a>
<a class="el" href="a00006.html#a5c826ed379482d64a4fc0bbb44969c64">bn_edge_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a1c821509d262895bac4377c068571775">get_time_slice_edges</a> () const </td></tr>
<tr class="memdesc:a1c821509d262895bac4377c068571775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time-slice edges as pairs of (var_{t-1}, (var_{t}). <br/></td></tr>
<tr class="separator:a1c821509d262895bac4377c068571775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebad96655011a9e11ec6f055f13cbde5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#aebad96655011a9e11ec6f055f13cbde5">set_query_cache_max_size</a> (unsigned int new_size)</td></tr>
<tr class="memdesc:aebad96655011a9e11ec6f055f13cbde5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of the cached target distributions.  <a href="#aebad96655011a9e11ec6f055f13cbde5">More...</a><br/></td></tr>
<tr class="separator:aebad96655011a9e11ec6f055f13cbde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_a00123"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_a00123')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="a00123.html">plObject</a></td></tr>
<tr class="memitem:ae56b362a1e46e4a0c217e260324fb28a inherit pub_methods_a00123"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae56b362a1e46e4a0c217e260324fb28a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#ae56b362a1e46e4a0c217e260324fb28a">plObject</a> ()</td></tr>
<tr class="memdesc:ae56b362a1e46e4a0c217e260324fb28a inherit pub_methods_a00123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="separator:ae56b362a1e46e4a0c217e260324fb28a inherit pub_methods_a00123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9c71b1b5085c527269ffa5bdd87522 inherit pub_methods_a00123"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#a5a9c71b1b5085c527269ffa5bdd87522">~plObject</a> ()</td></tr>
<tr class="memdesc:a5a9c71b1b5085c527269ffa5bdd87522 inherit pub_methods_a00123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the object.  <a href="#a5a9c71b1b5085c527269ffa5bdd87522">More...</a><br/></td></tr>
<tr class="separator:a5a9c71b1b5085c527269ffa5bdd87522 inherit pub_methods_a00123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b86aedf034cce26568c14020bd6c6d inherit pub_methods_a00123"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html#ad6b86aedf034cce26568c14020bd6c6d">to_string</a> (std::ostringstream *s=0) const </td></tr>
<tr class="memdesc:ad6b86aedf034cce26568c14020bd6c6d inherit pub_methods_a00123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object as a string.  <a href="#ad6b86aedf034cce26568c14020bd6c6d">More...</a><br/></td></tr>
<tr class="separator:ad6b86aedf034cce26568c14020bd6c6d inherit pub_methods_a00123"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a507448d61559c439b54f22e491e6430f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a507448d61559c439b54f22e491e6430f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html#a507448d61559c439b54f22e491e6430f">Output</a> (std::ostream &amp;os) const </td></tr>
<tr class="memdesc:a507448d61559c439b54f22e491e6430f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a human-readable representation of the network. <br/></td></tr>
<tr class="separator:a507448d61559c439b54f22e491e6430f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Simple helper for building a Bayesian network and using it for exact inference using discrete variables (continuous variables are allowed only when used as evidence ones). </p>
<p>This class is redundant with other objects of the API. It is made available to facilitate the use of the ProBT by newcomers.</p>
<p>Transitioning from this class to the classic ProBT API is easy. Consider the following example using <a class="el" href="a00006.html" title="Simple helper for building a Bayesian network and using it for exact inference using discrete variabl...">plBayesianNetwork</a>: </p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> a_vals[] = {1, 3.6, 5};</div>
<div class="line"><a class="code" href="a00140.html">plSymbol</a> a(<span class="stringliteral">&quot;A&quot;</span>, <a class="code" href="a00047.html">plDiscreteIntervalType</a>(3, a_vals));</div>
<div class="line"><a class="code" href="a00140.html">plSymbol</a> b(<span class="stringliteral">&quot;B&quot;</span>, <a class="code" href="a00078.html">plIntegerType</a>(0, 10));</div>
<div class="line"><a class="code" href="a00006.html">plBayesianNetwork</a> net;</div>
<div class="line">net.<a class="code" href="a00006.html#a28d5204db586df56de765b701effba43">add_node</a>(a);</div>
<div class="line">net.<a class="code" href="a00006.html#a28d5204db586df56de765b701effba43">add_node</a>(b);</div>
<div class="line">net.<a class="code" href="a00006.html#aa25c077d94f5b2d08f953cec933241ef">set_distribution</a>(<a class="code" href="a00144.html">plUniform</a>(a));</div>
<div class="line">net.<a class="code" href="a00006.html#aa25c077d94f5b2d08f953cec933241ef">set_distribution</a>(<a class="code" href="a00030.html">plCndNormal</a>(b, 5, a));</div>
<div class="line"><a class="code" href="a00147.html">plValues</a> evidence(b);</div>
<div class="line">evidence[b] = 2;</div>
<div class="line">net.<a class="code" href="a00006.html#ac6e33c56ff1576b5927e6aaa12577db0">set_evidence</a>(evidence);</div>
<div class="line"><span class="comment">// P(A = 5 | B = 2)</span></div>
<div class="line">std::cout &lt;&lt; net.<a class="code" href="a00006.html#abe747c946eb5995250d53363d4dcaddb">get_belief</a>(a).<a class="code" href="a00049.html#ab464372d19d9101e387f2e954a1daba6">compute</a>(5) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>This example can be replicated with the classic and more powerful ProBT API: </p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> a_vals[] = {1, 3.6, 5};</div>
<div class="line"><a class="code" href="a00140.html">plSymbol</a> a(<span class="stringliteral">&quot;A&quot;</span>, <a class="code" href="a00047.html">plDiscreteIntervalType</a>(3, a_vals));</div>
<div class="line"><a class="code" href="a00140.html">plSymbol</a> b(<span class="stringliteral">&quot;B&quot;</span>, <a class="code" href="a00078.html">plIntegerType</a>(0, 10));</div>
<div class="line"><a class="code" href="a00079.html">plJointDistribution</a> j(a ^ b,</div>
<div class="line"><a class="code" href="a00144.html">plUniform</a>(a) * <a class="code" href="a00030.html">plCndNormal</a>(b, 5, a));</div>
<div class="line"><a class="code" href="a00147.html">plValues</a> evidence(b);</div>
<div class="line">evidence[b] = 2;</div>
<div class="line"><span class="comment">// P(A = 5 | B = 2)</span></div>
<div class="line">std::cout &lt;&lt; j.ask(a, b).instantiate(evidence).compute(5) &lt;&lt; std::endl;   </div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a879e518761ff567a5e6df7c26bc61eea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">plBayesianNetwork::plBayesianNetwork </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;untitled_BN&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds an empty Bayesian network. </p>
<p>Add nodes to it using <a class="el" href="a00006.html#a28d5204db586df56de765b701effba43" title="Add a node with name name and of type type. ">add_node()</a>. Simultaneously add links and set the corresponding probability distribution using <a class="el" href="a00006.html#aa25c077d94f5b2d08f953cec933241ef" title="Sets the distribution associated to a given node. ">set_distribution()</a>. Insert evidence using <a class="el" href="a00006.html#ac6e33c56ff1576b5927e6aaa12577db0" title="Sets the evidence in the network. ">set_evidence()</a>. Get a belief corresponding to this last evidence using <a class="el" href="a00006.html#abe747c946eb5995250d53363d4dcaddb" title="Returns the belief associated to a given node, knowing the currently inserted evidence. ">get_belief()</a> (inference/propagation in the network is made automatically for you when needed). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4f7cf86ce9dba3d30028e98738bb60a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::add_evidence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00147.html">plValues</a> &amp;&#160;</td>
          <td class="paramname"><em>added_evidence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_validity</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addes a evidence in the network. </p>
<p>This adds the new evidence to the previously existing evidence. Evidence is contained in a <a class="el" href="a00147.html" title="A plValues is an object storing the values of a set of variables. ">plValues</a> object. For instance, to add an evidence over nodes <em>a</em> and <em>c</em>, that a=2 and c = 42: </p>
<div class="fragment"><div class="line"><a class="code" href="a00147.html">plValues</a> evidence(a ^ c);</div>
<div class="line">evidence[a] = 2;</div>
<div class="line">evidence[c] = 42;</div>
<div class="line">net.<a class="code" href="a00006.html#a4f7cf86ce9dba3d30028e98738bb60a3">add_evidence</a>(evidence);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a9eb5c8f203f34bea7408be3731a13983"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::add_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00140.html">plSymbol</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares a node in the network. </p>
<p>The node is described by a <a class="el" href="a00140.html" title="A plSymbol is a set containing one and only one unidimensional variable. ">plSymbol</a> object, which represents a variable. </p>

</div>
</div>
<a class="anchor" id="a113eb72f19b451ce60ea6194bf159882"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::add_time_transition_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00140.html">plSymbol</a> &amp;&#160;</td>
          <td class="paramname"><em>node_prec_timeslice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00140.html">plSymbol</a> &amp;&#160;</td>
          <td class="paramname"><em>node_current_timeslice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a time-transition edge. </p>
<p>For example, to add a time transition edge </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ P(X_{t} | X_{t-1} ) \]" src="form_22.png"/>
</p>
<p>, one can write: </p>
<div class="fragment"><div class="line"><a class="code" href="a00006.html">plBayesianNetwork</a> bn;</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="a00140.html">plSymbol</a> x(<span class="stringliteral">&quot;X&quot;</span>, <a class="code" href="a00225.html#a229326e7960dd2c88ee6a14cb3fec484">PL_BINARY_TYPE</a>);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="a00140.html">plSymbol</a> x_(<span class="stringliteral">&quot;X_&quot;</span>, <a class="code" href="a00225.html#a229326e7960dd2c88ee6a14cb3fec484">PL_BINARY_TYPE</a>);</div>
<div class="line"></div>
<div class="line">bn.<a class="code" href="a00006.html#a28d5204db586df56de765b701effba43">add_node</a>(x);</div>
<div class="line">bn.<a class="code" href="a00006.html#a28d5204db586df56de765b701effba43">add_node</a>(x_);</div>
<div class="line"></div>
<div class="line">bn.<a class="code" href="a00006.html#a113eb72f19b451ce60ea6194bf159882">add_time_transition_edge</a>( x_, x );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ae62ee25ce5a964014ec249fb7437a809"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::apply_prediction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>target_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html">plDataDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>output_probability_table</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nrows</em> = <code>std::numeric_limits&lt;&#160;unsigned&#160;int&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask a query to the BN and apply it to a data set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target_variables</td><td>The target variables to predict </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The input data set to be used for prediction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_file</td><td>The output file. It will include the columns (variables) of the input data set with additional columns corresponding the predicted target variables and the corresponding distribution table if 'output_probability_table=true' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_probability_table</td><td>If 'true', the probability table corresponding to the prediction will be added to the output file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows</td><td>The number of rows to be used for this prediction (starting from the current position in the input data source)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00006.html#a0df55f9b152a56a6fd59efb6bd686ce1" title="Return the value of target_variables that maximises the probabilit given the evidence evidence P(tar...">prediction()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a21c6463c967af76cdbb8fc87ecfeff87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="a00147.html">plValues</a>&gt; plBayesianNetwork::apply_prediction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>target_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html">plDataDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nrows</em> = <code>std::numeric_limits&lt;&#160;unsigned&#160;int&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask a query to the BN and apply it to a data set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target_variables</td><td>The target variables to predict </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The input data set to be used for prediction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows</td><td>The number of rows to be used for this prediction (starting from the current position in the input data source)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>for each data record, the value of <em>target_variables</em> that maximises the probabiliy given the evidence provided by the data row P(target_variables | row_evidence).</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00006.html#a0df55f9b152a56a6fd59efb6bd686ce1" title="Return the value of target_variables that maximises the probabilit given the evidence evidence P(tar...">prediction()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a74de80104f12fc4a65b7c3c34d85b303"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> plBayesianNetwork::compute_data_set_log_likelihood </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html">plDataDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>data_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nrows</em> = <code>std::numeric_limits&lt;&#160;unsigned&#160;int&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the log-likelihood of a given data set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">data_set</td><td>the data set for which the log-likelihood will be computed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows</td><td>The number of rows to be used for this validation (starting from the current position in the input data source)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log-likelihood of the data set </dd></dl>

</div>
</div>
<a class="anchor" id="a8b6d6f02d3d073d2090a0e4d3840392a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> plBayesianNetwork::compute_data_set_log_likelihood </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a00147.html">plValues</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_records</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the log-likelihood of a given vector of data records. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_records</td><td>the vector of data records for which the log-likelihood will be computed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log-likelihood of the data set </dd></dl>

</div>
</div>
<a class="anchor" id="a3115b9846e7f2bc280d49cf1843619ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::draw_graph </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00204.html#a17b03ddeaa84a29fde5bf564298cafbb">plDrawingLanguage</a>&#160;</td>
          <td class="paramname"><em>drawing_language</em> = <code><a class="el" href="a00204.html#a17b03ddeaa84a29fde5bf564298cafbba3d932b4569cdbd6f1882ec17919dd937">PL_XFIG_GRAPH</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the drawing instructions to represent the Graph of the net in <em>file_name</em>. </p>
<p>The current implementation allows using xfig and graphviz dot.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00006.html#ae5d1baeb070ffd538e16469caa875702" title="Writes the graphviz dot drawing instructions to represent the graph of the joint distribution in file...">draw_graph_dot</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae5d1baeb070ffd538e16469caa875702"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::draw_graph_dot </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dot_node_shape</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dot_node_color</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dot_node_fill_color</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dot_background_color</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dot_rankdir</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the graphviz dot drawing instructions to represent the graph of the joint distribution in <em>file_name</em>. </p>
<p>The parameters dot_node_shape, dot_node_color, dot_node_fill_color, dot_background_color, and dot_rankdir correspond to graphviz dot ones (see <a href="http://www.graphviz.org/pdf/dotguide.pdf">http://www.graphviz.org/pdf/dotguide.pdf</a>). There values will be inserted in the generated dot file without checking their validity.</p>
<p>To generate an image file from the generated graphvis dot <em>file_name</em>, you can use "dot -T'img_format' 'file_name' -o file_name.'img_format' " in which 'img_format' could be "pdf", "png",... The supported image formats could be found in <a href="http://www.graphviz.org/pdf/dotguide.pdf">http://www.graphviz.org/pdf/dotguide.pdf</a> </p>

</div>
</div>
<a class="anchor" id="abe747c946eb5995250d53363d4dcaddb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00049.html">plDistribution</a>&amp; plBayesianNetwork::get_belief </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00140.html">plSymbol</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the belief associated to a given node, knowing the currently inserted evidence. </p>
<p>Belief is returned as a <a class="el" href="a00049.html" title="The plDistribution class is the base class of all non-conditional probability (and density) distribut...">plDistribution</a> object, that is a non-conditional probability distribution whose values can be inspected using <a class="el" href="a00049.html#ab464372d19d9101e387f2e954a1daba6" title="Computes the value of the function for the one-dimensional input parameter value. ...">plDistribution::compute()</a> and <a class="el" href="a00049.html#a51fbb3bdaf79a1e70d8404e587234405" title="Tabulates the distribution in &quot;out&quot; stream. ">plDistribution::tabulate()</a>.</p>
<p>This belief can also be used as a building block for another <a class="el" href="a00079.html" title="The plJointDistribution class is used to describe a probabilistic model by providing a decomposition ...">plJointDistribution</a> or <a class="el" href="a00006.html" title="Simple helper for building a Bayesian network and using it for exact inference using discrete variabl...">plBayesianNetwork</a> object (using <a class="el" href="a00006.html#aa25c077d94f5b2d08f953cec933241ef" title="Sets the distribution associated to a given node. ">plBayesianNetwork::set_distribution()</a>). </p>

</div>
</div>
<a class="anchor" id="a99e35495d129f23581de903465608ffa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00049.html">plDistribution</a>&amp; plBayesianNetwork::get_belief </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>node_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the belief associated to a given node with name <em>node_name</em>, knowing the currently inserted evidence. </p>
<p>Belief is returned as a <a class="el" href="a00049.html" title="The plDistribution class is the base class of all non-conditional probability (and density) distribut...">plDistribution</a> object, that is a non-conditional probability distribution whose values can be inspected using <a class="el" href="a00049.html#ab464372d19d9101e387f2e954a1daba6" title="Computes the value of the function for the one-dimensional input parameter value. ...">plDistribution::compute()</a> and <a class="el" href="a00049.html#a51fbb3bdaf79a1e70d8404e587234405" title="Tabulates the distribution in &quot;out&quot; stream. ">plDistribution::tabulate()</a>.</p>
<p>This belief can also be used as a building block for another <a class="el" href="a00079.html" title="The plJointDistribution class is used to describe a probabilistic model by providing a decomposition ...">plJointDistribution</a> or <a class="el" href="a00006.html" title="Simple helper for building a Bayesian network and using it for exact inference using discrete variabl...">plBayesianNetwork</a> object (using <a class="el" href="a00006.html#aa25c077d94f5b2d08f953cec933241ef" title="Sets the distribution associated to a given node. ">plBayesianNetwork::set_distribution()</a>). </p>

</div>
</div>
<a class="anchor" id="a9dc8fa2788355cb757048066b3f5952f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00049.html">plDistribution</a>&amp; plBayesianNetwork::get_belief </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>node_conjunction</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the belief associated to a given conjunction of nodes, knowing the currently inserted evidence. </p>
<p>Belief is returned as a <a class="el" href="a00049.html" title="The plDistribution class is the base class of all non-conditional probability (and density) distribut...">plDistribution</a> object, that is a non-conditional probability distribution whose values can be inspected using <a class="el" href="a00049.html#ab464372d19d9101e387f2e954a1daba6" title="Computes the value of the function for the one-dimensional input parameter value. ...">plDistribution::compute()</a> and <a class="el" href="a00049.html#a51fbb3bdaf79a1e70d8404e587234405" title="Tabulates the distribution in &quot;out&quot; stream. ">plDistribution::tabulate()</a>.</p>
<p>This belief can also be used as a building block for another <a class="el" href="a00079.html" title="The plJointDistribution class is used to describe a probabilistic model by providing a decomposition ...">plJointDistribution</a> or <a class="el" href="a00006.html" title="Simple helper for building a Bayesian network and using it for exact inference using discrete variabl...">plBayesianNetwork</a> object (using <a class="el" href="a00006.html#aa25c077d94f5b2d08f953cec933241ef" title="Sets the distribution associated to a given node. ">plBayesianNetwork::set_distribution()</a>). </p>

</div>
</div>
<a class="anchor" id="a6da182420191068f7887677c9521b76c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::learn_naive_bayes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html">plDataDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00140.html">plSymbol</a> &amp;&#160;</td>
          <td class="paramname"><em>class_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00160.html#af3353c07f22f33cc74530cf82dafb90c">plStructureLearningScore</a>&#160;</td>
          <td class="paramname"><em>edge_score</em> = <code><a class="el" href="a00160.html#af3353c07f22f33cc74530cf82dafb90cae1afff89ba0469aee4389fb7950fdca9">PL_MI</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td>
          <td class="paramname"><em>score_threshold</em> = <code>-std::numeric_limits&lt;&#160;<a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;&gt;::infinity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the structure to naive bayes and learn the parameters using a data set while removing the edges having a value for score less than a given threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>The data source to be used for learning the structure and then the parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">class_node</td><td>The class node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge_score</td><td>The edge score to be used for evaluating the 'class -&gt; non class' edges. This parameter is used iff 'score_threshold' below is not -infinity </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">score_threshold</td><td>The threshold to be used for removing some 'class -&gt; non class' edges. The default value -infinity means that no 'class -&gt; non class' edge will be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c01d2f5864e916bee74c1b552415507"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::learn_parameters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>csv_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>em_iterations</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>csv_file_has_header</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>csv_file_undefined_field</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>csv_file_field_separators</em> = <code>&quot;,;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>csv_file_quotes</em> = <code>&quot;'\&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_em</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Learns the parameters of learnable distributions in the network. </p>
<p>There can be arbitrary missing data in the learning observations. If <em>no_em</em> is set to true (the default is <em>false</em>), only available values are used. Otherwise, EM (Expectation-Maximization) algorithm is used. This EM algorithm is implemented using <a class="el" href="a00061.html" title="This class implements a generic EM (Expectation-Maximization) learning algorithm (using incomplete da...">plEMLearner</a> and is run for <em>em_iterations</em> iterations if a positive value is provided. If <em>em_iterations</em> is not positive (the default value), the algorithm will be run until convergence.</p>
<p>The learning data is made of observations on the network variables, in a CSV (comma separated values) file.</p>
<p>The CSV files consists in a series of lines in text. Each line is made of a comma or semicolon-separated list of fields. Each field can be non-quoted, or quoted using single (') or double quotes ("). However, fields containing a comma or semicolon must be quoted. Spaces around quoted fields are ignored. You may include a quote inside a quoted field by doubling it.</p>
<p>The CSV file must be structured in the following way:</p>
<ul>
<li>its first line (the header) gives the names of the observed variables</li>
<li>each of the following lines gives the values of the observed variables for a given observation</li>
<li>a value can be left empty to signify that it was not observed.</li>
</ul>
<p>For instance, we can build a network with variables A, B, and C : </p>
<div class="fragment"><div class="line"><a class="code" href="a00140.html">plSymbol</a> a(<span class="stringliteral">&quot;A&quot;</span>, <a class="code" href="a00078.html">plIntegerType</a>(0, 42));</div>
<div class="line"><a class="code" href="a00140.html">plSymbol</a> b(<span class="stringliteral">&quot;B&quot;</span>, <a class="code" href="a00078.html">plIntegerType</a>(-2, 2));</div>
<div class="line"><a class="code" href="a00140.html">plSymbol</a> c(<span class="stringliteral">&quot;C&quot;</span>, <a class="code" href="a00078.html">plIntegerType</a>(-1, 1));</div>
<div class="line"><a class="code" href="a00006.html">plBayesianNetwork</a> net;</div>
<div class="line">net.<a class="code" href="a00006.html#a28d5204db586df56de765b701effba43">add_node</a>(a);</div>
<div class="line">net.<a class="code" href="a00006.html#a28d5204db586df56de765b701effba43">add_node</a>(b);</div>
<div class="line">net.<a class="code" href="a00006.html#a28d5204db586df56de765b701effba43">add_node</a>(c);</div>
<div class="line"><a class="code" href="a00095.html">plLearnLaplace</a> learn_a(a);</div>
<div class="line">net.<a class="code" href="a00006.html#aa25c077d94f5b2d08f953cec933241ef">set_distribution</a>(learn_a);</div>
<div class="line"><a class="code" href="a00028.html">plCndLearnObject&lt;plLearn1dNormal&gt;</a> learn_b_k_a(b, a);</div>
<div class="line">net.<a class="code" href="a00006.html#aa25c077d94f5b2d08f953cec933241ef">set_distribution</a>(learn_b_k_a);</div>
<div class="line"><a class="code" href="a00028.html">plCndLearnObject&lt;plLearn1dNormal&gt;</a> learn_c_k_b(c, b);</div>
<div class="line">net.<a class="code" href="a00006.html#aa25c077d94f5b2d08f953cec933241ef">set_distribution</a>(learn_c_k_b);</div>
<div class="line"><span class="comment">//net.learn_parameters(&quot;data.csv&quot;, 4);</span></div>
<div class="line">net.<a class="code" href="a00006.html#a7c01d2f5864e916bee74c1b552415507">learn_parameters</a>(<span class="stringliteral">&quot;data.csv&quot;</span>);</div>
<div class="line">std::cout &lt;&lt; net &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The CSV file "data.csv" may have the following contents: </p>
<div class="fragment"><div class="line">C,A</div>
<div class="line">0,41</div>
<div class="line">1,</div>
<div class="line">,7</div>
<div class="line">0,2</div>
</div><!-- fragment --><p>In this file, the header announces that we will have values for C, then A. No values for B will be given (they are always unknown). The first observation is C=0, A=41. The next is C=1, A: unknown. The next is C: unknown, A=7. The last is C=0, A=2. </p>

</div>
</div>
<a class="anchor" id="a811e8c96e61a38505d21aa8a69c9b32e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::learn_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html">plDataDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>data_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>em_iterations</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_em</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Learns the parameters of learnable distributions in the network. </p>
<p>There can be arbitrary missing data in the learning observations. If <em>no_em</em> is set to true (the default is <em>false</em>), only available values are used. Otherwise, EM (Expectation-Maximization) algorithm is used. This EM algorithm is implemented using <a class="el" href="a00061.html" title="This class implements a generic EM (Expectation-Maximization) learning algorithm (using incomplete da...">plEMLearner</a> and is run for <em>em_iterations</em> iterations if a positive value is provided. If <em>em_iterations</em> is not positive (the default value), the algorithm will be run until convergence.</p>
<p>The learning data is made of observations on the network variables, in a data descriptor object (<a class="el" href="a00044.html" title="This abstract template class defines a sequential data container. ">plDataDescriptor</a>) <em>data_set</em>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00044.html" title="This abstract template class defines a sequential data container. ">plDataDescriptor</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a412205d25ecbce40b34ff720bb4c4aa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> plBayesianNetwork::learn_parameters_em </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html">plDataDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>data_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>em_iterations</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>same_missing_variables</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Learns the parameters of learnable distributions in the network. </p>
<p>There can be arbitrary missing data in the learning observations and EM (Expectation-Maximization) algorithm is used. This EM algorithm is implemented using <a class="el" href="a00061.html" title="This class implements a generic EM (Expectation-Maximization) learning algorithm (using incomplete da...">plEMLearner</a> and is run for <em>em_iterations</em> iterations if a positive value is provided. If <em>em_iterations</em> is not positive (the default value), the algorithm will be run until convergence.</p>
<p>The learning data is made of observations on the network variables, in a data descriptor object (<a class="el" href="a00044.html" title="This abstract template class defines a sequential data container. ">plDataDescriptor</a>) <em>data_set</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>The log-likelihood of the learnt model</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00044.html" title="This abstract template class defines a sequential data container. ">plDataDescriptor</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abaafcf82e897edd5ee924133c75ab2fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::learn_parameters_no_em </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html">plDataDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>data_set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Learns the parameters of learnable distributions in the network. </p>
<p>There can be arbitrary missing data in the learning observations. However, only available values are used.</p>
<p>The learning data is made of observations on the network variables, in a data descriptor object (<a class="el" href="a00044.html" title="This abstract template class defines a sequential data container. ">plDataDescriptor</a>) <em>data_set</em>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00044.html" title="This abstract template class defines a sequential data container. ">plDataDescriptor</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0d0560bc96583b027f1a88e105d42816"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> plBayesianNetwork::learn_structure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html">plDataDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_current_structure_as_starting_point</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keep_current_edges</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00160.html#af3353c07f22f33cc74530cf82dafb90c">plStructureLearningScore</a>&#160;</td>
          <td class="paramname"><em>edge_score</em> = <code><a class="el" href="a00160.html#af3353c07f22f33cc74530cf82dafb90cae1afff89ba0469aee4389fb7950fdca9">PL_MI</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00160.html#af3353c07f22f33cc74530cf82dafb90c">plStructureLearningScore</a>&#160;</td>
          <td class="paramname"><em>node_score</em> = <code><a class="el" href="a00160.html#af3353c07f22f33cc74530cf82dafb90ca3139c717e277ac7e3adbe2bd703ebc79">PL_AIC</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00140.html">plSymbol</a> &amp;&#160;</td>
          <td class="paramname"><em>root_node</em> = <code><a class="el" href="a00140.html">plSymbol</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxp</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxpc</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00006.html#a5c826ed379482d64a4fc0bbb44969c64">bn_edge_list_t</a> &amp;&#160;</td>
          <td class="paramname"><em>edges_to_exclude</em> = <code><a class="el" href="a00006.html#a5c826ed379482d64a4fc0bbb44969c64">bn_edge_list_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Learns the structure of the network. </p>
<p>It assumes that the nodes (variables) of the net have been already inserted.</p>
<p>The learning data is made of observations on the network variables, in a data descriptor object (<a class="el" href="a00044.html" title="This abstract template class defines a sequential data container. ">plDataDescriptor</a>) <em>data_set</em>.</p>
<p>For instance, we can build a network with variables A, B, and C : </p>
<div class="fragment"><div class="line"><a class="code" href="a00140.html">plSymbol</a> a(<span class="stringliteral">&quot;A&quot;</span>, <a class="code" href="a00078.html">plIntegerType</a>(0, 42));</div>
<div class="line"><a class="code" href="a00140.html">plSymbol</a> b(<span class="stringliteral">&quot;B&quot;</span>, <a class="code" href="a00078.html">plIntegerType</a>(-2, 2));</div>
<div class="line"><a class="code" href="a00140.html">plSymbol</a> c(<span class="stringliteral">&quot;C&quot;</span>, <a class="code" href="a00078.html">plIntegerType</a>(-1, 1));</div>
<div class="line"><a class="code" href="a00006.html">plBayesianNetwork</a> net;</div>
<div class="line">net.<a class="code" href="a00006.html#a28d5204db586df56de765b701effba43">add_node</a>(a);</div>
<div class="line">net.<a class="code" href="a00006.html#a28d5204db586df56de765b701effba43">add_node</a>(b);</div>
<div class="line">net.<a class="code" href="a00006.html#a28d5204db586df56de765b701effba43">add_node</a>(c);</div>
<div class="line"></div>
<div class="line"><a class="code" href="a00041.html">plCSVDataDescriptor</a> cvs_data(<span class="stringliteral">&quot;data.csv&quot;</span>, a^b^c);</div>
<div class="line">net.<a class="code" href="a00006.html#a0d0560bc96583b027f1a88e105d42816">learn_structure</a>(cvs_data);</div>
<div class="line">std::cout &lt;&lt; net &lt;&lt; std::endl;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>The data source to be used for learning the structure and then the parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_current_structure_as_starting_point</td><td>If 'true', the current structure is used as a starting point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep_current_edges</td><td>If 'true', all the current edges will be kept in the final output structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge_score</td><td>The edge score to be used for the preliminary Directed Minimum Spanning Tree phase. This parameter (and the DMST algorithm) is used only when 'use_current_structure_as_starting_point=false' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">node_score</td><td>The node score to be used for the final Greedy Search phase. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root_node</td><td>The root not if any </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxp</td><td>The maximal number of parents allowed for a given node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxpc</td><td>The cardinality (numbers of discrete states) of parents allowed for a given node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edges_to_exclude</td><td>The edges to mandatory exclude in the final output structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the score (node_score) of the output structure on the provided data</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00044.html" title="This abstract template class defines a sequential data container. ">plDataDescriptor</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a045eafe9974ad5f4a29d475b33865b11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::learn_structure_tree_augmented_naive_bayes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00044.html">plDataDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00140.html">plSymbol</a> &amp;&#160;</td>
          <td class="paramname"><em>class_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00160.html#af3353c07f22f33cc74530cf82dafb90c">plStructureLearningScore</a>&#160;</td>
          <td class="paramname"><em>edge_score</em> = <code><a class="el" href="a00160.html#af3353c07f22f33cc74530cf82dafb90ca3139c717e277ac7e3adbe2bd703ebc79">PL_AIC</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a>&#160;</td>
          <td class="paramname"><em>score_threshold</em> = <code>PL_ZERO</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keep_current_edges</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00006.html#a5c826ed379482d64a4fc0bbb44969c64">bn_edge_list_t</a> &amp;&#160;</td>
          <td class="paramname"><em>edges_to_exclude</em> = <code><a class="el" href="a00006.html#a5c826ed379482d64a4fc0bbb44969c64">bn_edge_list_t</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Learns the structure of the network as a tree augmented naive bayes (TANB) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>The data source to be used for learning the structure and then the parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">class_node</td><td>The class node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge_score</td><td>The edge score to be used for evaluating edges. It will used as conditional regarding the class node for evaluating 'non class -&gt; non class' edges, and non conditional when evaluating 'class -&gt; non class' edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">score_threshold</td><td>The threshold to be used to decide if a given edge is to be added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep_current_edges</td><td>If 'true', all the current edges will be kept in the final output structure. It's the responsibility of the caller to check that the current edges are compatible with a TANB structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edges_to_exclude</td><td>The edges to mandatory exclude in the final output structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d7efe5f890fa4372f3f19d50ab21b4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::next_time_slice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update all the time-slice distributions if the BN is dynamic. </p>
<p>A typical use is as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="a00006.html">plBayesianNetwork</a> bn; </div>
<div class="line"><span class="keyword">const</span> <a class="code" href="a00140.html">plSymbol</a> x(<span class="stringliteral">&quot;X&quot;</span>, <a class="code" href="a00225.html#a229326e7960dd2c88ee6a14cb3fec484">PL_BINARY_TYPE</a>); </div>
<div class="line"><span class="keyword">const</span> <a class="code" href="a00140.html">plSymbol</a> x_(<span class="stringliteral">&quot;X_&quot;</span>, <a class="code" href="a00225.html#a229326e7960dd2c88ee6a14cb3fec484">PL_BINARY_TYPE</a>);</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="a00140.html">plSymbol</a> o(<span class="stringliteral">&quot;O&quot;</span>, <a class="code" href="a00131.html">plRealType</a>(-100000., 100000.));</div>
<div class="line"></div>
<div class="line">bn.<a class="code" href="a00006.html#a28d5204db586df56de765b701effba43">add_node</a>(x);</div>
<div class="line">bn.<a class="code" href="a00006.html#a28d5204db586df56de765b701effba43">add_node</a>(x_);</div>
<div class="line">bn.<a class="code" href="a00006.html#a28d5204db586df56de765b701effba43">add_node</a>(o);</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="a00024.html">plCndDistribution</a> transition( x, x_);</div>
<div class="line"></div>
<div class="line">bn.<a class="code" href="a00006.html#aee05426d13eb89f73cb2f798f96d61f6">set_time_transition_distribution</a>( transition );</div>
<div class="line"></div>
<div class="line"><span class="comment">// Dynamic BN joint distribution: P( X X_ O) = P(X_) P(X | X_) P(O | X)</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="a00147.html">plValues</a> observation(o);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 5; ++i) {</div>
<div class="line">  observation[o] = -10. + <a class="code" href="a00130.html#afe3f5fcba2152c699f69f56eb99b9197">plRandom::uniform_float</a>(10.);</div>
<div class="line">  bn.<a class="code" href="a00006.html#ac6e33c56ff1576b5927e6aaa12577db0">set_evidence</a>(observation);</div>
<div class="line">  std::cout &lt;&lt; bn &lt;&lt; std::endl;</div>
<div class="line">  bn.<a class="code" href="a00006.html#a2d7efe5f890fa4372f3f19d50ab21b4e">next_time_slice</a>();</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a0df55f9b152a56a6fd59efb6bd686ce1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00147.html">plValues</a> plBayesianNetwork::prediction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>target_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00147.html">plValues</a> &amp;&#160;</td>
          <td class="paramname"><em>evidence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value of <em>target_variables</em> that maximises the probabilit given the evidence <em>evidence</em> P(target_variables | evidence). </p>
<p>Equivalent to: </p>
<div class="fragment"><div class="line"><a class="code" href="a00006.html">plBayesianNetwork</a> net(...);</div>
<div class="line">.</div>
<div class="line">.</div>
<div class="line">.</div>
<div class="line">net.set_evidence(evidence.remove(target_variables));</div>
<div class="line"><a class="code" href="a00147.html">plValues</a> result = net.<a class="code" href="a00006.html#abe747c946eb5995250d53363d4dcaddb">get_belief</a>(target_variables).<a class="code" href="a00049.html#a591d01929c78933fa75f1d244e7cebb9">best</a>();</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a00cb00941b7acfbdde29d8e410518fe7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::sample </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nsamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>missing_probabilities</em> = <code>std::vector&lt;&#160;<a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate <em>nsamples</em> data in a CSV output file <em>file</em> according to the model defined by the net. </p>
<p>Simulating missing values is possible by providing the missing probability for each variable in the vector <em>missing_probabilities</em>.</p>
<p>The generated CSV file will be structured as follows:</p>
<ul>
<li>its first line (the header) gives the names of the variables (nodes)</li>
<li>each of the following lines gives the values of the variables for a given data instance</li>
<li>a value can be left empty to signify that it is missing. </li>
</ul>

</div>
</div>
<a class="anchor" id="a9f5a707ef30b1944d44e466183262443"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::set_compiled_belief_distribution </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compile_it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If set to 'true' (the default value), the distributions returned by <a class="el" href="a00006.html#abe747c946eb5995250d53363d4dcaddb" title="Returns the belief associated to a given node, knowing the currently inserted evidence. ">get_belief()</a> are compiled. </p>
<p>Set it to 'false' if you do not need compiled distributions </p>

</div>
</div>
<a class="anchor" id="aa25c077d94f5b2d08f953cec933241ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::set_distribution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00036.html">plComputableObject</a> &amp;&#160;</td>
          <td class="paramname"><em>distribution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the distribution associated to a given node. </p>
<p>The distribution itself specifies the network link:</p>
<ul>
<li>its left variable is the node to which the distribution is attached</li>
<li>its right variables are the parent nodes.</li>
</ul>
<p>If the distribution is non-conditional (in ProBT terminology, a <a class="el" href="a00049.html" title="The plDistribution class is the base class of all non-conditional probability (and density) distribut...">plDistribution</a>), this also establishes the fact that the node has no parents.</p>
<p>For instance, </p>
<div class="fragment"><div class="line">net.<a class="code" href="a00006.html#aa25c077d94f5b2d08f953cec933241ef">set_distribution</a>(<a class="code" href="a00144.html">plUniform</a>(a));</div>
</div><!-- fragment --><p> specifies that node <em>a</em> has no parents, and that the prior distribution on <em>a</em> is a uniform one.</p>
<p>If the distribution is conditional (a <a class="el" href="a00024.html" title="plCndDistribution is the base class of all conditional probability (and density) distributions like P...">plCndDistribution</a>), its right variables become the parents of the node.</p>
<p>For instance, </p>
<div class="fragment"><div class="line">net.<a class="code" href="a00006.html#aa25c077d94f5b2d08f953cec933241ef">set_distribution</a>(<a class="code" href="a00030.html">plCndNormal</a>(b, a, 1));</div>
</div><!-- fragment --><p> specifies that node <em>b</em> has <em>a</em> for only parent, and that its associated conditional probability distribution is a Normal (Gaussian) centered on the value of <em>a</em>, and of constant standard deviation equal to one. </p>

</div>
</div>
<a class="anchor" id="aa90eeca551c3c5628380936269ded918"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::set_distribution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00103.html">plLearnObject</a> &amp;&#160;</td>
          <td class="paramname"><em>learnable_distribution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the distribution associated to a given node to be a learnable distribution. </p>
<p>You may learn all learnable distributions of a network using <a class="el" href="a00006.html#a7c01d2f5864e916bee74c1b552415507" title="Learns the parameters of learnable distributions in the network. ">learn_parameters()</a>. Within the same network, you may freely mix learnable and non-learnable distributions.</p>
<p>For instance: </p>
<div class="fragment"><div class="line"><a class="code" href="a00140.html">plSymbol</a> a(<span class="stringliteral">&quot;A&quot;</span>, <a class="code" href="a00078.html">plIntegerType</a>(0, 42));</div>
<div class="line"><a class="code" href="a00140.html">plSymbol</a> b(<span class="stringliteral">&quot;B&quot;</span>, <a class="code" href="a00078.html">plIntegerType</a>(-2, 2));</div>
<div class="line"><a class="code" href="a00140.html">plSymbol</a> c(<span class="stringliteral">&quot;C&quot;</span>, <a class="code" href="a00078.html">plIntegerType</a>(-1, 1));</div>
<div class="line"><a class="code" href="a00006.html">plBayesianNetwork</a> net;</div>
<div class="line">net.<a class="code" href="a00006.html#a28d5204db586df56de765b701effba43">add_node</a>(a);</div>
<div class="line">net.<a class="code" href="a00006.html#a28d5204db586df56de765b701effba43">add_node</a>(b);</div>
<div class="line">net.<a class="code" href="a00006.html#a28d5204db586df56de765b701effba43">add_node</a>(c);</div>
<div class="line"><a class="code" href="a00095.html">plLearnLaplace</a> learn_a(a);</div>
<div class="line">net.<a class="code" href="a00006.html#aa25c077d94f5b2d08f953cec933241ef">set_distribution</a>(learn_a);</div>
<div class="line"><a class="code" href="a00028.html">plCndLearnObject&lt;plLearnNormal&gt;</a> learn_b_k_a(b, a);</div>
<div class="line">net.<a class="code" href="a00006.html#aa25c077d94f5b2d08f953cec933241ef">set_distribution</a>(learn_b_k_a);</div>
<div class="line"><a class="code" href="a00028.html">plCndLearnObject&lt;plLearnNormal&gt;</a> learn_c_k_b(c, b);</div>
<div class="line">net.<a class="code" href="a00006.html#aa25c077d94f5b2d08f953cec933241ef">set_distribution</a>(learn_c_k_b);</div>
<div class="line">net.<a class="code" href="a00006.html#a7c01d2f5864e916bee74c1b552415507">learn_parameters</a>(<span class="stringliteral">&quot;data.csv&quot;</span>);</div>
<div class="line">std::cout &lt;&lt; net &lt;&lt; std::endl;</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ac6e33c56ff1576b5927e6aaa12577db0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::set_evidence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00147.html">plValues</a> &amp;&#160;</td>
          <td class="paramname"><em>evidence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_validity</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the evidence in the network. </p>
<p>This replaces previously existing evidence. Evidence is contained in a <a class="el" href="a00147.html" title="A plValues is an object storing the values of a set of variables. ">plValues</a> object. For instance, to insert evidence over nodes <em>a</em> and <em>c</em>, that a = 2 and c = 42: </p>
<div class="fragment"><div class="line"><a class="code" href="a00147.html">plValues</a> evidence(a ^ c);</div>
<div class="line">evidence[a] = 2;</div>
<div class="line">evidence[c] = 42;</div>
<div class="line">net.<a class="code" href="a00006.html#ac6e33c56ff1576b5927e6aaa12577db0">set_evidence</a>(evidence);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a6b4759d3791c84f97eaa9d81e6c5872d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::set_inference_algorithm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00160.html#ac22bfeef2ef8c3e3a219937530b8edee">plInferenceAlgorithm</a>&#160;</td>
          <td class="paramname"><em>algo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the inference algorithm to be used. </p>
<p>Possible values are <em>PL_JT</em> for the "Junction Tree" algorithm and <em>PL_SR</em> for the "Successive Restrictions" algorithm (a kind of variable elimination). The initial value is <em>PL_SR</em>. </p>

</div>
</div>
<a class="anchor" id="aebad96655011a9e11ec6f055f13cbde5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::set_query_cache_max_size </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum number of the cached target distributions. </p>
<p>The default value is 10. </p>

</div>
</div>
<a class="anchor" id="aee05426d13eb89f73cb2f798f96d61f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::set_time_transition_distribution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00024.html">plCndDistribution</a> &amp;&#160;</td>
          <td class="paramname"><em>transition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a time-transition edge. </p>
<p>For example, to set a time-transition distribution </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ P(X_{t} | X_{t-1} ) \]" src="form_22.png"/>
</p>
<p>, one can write:</p>
<div class="fragment"><div class="line"><a class="code" href="a00006.html">plBayesianNetwork</a> bn; </div>
<div class="line"><span class="keyword">const</span> <a class="code" href="a00140.html">plSymbol</a> x(<span class="stringliteral">&quot;X&quot;</span>, <a class="code" href="a00225.html#a229326e7960dd2c88ee6a14cb3fec484">PL_BINARY_TYPE</a>); </div>
<div class="line"><span class="keyword">const</span> <a class="code" href="a00140.html">plSymbol</a> x_(<span class="stringliteral">&quot;X_&quot;</span>, <a class="code" href="a00225.html#a229326e7960dd2c88ee6a14cb3fec484">PL_BINARY_TYPE</a>);</div>
<div class="line"></div>
<div class="line">bn.<a class="code" href="a00006.html#a28d5204db586df56de765b701effba43">add_node</a>(x);</div>
<div class="line">bn.<a class="code" href="a00006.html#a28d5204db586df56de765b701effba43">add_node</a>(x_);</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="a00024.html">plCndDistribution</a> transition( x, x_);</div>
<div class="line"></div>
<div class="line">bn.<a class="code" href="a00006.html#aee05426d13eb89f73cb2f798f96d61f6">set_time_transition_distribution</a>( transition );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a72614b2ed61f98f106ee9415b2845429"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::set_time_transition_learnable_distribution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00103.html">plLearnObject</a> &amp;&#160;</td>
          <td class="paramname"><em>learnable_transition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a time-transition learnable distribution. </p>
<p>For example, to set a learnable time transition distribution </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ P(X_{t} | X_{t-1} ) \]" src="form_22.png"/>
</p>
<p>, one can write:</p>
<div class="fragment"><div class="line"><a class="code" href="a00006.html">plBayesianNetwork</a> bn; </div>
<div class="line"><span class="keyword">const</span> <a class="code" href="a00140.html">plSymbol</a> x(<span class="stringliteral">&quot;X&quot;</span>, <a class="code" href="a00225.html#a229326e7960dd2c88ee6a14cb3fec484">PL_BINARY_TYPE</a>); </div>
<div class="line"><span class="keyword">const</span> <a class="code" href="a00140.html">plSymbol</a> x_(<span class="stringliteral">&quot;X_&quot;</span>, <a class="code" href="a00225.html#a229326e7960dd2c88ee6a14cb3fec484">PL_BINARY_TYPE</a>);</div>
<div class="line"></div>
<div class="line">bn.<a class="code" href="a00006.html#a28d5204db586df56de765b701effba43">add_node</a>(x);</div>
<div class="line">bn.<a class="code" href="a00006.html#a28d5204db586df56de765b701effba43">add_node</a>(x_);</div>
<div class="line"></div>
<div class="line"><a class="code" href="a00028.html">plCndLearnObject&lt;plLearnHistogram&gt;</a> learnable_transition( x, x_);</div>
<div class="line"></div>
<div class="line">bn.<a class="code" href="a00006.html#a72614b2ed61f98f106ee9415b2845429">set_time_transition_learnable_distribution</a>( learnable_transition );</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ad2d946108e5cccbf8ea799c3a63afd5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::set_verbose_em_learning </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set/unset verbose mode for parameter learning using EM. </p>
<p>If true, the parameter learning algorithm will display intermediate results </p>

</div>
</div>
<a class="anchor" id="a62fee1c4e70b7ac4c5da93c792da62dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plBayesianNetwork::set_verbose_structure_learning </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set/unset verbose mode for structure learning. </p>
<p>If true, the structure learning algorithms will display intermediate results </p>

</div>
</div>
<a class="anchor" id="a79eb712479af21542c628bfa9b788d60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> plBayesianNetwork::validate_prediction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>target_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html">plDataDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>output_probability_table</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nrows</em> = <code>std::numeric_limits&lt;&#160;unsigned&#160;int&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask a query to the model, apply it to a data set, and provide validation statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target_variables</td><td>The target variables to predict </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The input data set to be used for validation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_file</td><td>The output file. It will include the columns (variables) of the input data set with additional columns corresponding the predicted target variables and the corresponding distribution table if 'output_probability_table=true' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_probability_table</td><td>If 'true', the probability table corresponding to the prediction will be added to the output file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows</td><td>The number of rows to be used for this validation (starting from the current position in the input data source)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>recognition percentage (sum of diagonal elements of the confusion matrix divided by the sum of all elements of the matrix) </dd></dl>

</div>
</div>
<a class="anchor" id="a1d69eb6f6f50ea545f91c4cb6905b071"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> plBayesianNetwork::validate_prediction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>target_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html">plDataDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>hard_confusion_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>output_probability_table</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nrows</em> = <code>std::numeric_limits&lt;&#160;unsigned&#160;int&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask a query to the model, apply it to a data set, and provide validation statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target_variables</td><td>The target variables to predict </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The input data set to be used for validation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_file</td><td>The output file. It will include the columns (variables) of the input data set with additional columns corresponding the predicted target variables and the corresponding distribution table if 'output_probability_table=true' </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hard_confusion_matrix</td><td>The output confusion matrix computed using the most probable predicted value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_probability_table</td><td>If 'true', the probability table corresponding to the prediction will be added to the output file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows</td><td>The number of rows to be used for this validation (starting from the current position in the input data source)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>recognition percentage (sum of diagonal elements of the confusion matrix divided by the sum of all elements of the matrix) </dd></dl>

</div>
</div>
<a class="anchor" id="af4c47fd826608bafee3ece4891ed19cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00255.html#a562a54911ed90df1b05235f6924f43c1">plFloat</a> plBayesianNetwork::validate_prediction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">plVariablesConjunction</a> &amp;&#160;</td>
          <td class="paramname"><em>target_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00044.html">plDataDescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>hard_confusion_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a00255.html#a2e68e988ec890a2b6fcb080cf1306403">plProbValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>soft_confusion_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>output_probability_table</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nrows</em> = <code>std::numeric_limits&lt;&#160;unsigned&#160;int&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask a query to the model, apply it to a data set, and provide validation statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target_variables</td><td>The target variables to predict </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The input data set to be used for validation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_file</td><td>The output file. It will include the columns (variables) of the input data set with additional columns corresponding the predicted target variables and the corresponding distribution table if 'output_probability_table=true' </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hard_confusion_matrix</td><td>The output confusion matrix computed using the most probable predicted value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">soft_confusion_matrix</td><td>The output confusion matrix computed using the the probability table corresonding to the predicted variable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">output_probability_table</td><td>If 'true', the probability table corresponding to the prediction will be added to the output file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrows</td><td>The number of rows to be used for this validation (starting from the current position in the input data source)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>recognition percentage (sum of diagonal elements of the confusion matrix divided by the sum of all elements of the matrix) </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jan 31 2015 01:13:26 for ProBT by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
