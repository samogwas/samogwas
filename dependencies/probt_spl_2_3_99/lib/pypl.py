# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pypl', [dirname(__file__)])
        except ImportError:
            import _pypl
            return _pypl
        if fp is not None:
            try:
                _mod = imp.load_module('_pypl', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pypl = swig_import_helper()
    del swig_import_helper
else:
    import _pypl
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


PL_ENABLE_SPL = _pypl.PL_ENABLE_SPL
PL_HAVE_TCC = _pypl.PL_HAVE_TCC
PL_ENABLE_SL = _pypl.PL_ENABLE_SL
PL_DOUBLE_PRECISION = _pypl.PL_DOUBLE_PRECISION
PL_USE_VISIBILITY = _pypl.PL_USE_VISIBILITY
PL_ENABLE_CONVERTER = _pypl.PL_ENABLE_CONVERTER
class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self):
        """value(SwigPyIterator self) -> PyObject *"""
        return _pypl.SwigPyIterator_value(self)

    def incr(self, n=1):
        """
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        incr(SwigPyIterator self) -> SwigPyIterator
        """
        return _pypl.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        """
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
        decr(SwigPyIterator self) -> SwigPyIterator
        """
        return _pypl.SwigPyIterator_decr(self, n)

    def distance(self, *args):
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _pypl.SwigPyIterator_distance(self, *args)

    def equal(self, *args):
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _pypl.SwigPyIterator_equal(self, *args)

    def copy(self):
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _pypl.SwigPyIterator_copy(self)

    def next(self):
        """next(SwigPyIterator self) -> PyObject *"""
        return _pypl.SwigPyIterator_next(self)

    def __next__(self):
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _pypl.SwigPyIterator___next__(self)

    def previous(self):
        """previous(SwigPyIterator self) -> PyObject *"""
        return _pypl.SwigPyIterator_previous(self)

    def advance(self, *args):
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _pypl.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args):
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _pypl.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _pypl.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _pypl.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _pypl.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args):
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _pypl.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _pypl.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _pypl.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

PROBT_MAJOR = _pypl.PROBT_MAJOR
PROBT_MINOR = _pypl.PROBT_MINOR
PROBT_REVISION = _pypl.PROBT_REVISION
PROBT_VERSION = _pypl.PROBT_VERSION
class plVersion(_object):
    """Proxy of C++ plVersion class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plVersion, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plVersion, name)
    __repr__ = _swig_repr
    __swig_setmethods__["major_"] = _pypl.plVersion_major__set
    __swig_getmethods__["major_"] = _pypl.plVersion_major__get
    if _newclass:major_ = _swig_property(_pypl.plVersion_major__get, _pypl.plVersion_major__set)
    __swig_setmethods__["minor_"] = _pypl.plVersion_minor__set
    __swig_getmethods__["minor_"] = _pypl.plVersion_minor__get
    if _newclass:minor_ = _swig_property(_pypl.plVersion_minor__get, _pypl.plVersion_minor__set)
    __swig_setmethods__["revision_"] = _pypl.plVersion_revision__set
    __swig_getmethods__["revision_"] = _pypl.plVersion_revision__get
    if _newclass:revision_ = _swig_property(_pypl.plVersion_revision__get, _pypl.plVersion_revision__set)
    __swig_setmethods__["s11n_compat_"] = _pypl.plVersion_s11n_compat__set
    __swig_getmethods__["s11n_compat_"] = _pypl.plVersion_s11n_compat__get
    if _newclass:s11n_compat_ = _swig_property(_pypl.plVersion_s11n_compat__get, _pypl.plVersion_s11n_compat__set)
    def __init__(self, *args): 
        """
        __init__(plVersion self) -> plVersion
        __init__(plVersion self, unsigned int maj, unsigned int min, unsigned int rev, unsigned int compat=0) -> plVersion
        __init__(plVersion self, unsigned int maj, unsigned int min, unsigned int rev) -> plVersion
        __init__(plVersion self, std::string const & version_string) -> plVersion
        """
        this = _pypl.new_plVersion(*args)
        try: self.this.append(this)
        except: self.this = this
    def _print(self):
        """_print(plVersion self) -> std::string"""
        return _pypl.plVersion__print(self)

    def __lt__(self, *args):
        """__lt__(plVersion self, plVersion o) -> bool"""
        return _pypl.plVersion___lt__(self, *args)

    def less(self, *args):
        """less(plVersion self, plVersion o) -> bool"""
        return _pypl.plVersion_less(self, *args)

    def get_version():
        """get_version() -> plVersion"""
        return _pypl.plVersion_get_version()

    if _newclass:get_version = staticmethod(get_version)
    __swig_getmethods__["get_version"] = lambda x: get_version
    def get_expiration_date():
        """get_expiration_date() -> std::string"""
        return _pypl.plVersion_get_expiration_date()

    if _newclass:get_expiration_date = staticmethod(get_expiration_date)
    __swig_getmethods__["get_expiration_date"] = lambda x: get_expiration_date
    def has_expired():
        """has_expired() -> bool"""
        return _pypl.plVersion_has_expired()

    if _newclass:has_expired = staticmethod(has_expired)
    __swig_getmethods__["has_expired"] = lambda x: has_expired
    __swig_destroy__ = _pypl.delete_plVersion
    __del__ = lambda self : None;
plVersion_swigregister = _pypl.plVersion_swigregister
plVersion_swigregister(plVersion)

def plVersion_get_version():
  """plVersion_get_version() -> plVersion"""
  return _pypl.plVersion_get_version()

def plVersion_get_expiration_date():
  """plVersion_get_expiration_date() -> std::string"""
  return _pypl.plVersion_get_expiration_date()

def plVersion_has_expired():
  """plVersion_has_expired() -> bool"""
  return _pypl.plVersion_has_expired()

PL_LOG_OF_2 = _pypl.PL_LOG_OF_2
PL_PI_2 = _pypl.PL_PI_2
PL_PI = _pypl.PL_PI
PL_2PI = _pypl.PL_2PI
PL_INV_SQRT_2PI = _pypl.PL_INV_SQRT_2PI
PL_SQRT_PI = _pypl.PL_SQRT_PI
PL_LOG_ROOT_2_PI = _pypl.PL_LOG_ROOT_2_PI
PL_ZERO = _pypl.PL_ZERO
PL_HALF = _pypl.PL_HALF
PL_ONE = _pypl.PL_ONE
PL_TWO = _pypl.PL_TWO
PL_SQRT_2 = _pypl.PL_SQRT_2
PL_E = _pypl.PL_E
PL_MIN_EXP = _pypl.PL_MIN_EXP
PL_LOG_OF_10_BASE2 = _pypl.PL_LOG_OF_10_BASE2
PL_MINUS_ONE = _pypl.PL_MINUS_ONE
PL_LOG_SQRT_2PI = _pypl.PL_LOG_SQRT_2PI

def plLogBase2(*args):
  """plLogBase2(plFloat v) -> plFloat"""
  return _pypl.plLogBase2(*args)

def plNbBits(*args):
  """plNbBits(int int_val) -> int"""
  return _pypl.plNbBits(*args)

def plRound(*args):
  """plRound(plFloat x) -> int"""
  return _pypl.plRound(*args)

def plFabs(*args):
  """plFabs(plFloat x) -> plFloat"""
  return _pypl.plFabs(*args)
PL_ZERO_PROB = _pypl.PL_ZERO_PROB
PL_HALF_PROB = _pypl.PL_HALF_PROB
PL_ONE_PROB = _pypl.PL_ONE_PROB
PL_TWO_PROB = _pypl.PL_TWO_PROB
PL_INVALID_PROB = _pypl.PL_INVALID_PROB
PL_DISTRIB_TRUNCATION_THRESHOLD = _pypl.PL_DISTRIB_TRUNCATION_THRESHOLD
class plPairVPV(_object):
    """Proxy of C++ std::pair<(plValues,plProbValue)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plPairVPV, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plPairVPV, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(std::pair<(plValues,plProbValue)> self) -> plPairVPV
        __init__(std::pair<(plValues,plProbValue)> self, plValues first, double second) -> plPairVPV
        __init__(std::pair<(plValues,plProbValue)> self, plPairVPV p) -> plPairVPV
        """
        this = _pypl.new_plPairVPV(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["first"] = _pypl.plPairVPV_first_set
    __swig_getmethods__["first"] = _pypl.plPairVPV_first_get
    if _newclass:first = _swig_property(_pypl.plPairVPV_first_get, _pypl.plPairVPV_first_set)
    __swig_setmethods__["second"] = _pypl.plPairVPV_second_set
    __swig_getmethods__["second"] = _pypl.plPairVPV_second_get
    if _newclass:second = _swig_property(_pypl.plPairVPV_second_get, _pypl.plPairVPV_second_set)
    def __len__(self): return 2
    def __repr__(self): return str((self.first, self.second))
    def __getitem__(self, index): 
      if not (index % 2): 
        return self.first
      else:
        return self.second
    def __setitem__(self, index, val):
      if not (index % 2): 
        self.first = val
      else:
        self.second = val
    __swig_destroy__ = _pypl.delete_plPairVPV
    __del__ = lambda self : None;
plPairVPV_swigregister = _pypl.plPairVPV_swigregister
plPairVPV_swigregister(plPairVPV)
cvar = _pypl.cvar
PL_NUMBER_OF_BITS_BY_CHAR = cvar.PL_NUMBER_OF_BITS_BY_CHAR

class IntVector(_object):
    """Proxy of C++ std::vector<(int)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(IntVector self) -> SwigPyIterator"""
        return _pypl.IntVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(IntVector self) -> bool"""
        return _pypl.IntVector___nonzero__(self)

    def __bool__(self):
        """__bool__(IntVector self) -> bool"""
        return _pypl.IntVector___bool__(self)

    def __len__(self):
        """__len__(IntVector self) -> std::vector< int >::size_type"""
        return _pypl.IntVector___len__(self)

    def pop(self):
        """pop(IntVector self) -> std::vector< int >::value_type"""
        return _pypl.IntVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(IntVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j) -> IntVector"""
        return _pypl.IntVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(IntVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j, IntVector v=std::vector< int,std::allocator< int > >())
        __setslice__(IntVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)
        """
        return _pypl.IntVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(IntVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)"""
        return _pypl.IntVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(IntVector self, std::vector< int >::difference_type i)
        __delitem__(IntVector self, PySliceObject * slice)
        """
        return _pypl.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(IntVector self, PySliceObject * slice) -> IntVector
        __getitem__(IntVector self, std::vector< int >::difference_type i) -> std::vector< int >::value_type const &
        """
        return _pypl.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(IntVector self, PySliceObject * slice, IntVector v)
        __setitem__(IntVector self, PySliceObject * slice)
        __setitem__(IntVector self, std::vector< int >::difference_type i, std::vector< int >::value_type const & x)
        """
        return _pypl.IntVector___setitem__(self, *args)

    def append(self, *args):
        """append(IntVector self, std::vector< int >::value_type const & x)"""
        return _pypl.IntVector_append(self, *args)

    def empty(self):
        """empty(IntVector self) -> bool"""
        return _pypl.IntVector_empty(self)

    def size(self):
        """size(IntVector self) -> std::vector< int >::size_type"""
        return _pypl.IntVector_size(self)

    def clear(self):
        """clear(IntVector self)"""
        return _pypl.IntVector_clear(self)

    def swap(self, *args):
        """swap(IntVector self, IntVector v)"""
        return _pypl.IntVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(IntVector self) -> std::vector< int >::allocator_type"""
        return _pypl.IntVector_get_allocator(self)

    def begin(self):
        """begin(IntVector self) -> std::vector< int >::iterator"""
        return _pypl.IntVector_begin(self)

    def end(self):
        """end(IntVector self) -> std::vector< int >::iterator"""
        return _pypl.IntVector_end(self)

    def rbegin(self):
        """rbegin(IntVector self) -> std::vector< int >::reverse_iterator"""
        return _pypl.IntVector_rbegin(self)

    def rend(self):
        """rend(IntVector self) -> std::vector< int >::reverse_iterator"""
        return _pypl.IntVector_rend(self)

    def pop_back(self):
        """pop_back(IntVector self)"""
        return _pypl.IntVector_pop_back(self)

    def erase(self, *args):
        """
        erase(IntVector self, std::vector< int >::iterator pos) -> std::vector< int >::iterator
        erase(IntVector self, std::vector< int >::iterator first, std::vector< int >::iterator last) -> std::vector< int >::iterator
        """
        return _pypl.IntVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(int)> self) -> IntVector
        __init__(std::vector<(int)> self, IntVector arg2) -> IntVector
        __init__(std::vector<(int)> self, std::vector< int >::size_type size) -> IntVector
        __init__(std::vector<(int)> self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> IntVector
        """
        this = _pypl.new_IntVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(IntVector self, std::vector< int >::value_type const & x)"""
        return _pypl.IntVector_push_back(self, *args)

    def front(self):
        """front(IntVector self) -> std::vector< int >::value_type const &"""
        return _pypl.IntVector_front(self)

    def back(self):
        """back(IntVector self) -> std::vector< int >::value_type const &"""
        return _pypl.IntVector_back(self)

    def assign(self, *args):
        """assign(IntVector self, std::vector< int >::size_type n, std::vector< int >::value_type const & x)"""
        return _pypl.IntVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(IntVector self, std::vector< int >::size_type new_size)
        resize(IntVector self, std::vector< int >::size_type new_size, std::vector< int >::value_type const & x)
        """
        return _pypl.IntVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(IntVector self, std::vector< int >::iterator pos, std::vector< int >::value_type const & x) -> std::vector< int >::iterator
        insert(IntVector self, std::vector< int >::iterator pos, std::vector< int >::size_type n, std::vector< int >::value_type const & x)
        """
        return _pypl.IntVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(IntVector self, std::vector< int >::size_type n)"""
        return _pypl.IntVector_reserve(self, *args)

    def capacity(self):
        """capacity(IntVector self) -> std::vector< int >::size_type"""
        return _pypl.IntVector_capacity(self)

    __swig_destroy__ = _pypl.delete_IntVector
    __del__ = lambda self : None;
IntVector_swigregister = _pypl.IntVector_swigregister
IntVector_swigregister(IntVector)

class UnsignedIntVector(_object):
    """Proxy of C++ std::vector<(unsigned int)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UnsignedIntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UnsignedIntVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(UnsignedIntVector self) -> SwigPyIterator"""
        return _pypl.UnsignedIntVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(UnsignedIntVector self) -> bool"""
        return _pypl.UnsignedIntVector___nonzero__(self)

    def __bool__(self):
        """__bool__(UnsignedIntVector self) -> bool"""
        return _pypl.UnsignedIntVector___bool__(self)

    def __len__(self):
        """__len__(UnsignedIntVector self) -> std::vector< unsigned int >::size_type"""
        return _pypl.UnsignedIntVector___len__(self)

    def pop(self):
        """pop(UnsignedIntVector self) -> std::vector< unsigned int >::value_type"""
        return _pypl.UnsignedIntVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(UnsignedIntVector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j) -> UnsignedIntVector"""
        return _pypl.UnsignedIntVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(UnsignedIntVector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j, 
            UnsignedIntVector v=std::vector< unsigned int,std::allocator< unsigned int > >())
        __setslice__(UnsignedIntVector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)
        """
        return _pypl.UnsignedIntVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(UnsignedIntVector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)"""
        return _pypl.UnsignedIntVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(UnsignedIntVector self, std::vector< unsigned int >::difference_type i)
        __delitem__(UnsignedIntVector self, PySliceObject * slice)
        """
        return _pypl.UnsignedIntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(UnsignedIntVector self, PySliceObject * slice) -> UnsignedIntVector
        __getitem__(UnsignedIntVector self, std::vector< unsigned int >::difference_type i) -> std::vector< unsigned int >::value_type const &
        """
        return _pypl.UnsignedIntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(UnsignedIntVector self, PySliceObject * slice, UnsignedIntVector v)
        __setitem__(UnsignedIntVector self, PySliceObject * slice)
        __setitem__(UnsignedIntVector self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::value_type const & x)
        """
        return _pypl.UnsignedIntVector___setitem__(self, *args)

    def append(self, *args):
        """append(UnsignedIntVector self, std::vector< unsigned int >::value_type const & x)"""
        return _pypl.UnsignedIntVector_append(self, *args)

    def empty(self):
        """empty(UnsignedIntVector self) -> bool"""
        return _pypl.UnsignedIntVector_empty(self)

    def size(self):
        """size(UnsignedIntVector self) -> std::vector< unsigned int >::size_type"""
        return _pypl.UnsignedIntVector_size(self)

    def clear(self):
        """clear(UnsignedIntVector self)"""
        return _pypl.UnsignedIntVector_clear(self)

    def swap(self, *args):
        """swap(UnsignedIntVector self, UnsignedIntVector v)"""
        return _pypl.UnsignedIntVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(UnsignedIntVector self) -> std::vector< unsigned int >::allocator_type"""
        return _pypl.UnsignedIntVector_get_allocator(self)

    def begin(self):
        """begin(UnsignedIntVector self) -> std::vector< unsigned int >::iterator"""
        return _pypl.UnsignedIntVector_begin(self)

    def end(self):
        """end(UnsignedIntVector self) -> std::vector< unsigned int >::iterator"""
        return _pypl.UnsignedIntVector_end(self)

    def rbegin(self):
        """rbegin(UnsignedIntVector self) -> std::vector< unsigned int >::reverse_iterator"""
        return _pypl.UnsignedIntVector_rbegin(self)

    def rend(self):
        """rend(UnsignedIntVector self) -> std::vector< unsigned int >::reverse_iterator"""
        return _pypl.UnsignedIntVector_rend(self)

    def pop_back(self):
        """pop_back(UnsignedIntVector self)"""
        return _pypl.UnsignedIntVector_pop_back(self)

    def erase(self, *args):
        """
        erase(UnsignedIntVector self, std::vector< unsigned int >::iterator pos) -> std::vector< unsigned int >::iterator
        erase(UnsignedIntVector self, std::vector< unsigned int >::iterator first, std::vector< unsigned int >::iterator last) -> std::vector< unsigned int >::iterator
        """
        return _pypl.UnsignedIntVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(unsigned int)> self) -> UnsignedIntVector
        __init__(std::vector<(unsigned int)> self, UnsignedIntVector arg2) -> UnsignedIntVector
        __init__(std::vector<(unsigned int)> self, std::vector< unsigned int >::size_type size) -> UnsignedIntVector
        __init__(std::vector<(unsigned int)> self, std::vector< unsigned int >::size_type size, std::vector< unsigned int >::value_type const & value) -> UnsignedIntVector
        """
        this = _pypl.new_UnsignedIntVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(UnsignedIntVector self, std::vector< unsigned int >::value_type const & x)"""
        return _pypl.UnsignedIntVector_push_back(self, *args)

    def front(self):
        """front(UnsignedIntVector self) -> std::vector< unsigned int >::value_type const &"""
        return _pypl.UnsignedIntVector_front(self)

    def back(self):
        """back(UnsignedIntVector self) -> std::vector< unsigned int >::value_type const &"""
        return _pypl.UnsignedIntVector_back(self)

    def assign(self, *args):
        """assign(UnsignedIntVector self, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)"""
        return _pypl.UnsignedIntVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(UnsignedIntVector self, std::vector< unsigned int >::size_type new_size)
        resize(UnsignedIntVector self, std::vector< unsigned int >::size_type new_size, std::vector< unsigned int >::value_type const & x)
        """
        return _pypl.UnsignedIntVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(UnsignedIntVector self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::value_type const & x) -> std::vector< unsigned int >::iterator
        insert(UnsignedIntVector self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::size_type n, 
            std::vector< unsigned int >::value_type const & x)
        """
        return _pypl.UnsignedIntVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(UnsignedIntVector self, std::vector< unsigned int >::size_type n)"""
        return _pypl.UnsignedIntVector_reserve(self, *args)

    def capacity(self):
        """capacity(UnsignedIntVector self) -> std::vector< unsigned int >::size_type"""
        return _pypl.UnsignedIntVector_capacity(self)

    __swig_destroy__ = _pypl.delete_UnsignedIntVector
    __del__ = lambda self : None;
UnsignedIntVector_swigregister = _pypl.UnsignedIntVector_swigregister
UnsignedIntVector_swigregister(UnsignedIntVector)

class StringVector(_object):
    """Proxy of C++ std::vector<(std::string)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(StringVector self) -> SwigPyIterator"""
        return _pypl.StringVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(StringVector self) -> bool"""
        return _pypl.StringVector___nonzero__(self)

    def __bool__(self):
        """__bool__(StringVector self) -> bool"""
        return _pypl.StringVector___bool__(self)

    def __len__(self):
        """__len__(StringVector self) -> std::vector< std::string >::size_type"""
        return _pypl.StringVector___len__(self)

    def pop(self):
        """pop(StringVector self) -> std::vector< std::string >::value_type"""
        return _pypl.StringVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(StringVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> StringVector"""
        return _pypl.StringVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(StringVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, 
            StringVector v=std::vector< std::string,std::allocator< std::string > >())
        __setslice__(StringVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        """
        return _pypl.StringVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(StringVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _pypl.StringVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(StringVector self, std::vector< std::string >::difference_type i)
        __delitem__(StringVector self, PySliceObject * slice)
        """
        return _pypl.StringVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(StringVector self, PySliceObject * slice) -> StringVector
        __getitem__(StringVector self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _pypl.StringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(StringVector self, PySliceObject * slice, StringVector v)
        __setitem__(StringVector self, PySliceObject * slice)
        __setitem__(StringVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _pypl.StringVector___setitem__(self, *args)

    def append(self, *args):
        """append(StringVector self, std::vector< std::string >::value_type const & x)"""
        return _pypl.StringVector_append(self, *args)

    def empty(self):
        """empty(StringVector self) -> bool"""
        return _pypl.StringVector_empty(self)

    def size(self):
        """size(StringVector self) -> std::vector< std::string >::size_type"""
        return _pypl.StringVector_size(self)

    def clear(self):
        """clear(StringVector self)"""
        return _pypl.StringVector_clear(self)

    def swap(self, *args):
        """swap(StringVector self, StringVector v)"""
        return _pypl.StringVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(StringVector self) -> std::vector< std::string >::allocator_type"""
        return _pypl.StringVector_get_allocator(self)

    def begin(self):
        """begin(StringVector self) -> std::vector< std::string >::iterator"""
        return _pypl.StringVector_begin(self)

    def end(self):
        """end(StringVector self) -> std::vector< std::string >::iterator"""
        return _pypl.StringVector_end(self)

    def rbegin(self):
        """rbegin(StringVector self) -> std::vector< std::string >::reverse_iterator"""
        return _pypl.StringVector_rbegin(self)

    def rend(self):
        """rend(StringVector self) -> std::vector< std::string >::reverse_iterator"""
        return _pypl.StringVector_rend(self)

    def pop_back(self):
        """pop_back(StringVector self)"""
        return _pypl.StringVector_pop_back(self)

    def erase(self, *args):
        """
        erase(StringVector self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(StringVector self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator
        """
        return _pypl.StringVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(std::string)> self) -> StringVector
        __init__(std::vector<(std::string)> self, StringVector arg2) -> StringVector
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size) -> StringVector
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> StringVector
        """
        this = _pypl.new_StringVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(StringVector self, std::vector< std::string >::value_type const & x)"""
        return _pypl.StringVector_push_back(self, *args)

    def front(self):
        """front(StringVector self) -> std::vector< std::string >::value_type const &"""
        return _pypl.StringVector_front(self)

    def back(self):
        """back(StringVector self) -> std::vector< std::string >::value_type const &"""
        return _pypl.StringVector_back(self)

    def assign(self, *args):
        """assign(StringVector self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)"""
        return _pypl.StringVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(StringVector self, std::vector< std::string >::size_type new_size)
        resize(StringVector self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)
        """
        return _pypl.StringVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(StringVector self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(StringVector self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, 
            std::vector< std::string >::value_type const & x)
        """
        return _pypl.StringVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(StringVector self, std::vector< std::string >::size_type n)"""
        return _pypl.StringVector_reserve(self, *args)

    def capacity(self):
        """capacity(StringVector self) -> std::vector< std::string >::size_type"""
        return _pypl.StringVector_capacity(self)

    __swig_destroy__ = _pypl.delete_StringVector
    __del__ = lambda self : None;
StringVector_swigregister = _pypl.StringVector_swigregister
StringVector_swigregister(StringVector)

class BoolVector(_object):
    """Proxy of C++ std::vector<(bool)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BoolVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BoolVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(BoolVector self) -> SwigPyIterator"""
        return _pypl.BoolVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(BoolVector self) -> bool"""
        return _pypl.BoolVector___nonzero__(self)

    def __bool__(self):
        """__bool__(BoolVector self) -> bool"""
        return _pypl.BoolVector___bool__(self)

    def __len__(self):
        """__len__(BoolVector self) -> std::vector< bool >::size_type"""
        return _pypl.BoolVector___len__(self)

    def pop(self):
        """pop(BoolVector self) -> std::vector< bool >::value_type"""
        return _pypl.BoolVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(BoolVector self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j) -> BoolVector"""
        return _pypl.BoolVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(BoolVector self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j, BoolVector v=std::vector< bool,std::allocator< bool > >())
        __setslice__(BoolVector self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j)
        """
        return _pypl.BoolVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(BoolVector self, std::vector< bool >::difference_type i, std::vector< bool >::difference_type j)"""
        return _pypl.BoolVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(BoolVector self, std::vector< bool >::difference_type i)
        __delitem__(BoolVector self, PySliceObject * slice)
        """
        return _pypl.BoolVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(BoolVector self, PySliceObject * slice) -> BoolVector
        __getitem__(BoolVector self, std::vector< bool >::difference_type i) -> std::vector< bool >::value_type
        """
        return _pypl.BoolVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(BoolVector self, PySliceObject * slice, BoolVector v)
        __setitem__(BoolVector self, PySliceObject * slice)
        __setitem__(BoolVector self, std::vector< bool >::difference_type i, std::vector< bool >::value_type x)
        """
        return _pypl.BoolVector___setitem__(self, *args)

    def append(self, *args):
        """append(BoolVector self, std::vector< bool >::value_type x)"""
        return _pypl.BoolVector_append(self, *args)

    def empty(self):
        """empty(BoolVector self) -> bool"""
        return _pypl.BoolVector_empty(self)

    def size(self):
        """size(BoolVector self) -> std::vector< bool >::size_type"""
        return _pypl.BoolVector_size(self)

    def clear(self):
        """clear(BoolVector self)"""
        return _pypl.BoolVector_clear(self)

    def swap(self, *args):
        """swap(BoolVector self, BoolVector v)"""
        return _pypl.BoolVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(BoolVector self) -> std::vector< bool >::allocator_type"""
        return _pypl.BoolVector_get_allocator(self)

    def begin(self):
        """begin(BoolVector self) -> std::vector< bool >::iterator"""
        return _pypl.BoolVector_begin(self)

    def end(self):
        """end(BoolVector self) -> std::vector< bool >::iterator"""
        return _pypl.BoolVector_end(self)

    def rbegin(self):
        """rbegin(BoolVector self) -> std::vector< bool >::reverse_iterator"""
        return _pypl.BoolVector_rbegin(self)

    def rend(self):
        """rend(BoolVector self) -> std::vector< bool >::reverse_iterator"""
        return _pypl.BoolVector_rend(self)

    def pop_back(self):
        """pop_back(BoolVector self)"""
        return _pypl.BoolVector_pop_back(self)

    def erase(self, *args):
        """
        erase(BoolVector self, std::vector< bool >::iterator pos) -> std::vector< bool >::iterator
        erase(BoolVector self, std::vector< bool >::iterator first, std::vector< bool >::iterator last) -> std::vector< bool >::iterator
        """
        return _pypl.BoolVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(bool)> self) -> BoolVector
        __init__(std::vector<(bool)> self, BoolVector arg2) -> BoolVector
        __init__(std::vector<(bool)> self, std::vector< bool >::size_type size) -> BoolVector
        __init__(std::vector<(bool)> self, std::vector< bool >::size_type size, std::vector< bool >::value_type value) -> BoolVector
        """
        this = _pypl.new_BoolVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(BoolVector self, std::vector< bool >::value_type x)"""
        return _pypl.BoolVector_push_back(self, *args)

    def front(self):
        """front(BoolVector self) -> std::vector< bool >::value_type"""
        return _pypl.BoolVector_front(self)

    def back(self):
        """back(BoolVector self) -> std::vector< bool >::value_type"""
        return _pypl.BoolVector_back(self)

    def assign(self, *args):
        """assign(BoolVector self, std::vector< bool >::size_type n, std::vector< bool >::value_type x)"""
        return _pypl.BoolVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(BoolVector self, std::vector< bool >::size_type new_size)
        resize(BoolVector self, std::vector< bool >::size_type new_size, std::vector< bool >::value_type x)
        """
        return _pypl.BoolVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(BoolVector self, std::vector< bool >::iterator pos, std::vector< bool >::value_type x) -> std::vector< bool >::iterator
        insert(BoolVector self, std::vector< bool >::iterator pos, std::vector< bool >::size_type n, std::vector< bool >::value_type x)
        """
        return _pypl.BoolVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(BoolVector self, std::vector< bool >::size_type n)"""
        return _pypl.BoolVector_reserve(self, *args)

    def capacity(self):
        """capacity(BoolVector self) -> std::vector< bool >::size_type"""
        return _pypl.BoolVector_capacity(self)

    __swig_destroy__ = _pypl.delete_BoolVector
    __del__ = lambda self : None;
BoolVector_swigregister = _pypl.BoolVector_swigregister
BoolVector_swigregister(BoolVector)

class FloatVector(_object):
    """Proxy of C++ std::vector<(float)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FloatVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(FloatVector self) -> SwigPyIterator"""
        return _pypl.FloatVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(FloatVector self) -> bool"""
        return _pypl.FloatVector___nonzero__(self)

    def __bool__(self):
        """__bool__(FloatVector self) -> bool"""
        return _pypl.FloatVector___bool__(self)

    def __len__(self):
        """__len__(FloatVector self) -> std::vector< float >::size_type"""
        return _pypl.FloatVector___len__(self)

    def pop(self):
        """pop(FloatVector self) -> std::vector< float >::value_type"""
        return _pypl.FloatVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(FloatVector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j) -> FloatVector"""
        return _pypl.FloatVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(FloatVector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j, 
            FloatVector v=std::vector< float,std::allocator< float > >())
        __setslice__(FloatVector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)
        """
        return _pypl.FloatVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(FloatVector self, std::vector< float >::difference_type i, std::vector< float >::difference_type j)"""
        return _pypl.FloatVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(FloatVector self, std::vector< float >::difference_type i)
        __delitem__(FloatVector self, PySliceObject * slice)
        """
        return _pypl.FloatVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(FloatVector self, PySliceObject * slice) -> FloatVector
        __getitem__(FloatVector self, std::vector< float >::difference_type i) -> std::vector< float >::value_type const &
        """
        return _pypl.FloatVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(FloatVector self, PySliceObject * slice, FloatVector v)
        __setitem__(FloatVector self, PySliceObject * slice)
        __setitem__(FloatVector self, std::vector< float >::difference_type i, std::vector< float >::value_type const & x)
        """
        return _pypl.FloatVector___setitem__(self, *args)

    def append(self, *args):
        """append(FloatVector self, std::vector< float >::value_type const & x)"""
        return _pypl.FloatVector_append(self, *args)

    def empty(self):
        """empty(FloatVector self) -> bool"""
        return _pypl.FloatVector_empty(self)

    def size(self):
        """size(FloatVector self) -> std::vector< float >::size_type"""
        return _pypl.FloatVector_size(self)

    def clear(self):
        """clear(FloatVector self)"""
        return _pypl.FloatVector_clear(self)

    def swap(self, *args):
        """swap(FloatVector self, FloatVector v)"""
        return _pypl.FloatVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(FloatVector self) -> std::vector< float >::allocator_type"""
        return _pypl.FloatVector_get_allocator(self)

    def begin(self):
        """begin(FloatVector self) -> std::vector< float >::iterator"""
        return _pypl.FloatVector_begin(self)

    def end(self):
        """end(FloatVector self) -> std::vector< float >::iterator"""
        return _pypl.FloatVector_end(self)

    def rbegin(self):
        """rbegin(FloatVector self) -> std::vector< float >::reverse_iterator"""
        return _pypl.FloatVector_rbegin(self)

    def rend(self):
        """rend(FloatVector self) -> std::vector< float >::reverse_iterator"""
        return _pypl.FloatVector_rend(self)

    def pop_back(self):
        """pop_back(FloatVector self)"""
        return _pypl.FloatVector_pop_back(self)

    def erase(self, *args):
        """
        erase(FloatVector self, std::vector< float >::iterator pos) -> std::vector< float >::iterator
        erase(FloatVector self, std::vector< float >::iterator first, std::vector< float >::iterator last) -> std::vector< float >::iterator
        """
        return _pypl.FloatVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(float)> self) -> FloatVector
        __init__(std::vector<(float)> self, FloatVector arg2) -> FloatVector
        __init__(std::vector<(float)> self, std::vector< float >::size_type size) -> FloatVector
        __init__(std::vector<(float)> self, std::vector< float >::size_type size, std::vector< float >::value_type const & value) -> FloatVector
        """
        this = _pypl.new_FloatVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(FloatVector self, std::vector< float >::value_type const & x)"""
        return _pypl.FloatVector_push_back(self, *args)

    def front(self):
        """front(FloatVector self) -> std::vector< float >::value_type const &"""
        return _pypl.FloatVector_front(self)

    def back(self):
        """back(FloatVector self) -> std::vector< float >::value_type const &"""
        return _pypl.FloatVector_back(self)

    def assign(self, *args):
        """assign(FloatVector self, std::vector< float >::size_type n, std::vector< float >::value_type const & x)"""
        return _pypl.FloatVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(FloatVector self, std::vector< float >::size_type new_size)
        resize(FloatVector self, std::vector< float >::size_type new_size, std::vector< float >::value_type const & x)
        """
        return _pypl.FloatVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(FloatVector self, std::vector< float >::iterator pos, std::vector< float >::value_type const & x) -> std::vector< float >::iterator
        insert(FloatVector self, std::vector< float >::iterator pos, std::vector< float >::size_type n, std::vector< float >::value_type const & x)
        """
        return _pypl.FloatVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(FloatVector self, std::vector< float >::size_type n)"""
        return _pypl.FloatVector_reserve(self, *args)

    def capacity(self):
        """capacity(FloatVector self) -> std::vector< float >::size_type"""
        return _pypl.FloatVector_capacity(self)

    __swig_destroy__ = _pypl.delete_FloatVector
    __del__ = lambda self : None;
FloatVector_swigregister = _pypl.FloatVector_swigregister
FloatVector_swigregister(FloatVector)

class FloatVectorVector(_object):
    """Proxy of C++ std::vector<(std::vector<(float)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FloatVectorVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(FloatVectorVector self) -> SwigPyIterator"""
        return _pypl.FloatVectorVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(FloatVectorVector self) -> bool"""
        return _pypl.FloatVectorVector___nonzero__(self)

    def __bool__(self):
        """__bool__(FloatVectorVector self) -> bool"""
        return _pypl.FloatVectorVector___bool__(self)

    def __len__(self):
        """__len__(FloatVectorVector self) -> std::vector< std::vector< float > >::size_type"""
        return _pypl.FloatVectorVector___len__(self)

    def pop(self):
        """pop(FloatVectorVector self) -> FloatVector"""
        return _pypl.FloatVectorVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(FloatVectorVector self, std::vector< std::vector< float > >::difference_type i, std::vector< std::vector< float > >::difference_type j) -> FloatVectorVector"""
        return _pypl.FloatVectorVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(FloatVectorVector self, std::vector< std::vector< float > >::difference_type i, std::vector< std::vector< float > >::difference_type j, 
            FloatVectorVector v=std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >())
        __setslice__(FloatVectorVector self, std::vector< std::vector< float > >::difference_type i, std::vector< std::vector< float > >::difference_type j)
        """
        return _pypl.FloatVectorVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(FloatVectorVector self, std::vector< std::vector< float > >::difference_type i, std::vector< std::vector< float > >::difference_type j)"""
        return _pypl.FloatVectorVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(FloatVectorVector self, std::vector< std::vector< float > >::difference_type i)
        __delitem__(FloatVectorVector self, PySliceObject * slice)
        """
        return _pypl.FloatVectorVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(FloatVectorVector self, PySliceObject * slice) -> FloatVectorVector
        __getitem__(FloatVectorVector self, std::vector< std::vector< float > >::difference_type i) -> FloatVector
        """
        return _pypl.FloatVectorVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(FloatVectorVector self, PySliceObject * slice, FloatVectorVector v)
        __setitem__(FloatVectorVector self, PySliceObject * slice)
        __setitem__(FloatVectorVector self, std::vector< std::vector< float > >::difference_type i, FloatVector x)
        """
        return _pypl.FloatVectorVector___setitem__(self, *args)

    def append(self, *args):
        """append(FloatVectorVector self, FloatVector x)"""
        return _pypl.FloatVectorVector_append(self, *args)

    def empty(self):
        """empty(FloatVectorVector self) -> bool"""
        return _pypl.FloatVectorVector_empty(self)

    def size(self):
        """size(FloatVectorVector self) -> std::vector< std::vector< float > >::size_type"""
        return _pypl.FloatVectorVector_size(self)

    def clear(self):
        """clear(FloatVectorVector self)"""
        return _pypl.FloatVectorVector_clear(self)

    def swap(self, *args):
        """swap(FloatVectorVector self, FloatVectorVector v)"""
        return _pypl.FloatVectorVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(FloatVectorVector self) -> std::vector< std::vector< float > >::allocator_type"""
        return _pypl.FloatVectorVector_get_allocator(self)

    def begin(self):
        """begin(FloatVectorVector self) -> std::vector< std::vector< float > >::iterator"""
        return _pypl.FloatVectorVector_begin(self)

    def end(self):
        """end(FloatVectorVector self) -> std::vector< std::vector< float > >::iterator"""
        return _pypl.FloatVectorVector_end(self)

    def rbegin(self):
        """rbegin(FloatVectorVector self) -> std::vector< std::vector< float > >::reverse_iterator"""
        return _pypl.FloatVectorVector_rbegin(self)

    def rend(self):
        """rend(FloatVectorVector self) -> std::vector< std::vector< float > >::reverse_iterator"""
        return _pypl.FloatVectorVector_rend(self)

    def pop_back(self):
        """pop_back(FloatVectorVector self)"""
        return _pypl.FloatVectorVector_pop_back(self)

    def erase(self, *args):
        """
        erase(FloatVectorVector self, std::vector< std::vector< float > >::iterator pos) -> std::vector< std::vector< float > >::iterator
        erase(FloatVectorVector self, std::vector< std::vector< float > >::iterator first, std::vector< std::vector< float > >::iterator last) -> std::vector< std::vector< float > >::iterator
        """
        return _pypl.FloatVectorVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(std::vector<(float)>)> self) -> FloatVectorVector
        __init__(std::vector<(std::vector<(float)>)> self, FloatVectorVector arg2) -> FloatVectorVector
        __init__(std::vector<(std::vector<(float)>)> self, std::vector< std::vector< float > >::size_type size) -> FloatVectorVector
        __init__(std::vector<(std::vector<(float)>)> self, std::vector< std::vector< float > >::size_type size, FloatVector value) -> FloatVectorVector
        """
        this = _pypl.new_FloatVectorVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(FloatVectorVector self, FloatVector x)"""
        return _pypl.FloatVectorVector_push_back(self, *args)

    def front(self):
        """front(FloatVectorVector self) -> FloatVector"""
        return _pypl.FloatVectorVector_front(self)

    def back(self):
        """back(FloatVectorVector self) -> FloatVector"""
        return _pypl.FloatVectorVector_back(self)

    def assign(self, *args):
        """assign(FloatVectorVector self, std::vector< std::vector< float > >::size_type n, FloatVector x)"""
        return _pypl.FloatVectorVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(FloatVectorVector self, std::vector< std::vector< float > >::size_type new_size)
        resize(FloatVectorVector self, std::vector< std::vector< float > >::size_type new_size, FloatVector x)
        """
        return _pypl.FloatVectorVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(FloatVectorVector self, std::vector< std::vector< float > >::iterator pos, FloatVector x) -> std::vector< std::vector< float > >::iterator
        insert(FloatVectorVector self, std::vector< std::vector< float > >::iterator pos, std::vector< std::vector< float > >::size_type n, 
            FloatVector x)
        """
        return _pypl.FloatVectorVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(FloatVectorVector self, std::vector< std::vector< float > >::size_type n)"""
        return _pypl.FloatVectorVector_reserve(self, *args)

    def capacity(self):
        """capacity(FloatVectorVector self) -> std::vector< std::vector< float > >::size_type"""
        return _pypl.FloatVectorVector_capacity(self)

    __swig_destroy__ = _pypl.delete_FloatVectorVector
    __del__ = lambda self : None;
FloatVectorVector_swigregister = _pypl.FloatVectorVector_swigregister
FloatVectorVector_swigregister(FloatVectorVector)

class FloatVectorVectorVector(_object):
    """Proxy of C++ std::vector<(std::vector<(std::vector<(float)>)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatVectorVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FloatVectorVectorVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(FloatVectorVectorVector self) -> SwigPyIterator"""
        return _pypl.FloatVectorVectorVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(FloatVectorVectorVector self) -> bool"""
        return _pypl.FloatVectorVectorVector___nonzero__(self)

    def __bool__(self):
        """__bool__(FloatVectorVectorVector self) -> bool"""
        return _pypl.FloatVectorVectorVector___bool__(self)

    def __len__(self):
        """__len__(FloatVectorVectorVector self) -> std::vector< std::vector< std::vector< float > > >::size_type"""
        return _pypl.FloatVectorVectorVector___len__(self)

    def pop(self):
        """pop(FloatVectorVectorVector self) -> FloatVectorVector"""
        return _pypl.FloatVectorVectorVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(FloatVectorVectorVector self, std::vector< std::vector< std::vector< float > > >::difference_type i, std::vector< std::vector< std::vector< float > > >::difference_type j) -> FloatVectorVectorVector"""
        return _pypl.FloatVectorVectorVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(FloatVectorVectorVector self, std::vector< std::vector< std::vector< float > > >::difference_type i, std::vector< std::vector< std::vector< float > > >::difference_type j, 
            FloatVectorVectorVector v=std::vector< std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >,std::allocator< std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > > >())
        __setslice__(FloatVectorVectorVector self, std::vector< std::vector< std::vector< float > > >::difference_type i, std::vector< std::vector< std::vector< float > > >::difference_type j)
        """
        return _pypl.FloatVectorVectorVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(FloatVectorVectorVector self, std::vector< std::vector< std::vector< float > > >::difference_type i, std::vector< std::vector< std::vector< float > > >::difference_type j)"""
        return _pypl.FloatVectorVectorVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(FloatVectorVectorVector self, std::vector< std::vector< std::vector< float > > >::difference_type i)
        __delitem__(FloatVectorVectorVector self, PySliceObject * slice)
        """
        return _pypl.FloatVectorVectorVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(FloatVectorVectorVector self, PySliceObject * slice) -> FloatVectorVectorVector
        __getitem__(FloatVectorVectorVector self, std::vector< std::vector< std::vector< float > > >::difference_type i) -> FloatVectorVector
        """
        return _pypl.FloatVectorVectorVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(FloatVectorVectorVector self, PySliceObject * slice, FloatVectorVectorVector v)
        __setitem__(FloatVectorVectorVector self, PySliceObject * slice)
        __setitem__(FloatVectorVectorVector self, std::vector< std::vector< std::vector< float > > >::difference_type i, FloatVectorVector x)
        """
        return _pypl.FloatVectorVectorVector___setitem__(self, *args)

    def append(self, *args):
        """append(FloatVectorVectorVector self, FloatVectorVector x)"""
        return _pypl.FloatVectorVectorVector_append(self, *args)

    def empty(self):
        """empty(FloatVectorVectorVector self) -> bool"""
        return _pypl.FloatVectorVectorVector_empty(self)

    def size(self):
        """size(FloatVectorVectorVector self) -> std::vector< std::vector< std::vector< float > > >::size_type"""
        return _pypl.FloatVectorVectorVector_size(self)

    def clear(self):
        """clear(FloatVectorVectorVector self)"""
        return _pypl.FloatVectorVectorVector_clear(self)

    def swap(self, *args):
        """swap(FloatVectorVectorVector self, FloatVectorVectorVector v)"""
        return _pypl.FloatVectorVectorVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(FloatVectorVectorVector self) -> std::vector< std::vector< std::vector< float > > >::allocator_type"""
        return _pypl.FloatVectorVectorVector_get_allocator(self)

    def begin(self):
        """begin(FloatVectorVectorVector self) -> std::vector< std::vector< std::vector< float > > >::iterator"""
        return _pypl.FloatVectorVectorVector_begin(self)

    def end(self):
        """end(FloatVectorVectorVector self) -> std::vector< std::vector< std::vector< float > > >::iterator"""
        return _pypl.FloatVectorVectorVector_end(self)

    def rbegin(self):
        """rbegin(FloatVectorVectorVector self) -> std::vector< std::vector< std::vector< float > > >::reverse_iterator"""
        return _pypl.FloatVectorVectorVector_rbegin(self)

    def rend(self):
        """rend(FloatVectorVectorVector self) -> std::vector< std::vector< std::vector< float > > >::reverse_iterator"""
        return _pypl.FloatVectorVectorVector_rend(self)

    def pop_back(self):
        """pop_back(FloatVectorVectorVector self)"""
        return _pypl.FloatVectorVectorVector_pop_back(self)

    def erase(self, *args):
        """
        erase(FloatVectorVectorVector self, std::vector< std::vector< std::vector< float > > >::iterator pos) -> std::vector< std::vector< std::vector< float > > >::iterator
        erase(FloatVectorVectorVector self, std::vector< std::vector< std::vector< float > > >::iterator first, std::vector< std::vector< std::vector< float > > >::iterator last) -> std::vector< std::vector< std::vector< float > > >::iterator
        """
        return _pypl.FloatVectorVectorVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(std::vector<(std::vector<(float)>)>)> self) -> FloatVectorVectorVector
        __init__(std::vector<(std::vector<(std::vector<(float)>)>)> self, FloatVectorVectorVector arg2) -> FloatVectorVectorVector
        __init__(std::vector<(std::vector<(std::vector<(float)>)>)> self, std::vector< std::vector< std::vector< float > > >::size_type size) -> FloatVectorVectorVector
        __init__(std::vector<(std::vector<(std::vector<(float)>)>)> self, std::vector< std::vector< std::vector< float > > >::size_type size, FloatVectorVector value) -> FloatVectorVectorVector
        """
        this = _pypl.new_FloatVectorVectorVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(FloatVectorVectorVector self, FloatVectorVector x)"""
        return _pypl.FloatVectorVectorVector_push_back(self, *args)

    def front(self):
        """front(FloatVectorVectorVector self) -> FloatVectorVector"""
        return _pypl.FloatVectorVectorVector_front(self)

    def back(self):
        """back(FloatVectorVectorVector self) -> FloatVectorVector"""
        return _pypl.FloatVectorVectorVector_back(self)

    def assign(self, *args):
        """assign(FloatVectorVectorVector self, std::vector< std::vector< std::vector< float > > >::size_type n, FloatVectorVector x)"""
        return _pypl.FloatVectorVectorVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(FloatVectorVectorVector self, std::vector< std::vector< std::vector< float > > >::size_type new_size)
        resize(FloatVectorVectorVector self, std::vector< std::vector< std::vector< float > > >::size_type new_size, FloatVectorVector x)
        """
        return _pypl.FloatVectorVectorVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(FloatVectorVectorVector self, std::vector< std::vector< std::vector< float > > >::iterator pos, FloatVectorVector x) -> std::vector< std::vector< std::vector< float > > >::iterator
        insert(FloatVectorVectorVector self, std::vector< std::vector< std::vector< float > > >::iterator pos, std::vector< std::vector< std::vector< float > > >::size_type n, 
            FloatVectorVector x)
        """
        return _pypl.FloatVectorVectorVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(FloatVectorVectorVector self, std::vector< std::vector< std::vector< float > > >::size_type n)"""
        return _pypl.FloatVectorVectorVector_reserve(self, *args)

    def capacity(self):
        """capacity(FloatVectorVectorVector self) -> std::vector< std::vector< std::vector< float > > >::size_type"""
        return _pypl.FloatVectorVectorVector_capacity(self)

    __swig_destroy__ = _pypl.delete_FloatVectorVectorVector
    __del__ = lambda self : None;
FloatVectorVectorVector_swigregister = _pypl.FloatVectorVectorVector_swigregister
FloatVectorVectorVector_swigregister(FloatVectorVectorVector)

class DoubleVector(_object):
    """Proxy of C++ std::vector<(double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(DoubleVector self) -> SwigPyIterator"""
        return _pypl.DoubleVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(DoubleVector self) -> bool"""
        return _pypl.DoubleVector___nonzero__(self)

    def __bool__(self):
        """__bool__(DoubleVector self) -> bool"""
        return _pypl.DoubleVector___bool__(self)

    def __len__(self):
        """__len__(DoubleVector self) -> std::vector< double >::size_type"""
        return _pypl.DoubleVector___len__(self)

    def pop(self):
        """pop(DoubleVector self) -> std::vector< double >::value_type"""
        return _pypl.DoubleVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> DoubleVector"""
        return _pypl.DoubleVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, 
            DoubleVector v=std::vector< double,std::allocator< double > >())
        __setslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        """
        return _pypl.DoubleVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _pypl.DoubleVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(DoubleVector self, std::vector< double >::difference_type i)
        __delitem__(DoubleVector self, PySliceObject * slice)
        """
        return _pypl.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(DoubleVector self, PySliceObject * slice) -> DoubleVector
        __getitem__(DoubleVector self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _pypl.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(DoubleVector self, PySliceObject * slice, DoubleVector v)
        __setitem__(DoubleVector self, PySliceObject * slice)
        __setitem__(DoubleVector self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _pypl.DoubleVector___setitem__(self, *args)

    def append(self, *args):
        """append(DoubleVector self, std::vector< double >::value_type const & x)"""
        return _pypl.DoubleVector_append(self, *args)

    def empty(self):
        """empty(DoubleVector self) -> bool"""
        return _pypl.DoubleVector_empty(self)

    def size(self):
        """size(DoubleVector self) -> std::vector< double >::size_type"""
        return _pypl.DoubleVector_size(self)

    def clear(self):
        """clear(DoubleVector self)"""
        return _pypl.DoubleVector_clear(self)

    def swap(self, *args):
        """swap(DoubleVector self, DoubleVector v)"""
        return _pypl.DoubleVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(DoubleVector self) -> std::vector< double >::allocator_type"""
        return _pypl.DoubleVector_get_allocator(self)

    def begin(self):
        """begin(DoubleVector self) -> std::vector< double >::iterator"""
        return _pypl.DoubleVector_begin(self)

    def end(self):
        """end(DoubleVector self) -> std::vector< double >::iterator"""
        return _pypl.DoubleVector_end(self)

    def rbegin(self):
        """rbegin(DoubleVector self) -> std::vector< double >::reverse_iterator"""
        return _pypl.DoubleVector_rbegin(self)

    def rend(self):
        """rend(DoubleVector self) -> std::vector< double >::reverse_iterator"""
        return _pypl.DoubleVector_rend(self)

    def pop_back(self):
        """pop_back(DoubleVector self)"""
        return _pypl.DoubleVector_pop_back(self)

    def erase(self, *args):
        """
        erase(DoubleVector self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(DoubleVector self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _pypl.DoubleVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(double)> self) -> DoubleVector
        __init__(std::vector<(double)> self, DoubleVector arg2) -> DoubleVector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> DoubleVector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> DoubleVector
        """
        this = _pypl.new_DoubleVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(DoubleVector self, std::vector< double >::value_type const & x)"""
        return _pypl.DoubleVector_push_back(self, *args)

    def front(self):
        """front(DoubleVector self) -> std::vector< double >::value_type const &"""
        return _pypl.DoubleVector_front(self)

    def back(self):
        """back(DoubleVector self) -> std::vector< double >::value_type const &"""
        return _pypl.DoubleVector_back(self)

    def assign(self, *args):
        """assign(DoubleVector self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _pypl.DoubleVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(DoubleVector self, std::vector< double >::size_type new_size)
        resize(DoubleVector self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _pypl.DoubleVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(DoubleVector self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(DoubleVector self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _pypl.DoubleVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(DoubleVector self, std::vector< double >::size_type n)"""
        return _pypl.DoubleVector_reserve(self, *args)

    def capacity(self):
        """capacity(DoubleVector self) -> std::vector< double >::size_type"""
        return _pypl.DoubleVector_capacity(self)

    __swig_destroy__ = _pypl.delete_DoubleVector
    __del__ = lambda self : None;
DoubleVector_swigregister = _pypl.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class DoubleVectorVector(_object):
    """Proxy of C++ std::vector<(std::vector<(double)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVectorVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(DoubleVectorVector self) -> SwigPyIterator"""
        return _pypl.DoubleVectorVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(DoubleVectorVector self) -> bool"""
        return _pypl.DoubleVectorVector___nonzero__(self)

    def __bool__(self):
        """__bool__(DoubleVectorVector self) -> bool"""
        return _pypl.DoubleVectorVector___bool__(self)

    def __len__(self):
        """__len__(DoubleVectorVector self) -> std::vector< std::vector< double > >::size_type"""
        return _pypl.DoubleVectorVector___len__(self)

    def pop(self):
        """pop(DoubleVectorVector self) -> DoubleVector"""
        return _pypl.DoubleVectorVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(DoubleVectorVector self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j) -> DoubleVectorVector"""
        return _pypl.DoubleVectorVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(DoubleVectorVector self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j, 
            DoubleVectorVector v=std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >())
        __setslice__(DoubleVectorVector self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)
        """
        return _pypl.DoubleVectorVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(DoubleVectorVector self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)"""
        return _pypl.DoubleVectorVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(DoubleVectorVector self, std::vector< std::vector< double > >::difference_type i)
        __delitem__(DoubleVectorVector self, PySliceObject * slice)
        """
        return _pypl.DoubleVectorVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(DoubleVectorVector self, PySliceObject * slice) -> DoubleVectorVector
        __getitem__(DoubleVectorVector self, std::vector< std::vector< double > >::difference_type i) -> DoubleVector
        """
        return _pypl.DoubleVectorVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(DoubleVectorVector self, PySliceObject * slice, DoubleVectorVector v)
        __setitem__(DoubleVectorVector self, PySliceObject * slice)
        __setitem__(DoubleVectorVector self, std::vector< std::vector< double > >::difference_type i, DoubleVector x)
        """
        return _pypl.DoubleVectorVector___setitem__(self, *args)

    def append(self, *args):
        """append(DoubleVectorVector self, DoubleVector x)"""
        return _pypl.DoubleVectorVector_append(self, *args)

    def empty(self):
        """empty(DoubleVectorVector self) -> bool"""
        return _pypl.DoubleVectorVector_empty(self)

    def size(self):
        """size(DoubleVectorVector self) -> std::vector< std::vector< double > >::size_type"""
        return _pypl.DoubleVectorVector_size(self)

    def clear(self):
        """clear(DoubleVectorVector self)"""
        return _pypl.DoubleVectorVector_clear(self)

    def swap(self, *args):
        """swap(DoubleVectorVector self, DoubleVectorVector v)"""
        return _pypl.DoubleVectorVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(DoubleVectorVector self) -> std::vector< std::vector< double > >::allocator_type"""
        return _pypl.DoubleVectorVector_get_allocator(self)

    def begin(self):
        """begin(DoubleVectorVector self) -> std::vector< std::vector< double > >::iterator"""
        return _pypl.DoubleVectorVector_begin(self)

    def end(self):
        """end(DoubleVectorVector self) -> std::vector< std::vector< double > >::iterator"""
        return _pypl.DoubleVectorVector_end(self)

    def rbegin(self):
        """rbegin(DoubleVectorVector self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _pypl.DoubleVectorVector_rbegin(self)

    def rend(self):
        """rend(DoubleVectorVector self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _pypl.DoubleVectorVector_rend(self)

    def pop_back(self):
        """pop_back(DoubleVectorVector self)"""
        return _pypl.DoubleVectorVector_pop_back(self)

    def erase(self, *args):
        """
        erase(DoubleVectorVector self, std::vector< std::vector< double > >::iterator pos) -> std::vector< std::vector< double > >::iterator
        erase(DoubleVectorVector self, std::vector< std::vector< double > >::iterator first, std::vector< std::vector< double > >::iterator last) -> std::vector< std::vector< double > >::iterator
        """
        return _pypl.DoubleVectorVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(std::vector<(double)>)> self) -> DoubleVectorVector
        __init__(std::vector<(std::vector<(double)>)> self, DoubleVectorVector arg2) -> DoubleVectorVector
        __init__(std::vector<(std::vector<(double)>)> self, std::vector< std::vector< double > >::size_type size) -> DoubleVectorVector
        __init__(std::vector<(std::vector<(double)>)> self, std::vector< std::vector< double > >::size_type size, DoubleVector value) -> DoubleVectorVector
        """
        this = _pypl.new_DoubleVectorVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(DoubleVectorVector self, DoubleVector x)"""
        return _pypl.DoubleVectorVector_push_back(self, *args)

    def front(self):
        """front(DoubleVectorVector self) -> DoubleVector"""
        return _pypl.DoubleVectorVector_front(self)

    def back(self):
        """back(DoubleVectorVector self) -> DoubleVector"""
        return _pypl.DoubleVectorVector_back(self)

    def assign(self, *args):
        """assign(DoubleVectorVector self, std::vector< std::vector< double > >::size_type n, DoubleVector x)"""
        return _pypl.DoubleVectorVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(DoubleVectorVector self, std::vector< std::vector< double > >::size_type new_size)
        resize(DoubleVectorVector self, std::vector< std::vector< double > >::size_type new_size, DoubleVector x)
        """
        return _pypl.DoubleVectorVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(DoubleVectorVector self, std::vector< std::vector< double > >::iterator pos, DoubleVector x) -> std::vector< std::vector< double > >::iterator
        insert(DoubleVectorVector self, std::vector< std::vector< double > >::iterator pos, std::vector< std::vector< double > >::size_type n, 
            DoubleVector x)
        """
        return _pypl.DoubleVectorVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(DoubleVectorVector self, std::vector< std::vector< double > >::size_type n)"""
        return _pypl.DoubleVectorVector_reserve(self, *args)

    def capacity(self):
        """capacity(DoubleVectorVector self) -> std::vector< std::vector< double > >::size_type"""
        return _pypl.DoubleVectorVector_capacity(self)

    __swig_destroy__ = _pypl.delete_DoubleVectorVector
    __del__ = lambda self : None;
DoubleVectorVector_swigregister = _pypl.DoubleVectorVector_swigregister
DoubleVectorVector_swigregister(DoubleVectorVector)

class DoubleVectorVectorVector(_object):
    """Proxy of C++ std::vector<(std::vector<(std::vector<(double)>)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVectorVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVectorVectorVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(DoubleVectorVectorVector self) -> SwigPyIterator"""
        return _pypl.DoubleVectorVectorVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(DoubleVectorVectorVector self) -> bool"""
        return _pypl.DoubleVectorVectorVector___nonzero__(self)

    def __bool__(self):
        """__bool__(DoubleVectorVectorVector self) -> bool"""
        return _pypl.DoubleVectorVectorVector___bool__(self)

    def __len__(self):
        """__len__(DoubleVectorVectorVector self) -> std::vector< std::vector< std::vector< double > > >::size_type"""
        return _pypl.DoubleVectorVectorVector___len__(self)

    def pop(self):
        """pop(DoubleVectorVectorVector self) -> DoubleVectorVector"""
        return _pypl.DoubleVectorVectorVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(DoubleVectorVectorVector self, std::vector< std::vector< std::vector< double > > >::difference_type i, std::vector< std::vector< std::vector< double > > >::difference_type j) -> DoubleVectorVectorVector"""
        return _pypl.DoubleVectorVectorVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(DoubleVectorVectorVector self, std::vector< std::vector< std::vector< double > > >::difference_type i, std::vector< std::vector< std::vector< double > > >::difference_type j, 
            DoubleVectorVectorVector v=std::vector< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >,std::allocator< std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > > >())
        __setslice__(DoubleVectorVectorVector self, std::vector< std::vector< std::vector< double > > >::difference_type i, std::vector< std::vector< std::vector< double > > >::difference_type j)
        """
        return _pypl.DoubleVectorVectorVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(DoubleVectorVectorVector self, std::vector< std::vector< std::vector< double > > >::difference_type i, std::vector< std::vector< std::vector< double > > >::difference_type j)"""
        return _pypl.DoubleVectorVectorVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(DoubleVectorVectorVector self, std::vector< std::vector< std::vector< double > > >::difference_type i)
        __delitem__(DoubleVectorVectorVector self, PySliceObject * slice)
        """
        return _pypl.DoubleVectorVectorVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(DoubleVectorVectorVector self, PySliceObject * slice) -> DoubleVectorVectorVector
        __getitem__(DoubleVectorVectorVector self, std::vector< std::vector< std::vector< double > > >::difference_type i) -> DoubleVectorVector
        """
        return _pypl.DoubleVectorVectorVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(DoubleVectorVectorVector self, PySliceObject * slice, DoubleVectorVectorVector v)
        __setitem__(DoubleVectorVectorVector self, PySliceObject * slice)
        __setitem__(DoubleVectorVectorVector self, std::vector< std::vector< std::vector< double > > >::difference_type i, DoubleVectorVector x)
        """
        return _pypl.DoubleVectorVectorVector___setitem__(self, *args)

    def append(self, *args):
        """append(DoubleVectorVectorVector self, DoubleVectorVector x)"""
        return _pypl.DoubleVectorVectorVector_append(self, *args)

    def empty(self):
        """empty(DoubleVectorVectorVector self) -> bool"""
        return _pypl.DoubleVectorVectorVector_empty(self)

    def size(self):
        """size(DoubleVectorVectorVector self) -> std::vector< std::vector< std::vector< double > > >::size_type"""
        return _pypl.DoubleVectorVectorVector_size(self)

    def clear(self):
        """clear(DoubleVectorVectorVector self)"""
        return _pypl.DoubleVectorVectorVector_clear(self)

    def swap(self, *args):
        """swap(DoubleVectorVectorVector self, DoubleVectorVectorVector v)"""
        return _pypl.DoubleVectorVectorVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(DoubleVectorVectorVector self) -> std::vector< std::vector< std::vector< double > > >::allocator_type"""
        return _pypl.DoubleVectorVectorVector_get_allocator(self)

    def begin(self):
        """begin(DoubleVectorVectorVector self) -> std::vector< std::vector< std::vector< double > > >::iterator"""
        return _pypl.DoubleVectorVectorVector_begin(self)

    def end(self):
        """end(DoubleVectorVectorVector self) -> std::vector< std::vector< std::vector< double > > >::iterator"""
        return _pypl.DoubleVectorVectorVector_end(self)

    def rbegin(self):
        """rbegin(DoubleVectorVectorVector self) -> std::vector< std::vector< std::vector< double > > >::reverse_iterator"""
        return _pypl.DoubleVectorVectorVector_rbegin(self)

    def rend(self):
        """rend(DoubleVectorVectorVector self) -> std::vector< std::vector< std::vector< double > > >::reverse_iterator"""
        return _pypl.DoubleVectorVectorVector_rend(self)

    def pop_back(self):
        """pop_back(DoubleVectorVectorVector self)"""
        return _pypl.DoubleVectorVectorVector_pop_back(self)

    def erase(self, *args):
        """
        erase(DoubleVectorVectorVector self, std::vector< std::vector< std::vector< double > > >::iterator pos) -> std::vector< std::vector< std::vector< double > > >::iterator
        erase(DoubleVectorVectorVector self, std::vector< std::vector< std::vector< double > > >::iterator first, std::vector< std::vector< std::vector< double > > >::iterator last) -> std::vector< std::vector< std::vector< double > > >::iterator
        """
        return _pypl.DoubleVectorVectorVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(std::vector<(std::vector<(double)>)>)> self) -> DoubleVectorVectorVector
        __init__(std::vector<(std::vector<(std::vector<(double)>)>)> self, DoubleVectorVectorVector arg2) -> DoubleVectorVectorVector
        __init__(std::vector<(std::vector<(std::vector<(double)>)>)> self, std::vector< std::vector< std::vector< double > > >::size_type size) -> DoubleVectorVectorVector
        __init__(std::vector<(std::vector<(std::vector<(double)>)>)> self, std::vector< std::vector< std::vector< double > > >::size_type size, DoubleVectorVector value) -> DoubleVectorVectorVector
        """
        this = _pypl.new_DoubleVectorVectorVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(DoubleVectorVectorVector self, DoubleVectorVector x)"""
        return _pypl.DoubleVectorVectorVector_push_back(self, *args)

    def front(self):
        """front(DoubleVectorVectorVector self) -> DoubleVectorVector"""
        return _pypl.DoubleVectorVectorVector_front(self)

    def back(self):
        """back(DoubleVectorVectorVector self) -> DoubleVectorVector"""
        return _pypl.DoubleVectorVectorVector_back(self)

    def assign(self, *args):
        """assign(DoubleVectorVectorVector self, std::vector< std::vector< std::vector< double > > >::size_type n, DoubleVectorVector x)"""
        return _pypl.DoubleVectorVectorVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(DoubleVectorVectorVector self, std::vector< std::vector< std::vector< double > > >::size_type new_size)
        resize(DoubleVectorVectorVector self, std::vector< std::vector< std::vector< double > > >::size_type new_size, DoubleVectorVector x)
        """
        return _pypl.DoubleVectorVectorVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(DoubleVectorVectorVector self, std::vector< std::vector< std::vector< double > > >::iterator pos, DoubleVectorVector x) -> std::vector< std::vector< std::vector< double > > >::iterator
        insert(DoubleVectorVectorVector self, std::vector< std::vector< std::vector< double > > >::iterator pos, std::vector< std::vector< std::vector< double > > >::size_type n, 
            DoubleVectorVector x)
        """
        return _pypl.DoubleVectorVectorVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(DoubleVectorVectorVector self, std::vector< std::vector< std::vector< double > > >::size_type n)"""
        return _pypl.DoubleVectorVectorVector_reserve(self, *args)

    def capacity(self):
        """capacity(DoubleVectorVectorVector self) -> std::vector< std::vector< std::vector< double > > >::size_type"""
        return _pypl.DoubleVectorVectorVector_capacity(self)

    __swig_destroy__ = _pypl.delete_DoubleVectorVectorVector
    __del__ = lambda self : None;
DoubleVectorVectorVector_swigregister = _pypl.DoubleVectorVectorVector_swigregister
DoubleVectorVectorVector_swigregister(DoubleVectorVectorVector)

class LongDoubleVector(_object):
    """Proxy of C++ std::vector<(long double)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LongDoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LongDoubleVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(LongDoubleVector self) -> SwigPyIterator"""
        return _pypl.LongDoubleVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(LongDoubleVector self) -> bool"""
        return _pypl.LongDoubleVector___nonzero__(self)

    def __bool__(self):
        """__bool__(LongDoubleVector self) -> bool"""
        return _pypl.LongDoubleVector___bool__(self)

    def __len__(self):
        """__len__(LongDoubleVector self) -> std::vector< long double >::size_type"""
        return _pypl.LongDoubleVector___len__(self)

    def pop(self):
        """pop(LongDoubleVector self) -> std::vector< long double >::value_type"""
        return _pypl.LongDoubleVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(LongDoubleVector self, std::vector< long double >::difference_type i, std::vector< long double >::difference_type j) -> LongDoubleVector"""
        return _pypl.LongDoubleVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(LongDoubleVector self, std::vector< long double >::difference_type i, std::vector< long double >::difference_type j, 
            LongDoubleVector v=std::vector< long double,std::allocator< long double > >())
        __setslice__(LongDoubleVector self, std::vector< long double >::difference_type i, std::vector< long double >::difference_type j)
        """
        return _pypl.LongDoubleVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(LongDoubleVector self, std::vector< long double >::difference_type i, std::vector< long double >::difference_type j)"""
        return _pypl.LongDoubleVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(LongDoubleVector self, std::vector< long double >::difference_type i)
        __delitem__(LongDoubleVector self, PySliceObject * slice)
        """
        return _pypl.LongDoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(LongDoubleVector self, PySliceObject * slice) -> LongDoubleVector
        __getitem__(LongDoubleVector self, std::vector< long double >::difference_type i) -> std::vector< long double >::value_type const &
        """
        return _pypl.LongDoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(LongDoubleVector self, PySliceObject * slice, LongDoubleVector v)
        __setitem__(LongDoubleVector self, PySliceObject * slice)
        __setitem__(LongDoubleVector self, std::vector< long double >::difference_type i, std::vector< long double >::value_type const & x)
        """
        return _pypl.LongDoubleVector___setitem__(self, *args)

    def append(self, *args):
        """append(LongDoubleVector self, std::vector< long double >::value_type const & x)"""
        return _pypl.LongDoubleVector_append(self, *args)

    def empty(self):
        """empty(LongDoubleVector self) -> bool"""
        return _pypl.LongDoubleVector_empty(self)

    def size(self):
        """size(LongDoubleVector self) -> std::vector< long double >::size_type"""
        return _pypl.LongDoubleVector_size(self)

    def clear(self):
        """clear(LongDoubleVector self)"""
        return _pypl.LongDoubleVector_clear(self)

    def swap(self, *args):
        """swap(LongDoubleVector self, LongDoubleVector v)"""
        return _pypl.LongDoubleVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(LongDoubleVector self) -> std::vector< long double >::allocator_type"""
        return _pypl.LongDoubleVector_get_allocator(self)

    def begin(self):
        """begin(LongDoubleVector self) -> std::vector< long double >::iterator"""
        return _pypl.LongDoubleVector_begin(self)

    def end(self):
        """end(LongDoubleVector self) -> std::vector< long double >::iterator"""
        return _pypl.LongDoubleVector_end(self)

    def rbegin(self):
        """rbegin(LongDoubleVector self) -> std::vector< long double >::reverse_iterator"""
        return _pypl.LongDoubleVector_rbegin(self)

    def rend(self):
        """rend(LongDoubleVector self) -> std::vector< long double >::reverse_iterator"""
        return _pypl.LongDoubleVector_rend(self)

    def pop_back(self):
        """pop_back(LongDoubleVector self)"""
        return _pypl.LongDoubleVector_pop_back(self)

    def erase(self, *args):
        """
        erase(LongDoubleVector self, std::vector< long double >::iterator pos) -> std::vector< long double >::iterator
        erase(LongDoubleVector self, std::vector< long double >::iterator first, std::vector< long double >::iterator last) -> std::vector< long double >::iterator
        """
        return _pypl.LongDoubleVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(long double)> self) -> LongDoubleVector
        __init__(std::vector<(long double)> self, LongDoubleVector arg2) -> LongDoubleVector
        __init__(std::vector<(long double)> self, std::vector< long double >::size_type size) -> LongDoubleVector
        __init__(std::vector<(long double)> self, std::vector< long double >::size_type size, std::vector< long double >::value_type const & value) -> LongDoubleVector
        """
        this = _pypl.new_LongDoubleVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(LongDoubleVector self, std::vector< long double >::value_type const & x)"""
        return _pypl.LongDoubleVector_push_back(self, *args)

    def front(self):
        """front(LongDoubleVector self) -> std::vector< long double >::value_type const &"""
        return _pypl.LongDoubleVector_front(self)

    def back(self):
        """back(LongDoubleVector self) -> std::vector< long double >::value_type const &"""
        return _pypl.LongDoubleVector_back(self)

    def assign(self, *args):
        """assign(LongDoubleVector self, std::vector< long double >::size_type n, std::vector< long double >::value_type const & x)"""
        return _pypl.LongDoubleVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(LongDoubleVector self, std::vector< long double >::size_type new_size)
        resize(LongDoubleVector self, std::vector< long double >::size_type new_size, std::vector< long double >::value_type const & x)
        """
        return _pypl.LongDoubleVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(LongDoubleVector self, std::vector< long double >::iterator pos, std::vector< long double >::value_type const & x) -> std::vector< long double >::iterator
        insert(LongDoubleVector self, std::vector< long double >::iterator pos, std::vector< long double >::size_type n, 
            std::vector< long double >::value_type const & x)
        """
        return _pypl.LongDoubleVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(LongDoubleVector self, std::vector< long double >::size_type n)"""
        return _pypl.LongDoubleVector_reserve(self, *args)

    def capacity(self):
        """capacity(LongDoubleVector self) -> std::vector< long double >::size_type"""
        return _pypl.LongDoubleVector_capacity(self)

    __swig_destroy__ = _pypl.delete_LongDoubleVector
    __del__ = lambda self : None;
LongDoubleVector_swigregister = _pypl.LongDoubleVector_swigregister
LongDoubleVector_swigregister(LongDoubleVector)

class LongDoubleVectorVector(_object):
    """Proxy of C++ std::vector<(std::vector<(long double)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LongDoubleVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LongDoubleVectorVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(LongDoubleVectorVector self) -> SwigPyIterator"""
        return _pypl.LongDoubleVectorVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(LongDoubleVectorVector self) -> bool"""
        return _pypl.LongDoubleVectorVector___nonzero__(self)

    def __bool__(self):
        """__bool__(LongDoubleVectorVector self) -> bool"""
        return _pypl.LongDoubleVectorVector___bool__(self)

    def __len__(self):
        """__len__(LongDoubleVectorVector self) -> std::vector< std::vector< long double > >::size_type"""
        return _pypl.LongDoubleVectorVector___len__(self)

    def pop(self):
        """pop(LongDoubleVectorVector self) -> LongDoubleVector"""
        return _pypl.LongDoubleVectorVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(LongDoubleVectorVector self, std::vector< std::vector< long double > >::difference_type i, std::vector< std::vector< long double > >::difference_type j) -> LongDoubleVectorVector"""
        return _pypl.LongDoubleVectorVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(LongDoubleVectorVector self, std::vector< std::vector< long double > >::difference_type i, std::vector< std::vector< long double > >::difference_type j, 
            LongDoubleVectorVector v=std::vector< std::vector< long double,std::allocator< long double > >,std::allocator< std::vector< long double,std::allocator< long double > > > >())
        __setslice__(LongDoubleVectorVector self, std::vector< std::vector< long double > >::difference_type i, std::vector< std::vector< long double > >::difference_type j)
        """
        return _pypl.LongDoubleVectorVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(LongDoubleVectorVector self, std::vector< std::vector< long double > >::difference_type i, std::vector< std::vector< long double > >::difference_type j)"""
        return _pypl.LongDoubleVectorVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(LongDoubleVectorVector self, std::vector< std::vector< long double > >::difference_type i)
        __delitem__(LongDoubleVectorVector self, PySliceObject * slice)
        """
        return _pypl.LongDoubleVectorVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(LongDoubleVectorVector self, PySliceObject * slice) -> LongDoubleVectorVector
        __getitem__(LongDoubleVectorVector self, std::vector< std::vector< long double > >::difference_type i) -> LongDoubleVector
        """
        return _pypl.LongDoubleVectorVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(LongDoubleVectorVector self, PySliceObject * slice, LongDoubleVectorVector v)
        __setitem__(LongDoubleVectorVector self, PySliceObject * slice)
        __setitem__(LongDoubleVectorVector self, std::vector< std::vector< long double > >::difference_type i, LongDoubleVector x)
        """
        return _pypl.LongDoubleVectorVector___setitem__(self, *args)

    def append(self, *args):
        """append(LongDoubleVectorVector self, LongDoubleVector x)"""
        return _pypl.LongDoubleVectorVector_append(self, *args)

    def empty(self):
        """empty(LongDoubleVectorVector self) -> bool"""
        return _pypl.LongDoubleVectorVector_empty(self)

    def size(self):
        """size(LongDoubleVectorVector self) -> std::vector< std::vector< long double > >::size_type"""
        return _pypl.LongDoubleVectorVector_size(self)

    def clear(self):
        """clear(LongDoubleVectorVector self)"""
        return _pypl.LongDoubleVectorVector_clear(self)

    def swap(self, *args):
        """swap(LongDoubleVectorVector self, LongDoubleVectorVector v)"""
        return _pypl.LongDoubleVectorVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(LongDoubleVectorVector self) -> std::vector< std::vector< long double > >::allocator_type"""
        return _pypl.LongDoubleVectorVector_get_allocator(self)

    def begin(self):
        """begin(LongDoubleVectorVector self) -> std::vector< std::vector< long double > >::iterator"""
        return _pypl.LongDoubleVectorVector_begin(self)

    def end(self):
        """end(LongDoubleVectorVector self) -> std::vector< std::vector< long double > >::iterator"""
        return _pypl.LongDoubleVectorVector_end(self)

    def rbegin(self):
        """rbegin(LongDoubleVectorVector self) -> std::vector< std::vector< long double > >::reverse_iterator"""
        return _pypl.LongDoubleVectorVector_rbegin(self)

    def rend(self):
        """rend(LongDoubleVectorVector self) -> std::vector< std::vector< long double > >::reverse_iterator"""
        return _pypl.LongDoubleVectorVector_rend(self)

    def pop_back(self):
        """pop_back(LongDoubleVectorVector self)"""
        return _pypl.LongDoubleVectorVector_pop_back(self)

    def erase(self, *args):
        """
        erase(LongDoubleVectorVector self, std::vector< std::vector< long double > >::iterator pos) -> std::vector< std::vector< long double > >::iterator
        erase(LongDoubleVectorVector self, std::vector< std::vector< long double > >::iterator first, std::vector< std::vector< long double > >::iterator last) -> std::vector< std::vector< long double > >::iterator
        """
        return _pypl.LongDoubleVectorVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(std::vector<(long double)>)> self) -> LongDoubleVectorVector
        __init__(std::vector<(std::vector<(long double)>)> self, LongDoubleVectorVector arg2) -> LongDoubleVectorVector
        __init__(std::vector<(std::vector<(long double)>)> self, std::vector< std::vector< long double > >::size_type size) -> LongDoubleVectorVector
        __init__(std::vector<(std::vector<(long double)>)> self, std::vector< std::vector< long double > >::size_type size, LongDoubleVector value) -> LongDoubleVectorVector
        """
        this = _pypl.new_LongDoubleVectorVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(LongDoubleVectorVector self, LongDoubleVector x)"""
        return _pypl.LongDoubleVectorVector_push_back(self, *args)

    def front(self):
        """front(LongDoubleVectorVector self) -> LongDoubleVector"""
        return _pypl.LongDoubleVectorVector_front(self)

    def back(self):
        """back(LongDoubleVectorVector self) -> LongDoubleVector"""
        return _pypl.LongDoubleVectorVector_back(self)

    def assign(self, *args):
        """assign(LongDoubleVectorVector self, std::vector< std::vector< long double > >::size_type n, LongDoubleVector x)"""
        return _pypl.LongDoubleVectorVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(LongDoubleVectorVector self, std::vector< std::vector< long double > >::size_type new_size)
        resize(LongDoubleVectorVector self, std::vector< std::vector< long double > >::size_type new_size, LongDoubleVector x)
        """
        return _pypl.LongDoubleVectorVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(LongDoubleVectorVector self, std::vector< std::vector< long double > >::iterator pos, LongDoubleVector x) -> std::vector< std::vector< long double > >::iterator
        insert(LongDoubleVectorVector self, std::vector< std::vector< long double > >::iterator pos, std::vector< std::vector< long double > >::size_type n, 
            LongDoubleVector x)
        """
        return _pypl.LongDoubleVectorVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(LongDoubleVectorVector self, std::vector< std::vector< long double > >::size_type n)"""
        return _pypl.LongDoubleVectorVector_reserve(self, *args)

    def capacity(self):
        """capacity(LongDoubleVectorVector self) -> std::vector< std::vector< long double > >::size_type"""
        return _pypl.LongDoubleVectorVector_capacity(self)

    __swig_destroy__ = _pypl.delete_LongDoubleVectorVector
    __del__ = lambda self : None;
LongDoubleVectorVector_swigregister = _pypl.LongDoubleVectorVector_swigregister
LongDoubleVectorVector_swigregister(LongDoubleVectorVector)

class LongDoubleVectorVectorVector(_object):
    """Proxy of C++ std::vector<(std::vector<(std::vector<(long double)>)>)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LongDoubleVectorVectorVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LongDoubleVectorVectorVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(LongDoubleVectorVectorVector self) -> SwigPyIterator"""
        return _pypl.LongDoubleVectorVectorVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(LongDoubleVectorVectorVector self) -> bool"""
        return _pypl.LongDoubleVectorVectorVector___nonzero__(self)

    def __bool__(self):
        """__bool__(LongDoubleVectorVectorVector self) -> bool"""
        return _pypl.LongDoubleVectorVectorVector___bool__(self)

    def __len__(self):
        """__len__(LongDoubleVectorVectorVector self) -> std::vector< std::vector< std::vector< long double > > >::size_type"""
        return _pypl.LongDoubleVectorVectorVector___len__(self)

    def pop(self):
        """pop(LongDoubleVectorVectorVector self) -> LongDoubleVectorVector"""
        return _pypl.LongDoubleVectorVectorVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(LongDoubleVectorVectorVector self, std::vector< std::vector< std::vector< long double > > >::difference_type i, std::vector< std::vector< std::vector< long double > > >::difference_type j) -> LongDoubleVectorVectorVector"""
        return _pypl.LongDoubleVectorVectorVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(LongDoubleVectorVectorVector self, std::vector< std::vector< std::vector< long double > > >::difference_type i, std::vector< std::vector< std::vector< long double > > >::difference_type j, 
            LongDoubleVectorVectorVector v=std::vector< std::vector< std::vector< long double,std::allocator< long double > >,std::allocator< std::vector< long double,std::allocator< long double > > > >,std::allocator< std::vector< std::vector< long double,std::allocator< long double > >,std::allocator< std::vector< long double,std::allocator< long double > > > > > >())
        __setslice__(LongDoubleVectorVectorVector self, std::vector< std::vector< std::vector< long double > > >::difference_type i, std::vector< std::vector< std::vector< long double > > >::difference_type j)
        """
        return _pypl.LongDoubleVectorVectorVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(LongDoubleVectorVectorVector self, std::vector< std::vector< std::vector< long double > > >::difference_type i, std::vector< std::vector< std::vector< long double > > >::difference_type j)"""
        return _pypl.LongDoubleVectorVectorVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(LongDoubleVectorVectorVector self, std::vector< std::vector< std::vector< long double > > >::difference_type i)
        __delitem__(LongDoubleVectorVectorVector self, PySliceObject * slice)
        """
        return _pypl.LongDoubleVectorVectorVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(LongDoubleVectorVectorVector self, PySliceObject * slice) -> LongDoubleVectorVectorVector
        __getitem__(LongDoubleVectorVectorVector self, std::vector< std::vector< std::vector< long double > > >::difference_type i) -> LongDoubleVectorVector
        """
        return _pypl.LongDoubleVectorVectorVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(LongDoubleVectorVectorVector self, PySliceObject * slice, LongDoubleVectorVectorVector v)
        __setitem__(LongDoubleVectorVectorVector self, PySliceObject * slice)
        __setitem__(LongDoubleVectorVectorVector self, std::vector< std::vector< std::vector< long double > > >::difference_type i, LongDoubleVectorVector x)
        """
        return _pypl.LongDoubleVectorVectorVector___setitem__(self, *args)

    def append(self, *args):
        """append(LongDoubleVectorVectorVector self, LongDoubleVectorVector x)"""
        return _pypl.LongDoubleVectorVectorVector_append(self, *args)

    def empty(self):
        """empty(LongDoubleVectorVectorVector self) -> bool"""
        return _pypl.LongDoubleVectorVectorVector_empty(self)

    def size(self):
        """size(LongDoubleVectorVectorVector self) -> std::vector< std::vector< std::vector< long double > > >::size_type"""
        return _pypl.LongDoubleVectorVectorVector_size(self)

    def clear(self):
        """clear(LongDoubleVectorVectorVector self)"""
        return _pypl.LongDoubleVectorVectorVector_clear(self)

    def swap(self, *args):
        """swap(LongDoubleVectorVectorVector self, LongDoubleVectorVectorVector v)"""
        return _pypl.LongDoubleVectorVectorVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(LongDoubleVectorVectorVector self) -> std::vector< std::vector< std::vector< long double > > >::allocator_type"""
        return _pypl.LongDoubleVectorVectorVector_get_allocator(self)

    def begin(self):
        """begin(LongDoubleVectorVectorVector self) -> std::vector< std::vector< std::vector< long double > > >::iterator"""
        return _pypl.LongDoubleVectorVectorVector_begin(self)

    def end(self):
        """end(LongDoubleVectorVectorVector self) -> std::vector< std::vector< std::vector< long double > > >::iterator"""
        return _pypl.LongDoubleVectorVectorVector_end(self)

    def rbegin(self):
        """rbegin(LongDoubleVectorVectorVector self) -> std::vector< std::vector< std::vector< long double > > >::reverse_iterator"""
        return _pypl.LongDoubleVectorVectorVector_rbegin(self)

    def rend(self):
        """rend(LongDoubleVectorVectorVector self) -> std::vector< std::vector< std::vector< long double > > >::reverse_iterator"""
        return _pypl.LongDoubleVectorVectorVector_rend(self)

    def pop_back(self):
        """pop_back(LongDoubleVectorVectorVector self)"""
        return _pypl.LongDoubleVectorVectorVector_pop_back(self)

    def erase(self, *args):
        """
        erase(LongDoubleVectorVectorVector self, std::vector< std::vector< std::vector< long double > > >::iterator pos) -> std::vector< std::vector< std::vector< long double > > >::iterator
        erase(LongDoubleVectorVectorVector self, std::vector< std::vector< std::vector< long double > > >::iterator first, std::vector< std::vector< std::vector< long double > > >::iterator last) -> std::vector< std::vector< std::vector< long double > > >::iterator
        """
        return _pypl.LongDoubleVectorVectorVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(std::vector<(std::vector<(long double)>)>)> self) -> LongDoubleVectorVectorVector
        __init__(std::vector<(std::vector<(std::vector<(long double)>)>)> self, LongDoubleVectorVectorVector arg2) -> LongDoubleVectorVectorVector
        __init__(std::vector<(std::vector<(std::vector<(long double)>)>)> self, std::vector< std::vector< std::vector< long double > > >::size_type size) -> LongDoubleVectorVectorVector
        __init__(std::vector<(std::vector<(std::vector<(long double)>)>)> self, std::vector< std::vector< std::vector< long double > > >::size_type size, LongDoubleVectorVector value) -> LongDoubleVectorVectorVector
        """
        this = _pypl.new_LongDoubleVectorVectorVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(LongDoubleVectorVectorVector self, LongDoubleVectorVector x)"""
        return _pypl.LongDoubleVectorVectorVector_push_back(self, *args)

    def front(self):
        """front(LongDoubleVectorVectorVector self) -> LongDoubleVectorVector"""
        return _pypl.LongDoubleVectorVectorVector_front(self)

    def back(self):
        """back(LongDoubleVectorVectorVector self) -> LongDoubleVectorVector"""
        return _pypl.LongDoubleVectorVectorVector_back(self)

    def assign(self, *args):
        """assign(LongDoubleVectorVectorVector self, std::vector< std::vector< std::vector< long double > > >::size_type n, LongDoubleVectorVector x)"""
        return _pypl.LongDoubleVectorVectorVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(LongDoubleVectorVectorVector self, std::vector< std::vector< std::vector< long double > > >::size_type new_size)
        resize(LongDoubleVectorVectorVector self, std::vector< std::vector< std::vector< long double > > >::size_type new_size, LongDoubleVectorVector x)
        """
        return _pypl.LongDoubleVectorVectorVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(LongDoubleVectorVectorVector self, std::vector< std::vector< std::vector< long double > > >::iterator pos, LongDoubleVectorVector x) -> std::vector< std::vector< std::vector< long double > > >::iterator
        insert(LongDoubleVectorVectorVector self, std::vector< std::vector< std::vector< long double > > >::iterator pos, std::vector< std::vector< std::vector< long double > > >::size_type n, 
            LongDoubleVectorVector x)
        """
        return _pypl.LongDoubleVectorVectorVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(LongDoubleVectorVectorVector self, std::vector< std::vector< std::vector< long double > > >::size_type n)"""
        return _pypl.LongDoubleVectorVectorVector_reserve(self, *args)

    def capacity(self):
        """capacity(LongDoubleVectorVectorVector self) -> std::vector< std::vector< std::vector< long double > > >::size_type"""
        return _pypl.LongDoubleVectorVectorVector_capacity(self)

    __swig_destroy__ = _pypl.delete_LongDoubleVectorVectorVector
    __del__ = lambda self : None;
LongDoubleVectorVectorVector_swigregister = _pypl.LongDoubleVectorVectorVector_swigregister
LongDoubleVectorVectorVector_swigregister(LongDoubleVectorVectorVector)

class LongIntVector(_object):
    """Proxy of C++ std::vector<(long)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LongIntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LongIntVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(LongIntVector self) -> SwigPyIterator"""
        return _pypl.LongIntVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(LongIntVector self) -> bool"""
        return _pypl.LongIntVector___nonzero__(self)

    def __bool__(self):
        """__bool__(LongIntVector self) -> bool"""
        return _pypl.LongIntVector___bool__(self)

    def __len__(self):
        """__len__(LongIntVector self) -> std::vector< long >::size_type"""
        return _pypl.LongIntVector___len__(self)

    def pop(self):
        """pop(LongIntVector self) -> std::vector< long >::value_type"""
        return _pypl.LongIntVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(LongIntVector self, std::vector< long >::difference_type i, std::vector< long >::difference_type j) -> LongIntVector"""
        return _pypl.LongIntVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(LongIntVector self, std::vector< long >::difference_type i, std::vector< long >::difference_type j, LongIntVector v=std::vector< long,std::allocator< long > >())
        __setslice__(LongIntVector self, std::vector< long >::difference_type i, std::vector< long >::difference_type j)
        """
        return _pypl.LongIntVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(LongIntVector self, std::vector< long >::difference_type i, std::vector< long >::difference_type j)"""
        return _pypl.LongIntVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(LongIntVector self, std::vector< long >::difference_type i)
        __delitem__(LongIntVector self, PySliceObject * slice)
        """
        return _pypl.LongIntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(LongIntVector self, PySliceObject * slice) -> LongIntVector
        __getitem__(LongIntVector self, std::vector< long >::difference_type i) -> std::vector< long >::value_type const &
        """
        return _pypl.LongIntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(LongIntVector self, PySliceObject * slice, LongIntVector v)
        __setitem__(LongIntVector self, PySliceObject * slice)
        __setitem__(LongIntVector self, std::vector< long >::difference_type i, std::vector< long >::value_type const & x)
        """
        return _pypl.LongIntVector___setitem__(self, *args)

    def append(self, *args):
        """append(LongIntVector self, std::vector< long >::value_type const & x)"""
        return _pypl.LongIntVector_append(self, *args)

    def empty(self):
        """empty(LongIntVector self) -> bool"""
        return _pypl.LongIntVector_empty(self)

    def size(self):
        """size(LongIntVector self) -> std::vector< long >::size_type"""
        return _pypl.LongIntVector_size(self)

    def clear(self):
        """clear(LongIntVector self)"""
        return _pypl.LongIntVector_clear(self)

    def swap(self, *args):
        """swap(LongIntVector self, LongIntVector v)"""
        return _pypl.LongIntVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(LongIntVector self) -> std::vector< long >::allocator_type"""
        return _pypl.LongIntVector_get_allocator(self)

    def begin(self):
        """begin(LongIntVector self) -> std::vector< long >::iterator"""
        return _pypl.LongIntVector_begin(self)

    def end(self):
        """end(LongIntVector self) -> std::vector< long >::iterator"""
        return _pypl.LongIntVector_end(self)

    def rbegin(self):
        """rbegin(LongIntVector self) -> std::vector< long >::reverse_iterator"""
        return _pypl.LongIntVector_rbegin(self)

    def rend(self):
        """rend(LongIntVector self) -> std::vector< long >::reverse_iterator"""
        return _pypl.LongIntVector_rend(self)

    def pop_back(self):
        """pop_back(LongIntVector self)"""
        return _pypl.LongIntVector_pop_back(self)

    def erase(self, *args):
        """
        erase(LongIntVector self, std::vector< long >::iterator pos) -> std::vector< long >::iterator
        erase(LongIntVector self, std::vector< long >::iterator first, std::vector< long >::iterator last) -> std::vector< long >::iterator
        """
        return _pypl.LongIntVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(long)> self) -> LongIntVector
        __init__(std::vector<(long)> self, LongIntVector arg2) -> LongIntVector
        __init__(std::vector<(long)> self, std::vector< long >::size_type size) -> LongIntVector
        __init__(std::vector<(long)> self, std::vector< long >::size_type size, std::vector< long >::value_type const & value) -> LongIntVector
        """
        this = _pypl.new_LongIntVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(LongIntVector self, std::vector< long >::value_type const & x)"""
        return _pypl.LongIntVector_push_back(self, *args)

    def front(self):
        """front(LongIntVector self) -> std::vector< long >::value_type const &"""
        return _pypl.LongIntVector_front(self)

    def back(self):
        """back(LongIntVector self) -> std::vector< long >::value_type const &"""
        return _pypl.LongIntVector_back(self)

    def assign(self, *args):
        """assign(LongIntVector self, std::vector< long >::size_type n, std::vector< long >::value_type const & x)"""
        return _pypl.LongIntVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(LongIntVector self, std::vector< long >::size_type new_size)
        resize(LongIntVector self, std::vector< long >::size_type new_size, std::vector< long >::value_type const & x)
        """
        return _pypl.LongIntVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(LongIntVector self, std::vector< long >::iterator pos, std::vector< long >::value_type const & x) -> std::vector< long >::iterator
        insert(LongIntVector self, std::vector< long >::iterator pos, std::vector< long >::size_type n, std::vector< long >::value_type const & x)
        """
        return _pypl.LongIntVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(LongIntVector self, std::vector< long >::size_type n)"""
        return _pypl.LongIntVector_reserve(self, *args)

    def capacity(self):
        """capacity(LongIntVector self) -> std::vector< long >::size_type"""
        return _pypl.LongIntVector_capacity(self)

    __swig_destroy__ = _pypl.delete_LongIntVector
    __del__ = lambda self : None;
LongIntVector_swigregister = _pypl.LongIntVector_swigregister
LongIntVector_swigregister(LongIntVector)

plProbValueVector = DoubleVector; 
def display(c):
  s = "[ "
  for x in range(c.size()):
    s = s + str(c[x]) 
    if x<c.size()-1:
      s = s + ", "
  s = s +  " ]"
  return s

IntVector.__repr__ = display
UnsignedIntVector.__repr__ = display
StringVector.__repr__ = display
BoolVector.__repr__ = display

FloatVector.__repr__ = display
FloatVectorVector. __repr__ = display
FloatVectorVectorVector.__repr__ = display

DoubleVector.__repr__ = display
DoubleVectorVector. __repr__ = display
DoubleVectorVectorVector.__repr__ = display

IntVector.__str__ = display
UnsignedIntVector.__str__ = display
StringVector.__str__ = display
BoolVector.__str__ = display

FloatVector.__str__ = display
FloatVectorVector. __str__ = display
FloatVectorVectorVector.__str__ = display

DoubleVector.__str__ = display
DoubleVectorVector. __str__ = display
DoubleVectorVectorVector.__str__ = display

LongIntVector.__str__ = display


display = None

class plObject(_object):
    """Proxy of C++ plObject class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plObject, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plObject
    __del__ = lambda self : None;
    def to_string(self, s=None):
        """
        to_string(plObject self, std::ostringstream * s=None) -> std::string
        to_string(plObject self) -> std::string
        """
        return _pypl.plObject_to_string(self, s)

plObject_swigregister = _pypl.plObject_swigregister
plObject_swigregister(plObject)

class plBuiltinModel(plObject):
    """Proxy of C++ plBuiltinModel class"""
    __swig_setmethods__ = {}
    for _s in [plObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plBuiltinModel, name, value)
    __swig_getmethods__ = {}
    for _s in [plObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plBuiltinModel, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plBuiltinModel
    __del__ = lambda self : None;
plBuiltinModel_swigregister = _pypl.plBuiltinModel_swigregister
plBuiltinModel_swigregister(plBuiltinModel)

class plSampleSpaceObject(plObject):
    """Proxy of C++ plSampleSpaceObject class"""
    __swig_setmethods__ = {}
    for _s in [plObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plSampleSpaceObject, name, value)
    __swig_getmethods__ = {}
    for _s in [plObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plSampleSpaceObject, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plSampleSpaceObject
    __del__ = lambda self : None;
plSampleSpaceObject_swigregister = _pypl.plSampleSpaceObject_swigregister
plSampleSpaceObject_swigregister(plSampleSpaceObject)

class plUserFunction(plObject):
    """Proxy of C++ plUserFunction class"""
    __swig_setmethods__ = {}
    for _s in [plObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plUserFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [plObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plUserFunction, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plUserFunction
    __del__ = lambda self : None;
plUserFunction_swigregister = _pypl.plUserFunction_swigregister
plUserFunction_swigregister(plUserFunction)

plObject.__str__ = plObject.to_string;
plObject.__repr__ = plObject.__str__;

class plError(plObject,):
    """Proxy of C++ plError class"""
    __swig_setmethods__ = {}
    for _s in [plObject,]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plError, name, value)
    __swig_getmethods__ = {}
    for _s in [plObject,]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plError, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plError self) -> plError
        __init__(plError self, unsigned int error_id) -> plError
        __init__(plError self, unsigned int error_id, std::string const & additional_info) -> plError
        """
        this = _pypl.new_plError(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plError
    __del__ = lambda self : None;
    def what(self):
        """what(plError self) -> char const *"""
        return _pypl.plError_what(self)

    def display(self):
        """
        display(plError self)
        display(plError self)
        """
        return _pypl.plError_display(self)

    def get_error_number(self):
        """get_error_number(plError self) -> unsigned int"""
        return _pypl.plError_get_error_number(self)

    def always_display(*args):
        """always_display(bool display_flag)"""
        return _pypl.plError_always_display(*args)

    if _newclass:always_display = staticmethod(always_display)
    __swig_getmethods__["always_display"] = lambda x: always_display
    def ignore_this_message(*args):
        """ignore_this_message(unsigned int id_message, bool ignoring_state)"""
        return _pypl.plError_ignore_this_message(*args)

    if _newclass:ignore_this_message = staticmethod(ignore_this_message)
    __swig_getmethods__["ignore_this_message"] = lambda x: ignore_this_message
    def message_is_ignored(*args):
        """message_is_ignored(unsigned int id_message) -> bool"""
        return _pypl.plError_message_is_ignored(*args)

    if _newclass:message_is_ignored = staticmethod(message_is_ignored)
    __swig_getmethods__["message_is_ignored"] = lambda x: message_is_ignored
    def always_display_warning(*args):
        """always_display_warning(bool display_flag)"""
        return _pypl.plError_always_display_warning(*args)

    if _newclass:always_display_warning = staticmethod(always_display_warning)
    __swig_getmethods__["always_display_warning"] = lambda x: always_display_warning
    def abort_in_warning(*args):
        """abort_in_warning(bool wie_flag)"""
        return _pypl.plError_abort_in_warning(*args)

    if _newclass:abort_in_warning = staticmethod(abort_in_warning)
    __swig_getmethods__["abort_in_warning"] = lambda x: abort_in_warning
    def treat_warnings_as_errors(wie_flag=True):
        """
        treat_warnings_as_errors(bool wie_flag=True)
        treat_warnings_as_errors()
        """
        return _pypl.plError_treat_warnings_as_errors(wie_flag)

    if _newclass:treat_warnings_as_errors = staticmethod(treat_warnings_as_errors)
    __swig_getmethods__["treat_warnings_as_errors"] = lambda x: treat_warnings_as_errors
    def treat_this_warning_as_error(*args):
        """
        treat_this_warning_as_error(unsigned int id_warning, bool wae_flag=True)
        treat_this_warning_as_error(unsigned int id_warning)
        """
        return _pypl.plError_treat_this_warning_as_error(*args)

    if _newclass:treat_this_warning_as_error = staticmethod(treat_this_warning_as_error)
    __swig_getmethods__["treat_this_warning_as_error"] = lambda x: treat_this_warning_as_error
    def warn(*args):
        """
        warn(unsigned int error_id)
        warn(unsigned int error_id, std::string const & additional_info)
        """
        return _pypl.plError_warn(*args)

    if _newclass:warn = staticmethod(warn)
    __swig_getmethods__["warn"] = lambda x: warn
    def get_main_message(self):
        """get_main_message(plError self) -> std::string"""
        return _pypl.plError_get_main_message(self)

    def get_additional_info(self):
        """get_additional_info(plError self) -> std::string const &"""
        return _pypl.plError_get_additional_info(self)

    def set_output_stream():
        """set_output_stream()"""
        return _pypl.plError_set_output_stream()

    if _newclass:set_output_stream = staticmethod(set_output_stream)
    __swig_getmethods__["set_output_stream"] = lambda x: set_output_stream
plError_swigregister = _pypl.plError_swigregister
plError_swigregister(plError)

def plError_always_display(*args):
  """plError_always_display(bool display_flag)"""
  return _pypl.plError_always_display(*args)

def plError_ignore_this_message(*args):
  """plError_ignore_this_message(unsigned int id_message, bool ignoring_state)"""
  return _pypl.plError_ignore_this_message(*args)

def plError_message_is_ignored(*args):
  """plError_message_is_ignored(unsigned int id_message) -> bool"""
  return _pypl.plError_message_is_ignored(*args)

def plError_always_display_warning(*args):
  """plError_always_display_warning(bool display_flag)"""
  return _pypl.plError_always_display_warning(*args)

def plError_abort_in_warning(*args):
  """plError_abort_in_warning(bool wie_flag)"""
  return _pypl.plError_abort_in_warning(*args)

def plError_treat_warnings_as_errors(wie_flag=True):
  """
    treat_warnings_as_errors(bool wie_flag=True)
    plError_treat_warnings_as_errors()
    """
  return _pypl.plError_treat_warnings_as_errors(wie_flag)

def plError_treat_this_warning_as_error(*args):
  """
    treat_this_warning_as_error(unsigned int id_warning, bool wae_flag=True)
    plError_treat_this_warning_as_error(unsigned int id_warning)
    """
  return _pypl.plError_treat_this_warning_as_error(*args)

def plError_warn(*args):
  """
    warn(unsigned int error_id)
    plError_warn(unsigned int error_id, std::string const & additional_info)
    """
  return _pypl.plError_warn(*args)

def plError_set_output_stream():
  """plError_set_output_stream()"""
  return _pypl.plError_set_output_stream()

class plIgnoreMessage(_object):
    """Proxy of C++ plIgnoreMessage class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plIgnoreMessage, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plIgnoreMessage, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(plIgnoreMessage self, unsigned int id) -> plIgnoreMessage"""
        this = _pypl.new_plIgnoreMessage(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plIgnoreMessage
    __del__ = lambda self : None;
plIgnoreMessage_swigregister = _pypl.plIgnoreMessage_swigregister
plIgnoreMessage_swigregister(plIgnoreMessage)


def get_most_derived(*args):
  """get_most_derived(plObject obj) -> PyObject *"""
  return _pypl.get_most_derived(*args)

def plRandomInt(*args):
  """plRandomInt(unsigned int max) -> unsigned int"""
  return _pypl.plRandomInt(*args)

def plRandomFloat(*args):
  """plRandomFloat(plFloat max) -> plFloat"""
  return _pypl.plRandomFloat(*args)

def plSRandom(*args):
  """plSRandom(int seed)"""
  return _pypl.plSRandom(*args)

def plNormalRandom(*args):
  """
    plNormalRandom(plFloat m, plFloat sd) -> plFloat
    plNormalRandom(plFloat m, plFloat sd, plFloat a, plFloat b) -> plFloat
    """
  return _pypl.plNormalRandom(*args)

def plNormalRandomUsingInvPhi(*args):
  """plNormalRandomUsingInvPhi(plFloat m, plFloat sd, plFloat two_inta_minus_half, plFloat two_intb_minus_half) -> plFloat"""
  return _pypl.plNormalRandomUsingInvPhi(*args)

def plHalfNormalRandom(*args):
  """plHalfNormalRandom(plFloat m, plFloat sd) -> plFloat"""
  return _pypl.plHalfNormalRandom(*args)
class plRandom(_object):
    """Proxy of C++ plRandom class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plRandom, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plRandom, name)
    __repr__ = _swig_repr
    def seed(*args):
        """seed(int seed_value)"""
        return _pypl.plRandom_seed(*args)

    if _newclass:seed = staticmethod(seed)
    __swig_getmethods__["seed"] = lambda x: seed
    def uniform_integer(*args):
        """uniform_integer(unsigned int max) -> unsigned int"""
        return _pypl.plRandom_uniform_integer(*args)

    if _newclass:uniform_integer = staticmethod(uniform_integer)
    __swig_getmethods__["uniform_integer"] = lambda x: uniform_integer
    def uniform_float(*args):
        """uniform_float(plFloat max) -> plFloat"""
        return _pypl.plRandom_uniform_float(*args)

    if _newclass:uniform_float = staticmethod(uniform_float)
    __swig_getmethods__["uniform_float"] = lambda x: uniform_float
    def normal_float(*args):
        """
        normal_float(plFloat m, plFloat sd) -> plFloat
        normal_float(plFloat m, plFloat sd, plFloat a, plFloat b) -> plFloat
        """
        return _pypl.plRandom_normal_float(*args)

    if _newclass:normal_float = staticmethod(normal_float)
    __swig_getmethods__["normal_float"] = lambda x: normal_float
    def __init__(self): 
        """__init__(plRandom self) -> plRandom"""
        this = _pypl.new_plRandom()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plRandom
    __del__ = lambda self : None;
plRandom_swigregister = _pypl.plRandom_swigregister
plRandom_swigregister(plRandom)

def plRandom_seed(*args):
  """plRandom_seed(int seed_value)"""
  return _pypl.plRandom_seed(*args)

def plRandom_uniform_integer(*args):
  """plRandom_uniform_integer(unsigned int max) -> unsigned int"""
  return _pypl.plRandom_uniform_integer(*args)

def plRandom_uniform_float(*args):
  """plRandom_uniform_float(plFloat max) -> plFloat"""
  return _pypl.plRandom_uniform_float(*args)

def plRandom_normal_float(*args):
  """
    normal_float(plFloat m, plFloat sd) -> plFloat
    plRandom_normal_float(plFloat m, plFloat sd, plFloat a, plFloat b) -> plFloat
    """
  return _pypl.plRandom_normal_float(*args)

class plFloatMatrix(plObject):
    """Proxy of C++ plFloatMatrix class"""
    __swig_setmethods__ = {}
    for _s in [plObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plFloatMatrix, name, value)
    __swig_getmethods__ = {}
    for _s in [plObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plFloatMatrix, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plFloatMatrix self) -> plFloatMatrix
        __init__(plFloatMatrix self, size_t r, size_t c) -> plFloatMatrix
        __init__(plFloatMatrix self, size_t d) -> plFloatMatrix
        __init__(plFloatMatrix self, size_t d, double const * float_vector) -> plFloatMatrix
        __init__(plFloatMatrix self, size_t d, float const * float_vector) -> plFloatMatrix
        __init__(plFloatMatrix self, size_t d, long double const * float_vector) -> plFloatMatrix
        __init__(plFloatMatrix self, DoubleVector float_vector) -> plFloatMatrix
        __init__(plFloatMatrix self, FloatVector float_vector) -> plFloatMatrix
        __init__(plFloatMatrix self, LongDoubleVector float_vector) -> plFloatMatrix
        __init__(plFloatMatrix self, DoubleVectorVector stl_matrix) -> plFloatMatrix
        __init__(plFloatMatrix self, FloatVectorVector stl_matrix) -> plFloatMatrix
        __init__(plFloatMatrix self, LongDoubleVectorVector stl_matrix) -> plFloatMatrix
        __init__(plFloatMatrix self, plFloatMatrix arg2) -> plFloatMatrix
        """
        this = _pypl.new_plFloatMatrix(*args)
        try: self.this.append(this)
        except: self.this = this
    def make_diagonal(self, *args):
        """make_diagonal(plFloatMatrix self, plFloatVector diag_vector)"""
        return _pypl.plFloatMatrix_make_diagonal(self, *args)

    def make_identity(self, *args):
        """make_identity(plFloatMatrix self, size_t n)"""
        return _pypl.plFloatMatrix_make_identity(self, *args)

    def resize(self, *args):
        """
        resize(plFloatMatrix self, size_t nr, size_t nc)
        resize(plFloatMatrix self, size_t n)
        """
        return _pypl.plFloatMatrix_resize(self, *args)

    __swig_destroy__ = _pypl.delete_plFloatMatrix
    __del__ = lambda self : None;
    def rows(self):
        """rows(plFloatMatrix self) -> size_t"""
        return _pypl.plFloatMatrix_rows(self)

    def cols(self):
        """cols(plFloatMatrix self) -> size_t"""
        return _pypl.plFloatMatrix_cols(self)

    def at(self, *args):
        """
        at(plFloatMatrix self, size_t r, size_t c) -> plFloat
        at(plFloatMatrix self, size_t r, size_t c) -> plFloat &
        """
        return _pypl.plFloatMatrix_at(self, *args)

    def set_value(self, *args):
        """set_value(plFloatMatrix self, size_t const & r, size_t const & c, plFloat const & v)"""
        return _pypl.plFloatMatrix_set_value(self, *args)

    def get_value(self, *args):
        """get_value(plFloatMatrix self, size_t const & r, size_t const & c) -> plFloat"""
        return _pypl.plFloatMatrix_get_value(self, *args)

    def row(self, *args):
        """row(plFloatMatrix self, size_t i) -> plFloatVector"""
        return _pypl.plFloatMatrix_row(self, *args)

    def column(self, *args):
        """column(plFloatMatrix self, size_t j) -> plFloatVector"""
        return _pypl.plFloatMatrix_column(self, *args)

    def assign_from(self, *args):
        """assign_from(plFloatMatrix self, plFloatMatrix other) -> plFloatMatrix"""
        return _pypl.plFloatMatrix_assign_from(self, *args)

    def __add__(self, *args):
        """__add__(plFloatMatrix self, plFloatMatrix arg2) -> plFloatMatrix"""
        return _pypl.plFloatMatrix___add__(self, *args)

    def add(self, *args):
        """add(plFloatMatrix self, plFloatMatrix other) -> plFloatMatrix"""
        return _pypl.plFloatMatrix_add(self, *args)

    def __iadd__(self, *args):
        """__iadd__(plFloatMatrix self, plFloatMatrix arg2) -> plFloatMatrix"""
        return _pypl.plFloatMatrix___iadd__(self, *args)

    def add_in_place(self, *args):
        """add_in_place(plFloatMatrix self, plFloatMatrix other) -> plFloatMatrix"""
        return _pypl.plFloatMatrix_add_in_place(self, *args)

    def __sub__(self, *args):
        """__sub__(plFloatMatrix self, plFloatMatrix arg2) -> plFloatMatrix"""
        return _pypl.plFloatMatrix___sub__(self, *args)

    def subtract(self, *args):
        """subtract(plFloatMatrix self, plFloatMatrix other) -> plFloatMatrix"""
        return _pypl.plFloatMatrix_subtract(self, *args)

    def __isub__(self, *args):
        """__isub__(plFloatMatrix self, plFloatMatrix arg2) -> plFloatMatrix"""
        return _pypl.plFloatMatrix___isub__(self, *args)

    def subtract_in_place(self, *args):
        """subtract_in_place(plFloatMatrix self, plFloatMatrix other) -> plFloatMatrix"""
        return _pypl.plFloatMatrix_subtract_in_place(self, *args)

    def __mul__(self, *args):
        """
        __mul__(plFloatMatrix self, plFloatMatrix arg2) -> plFloatMatrix
        __mul__(plFloatMatrix self, plFloatVector arg2) -> plFloatVector
        """
        return _pypl.plFloatMatrix___mul__(self, *args)

    def __eq__(self, *args):
        """__eq__(plFloatMatrix self, plFloatMatrix arg2) -> bool"""
        return _pypl.plFloatMatrix___eq__(self, *args)

    def equal(self, *args):
        """equal(plFloatMatrix self, plFloatMatrix other) -> bool"""
        return _pypl.plFloatMatrix_equal(self, *args)

    def transpose(self, *args):
        """
        transpose(plFloatMatrix self) -> plFloatMatrix
        transpose(plFloatMatrix self, plFloatMatrix result)
        """
        return _pypl.plFloatMatrix_transpose(self, *args)

    def trace(self):
        """trace(plFloatMatrix self) -> plFloat"""
        return _pypl.plFloatMatrix_trace(self)

    def inverse_using_greville(self, *args):
        """inverse_using_greville(plFloatMatrix self, plFloatMatrix inverse, plFloat threshold) -> unsigned int"""
        return _pypl.plFloatMatrix_inverse_using_greville(self, *args)

    def inverse_using_eigen_decomposition(self, *args):
        """
        inverse_using_eigen_decomposition(plFloatMatrix self, plFloatMatrix inverse) -> plFloat
        inverse_using_eigen_decomposition(plFloatMatrix self, plFloatMatrix inverse, plFloatMatrix mat_n_n_tmp1, plFloatMatrix mat_n_n_tmp2, plFloatVector vect_n_tmp) -> plFloat
        """
        return _pypl.plFloatMatrix_inverse_using_eigen_decomposition(self, *args)

    def compute_eigen_decomposition(self, *args):
        """compute_eigen_decomposition(plFloatMatrix self, plFloatMatrix Eigen_Matrix, plFloatVector Eigen_Vector)"""
        return _pypl.plFloatMatrix_compute_eigen_decomposition(self, *args)

    def reset(self, val=0.):
        """
        reset(plFloatMatrix self, plFloat val=0.)
        reset(plFloatMatrix self)
        """
        return _pypl.plFloatMatrix_reset(self, val)

    def is_empty(self):
        """is_empty(plFloatMatrix self) -> bool"""
        return _pypl.plFloatMatrix_is_empty(self)

    def multiply_with_transpose(self, *args):
        """multiply_with_transpose(plFloatMatrix self, plFloatMatrix other, plFloatMatrix result)"""
        return _pypl.plFloatMatrix_multiply_with_transpose(self, *args)

    def multiply_with_transpose_symmetric(self, *args):
        """multiply_with_transpose_symmetric(plFloatMatrix self, plFloatMatrix other, plFloatMatrix result)"""
        return _pypl.plFloatMatrix_multiply_with_transpose_symmetric(self, *args)

    def multiply(self, *args):
        """
        multiply(plFloatMatrix self, plFloatMatrix other, plFloatMatrix result)
        multiply(plFloatMatrix self, plFloatVector vect, plFloatVector result)
        """
        return _pypl.plFloatMatrix_multiply(self, *args)

    def multiply_transpose_with(self, *args):
        """
        multiply_transpose_with(plFloatMatrix self, plFloatMatrix other, plFloatMatrix result)
        multiply_transpose_with(plFloatMatrix self, plFloatVector vect, plFloatVector result)
        """
        return _pypl.plFloatMatrix_multiply_transpose_with(self, *args)

    def set(self, *args):
        """set(plFloatMatrix self, unsigned int r, unsigned int c, plFloat value)"""
        return _pypl.plFloatMatrix_set(self, *args)

    def __getitem__(self, *args):
        """__getitem__(plFloatMatrix self, PyObject * indices) -> plFloat"""
        return _pypl.plFloatMatrix___getitem__(self, *args)

    def __setitem__(self, *args):
        """__setitem__(plFloatMatrix self, PyObject * indices, plFloat value) -> void *"""
        return _pypl.plFloatMatrix___setitem__(self, *args)

plFloatMatrix_swigregister = _pypl.plFloatMatrix_swigregister
plFloatMatrix_swigregister(plFloatMatrix)

plFloatMatrix.__str__ = plFloatMatrix.to_string;
plFloatMatrix.__repr__ = plFloatMatrix.__str__;

try:
  import numpy;

  def plFloatMatrix_to_numpy( mat ):
    """
    Converts a plFloatMatrix to numpy 2D array 
    """
    npmat = numpy.zeros( (mat.rows(), mat.cols()) )
    for i in range(mat.rows()):
      for j in range(mat.cols()):
        npmat[i][j] = mat.at(i, j)
    return npmat

  plFloatMatrix.to_numpy = plFloatMatrix_to_numpy;


  def numpy_to_plFloatMatrix( a ):
    """
    Converts a numpy 2D array to plFloatMatrix
    """
    if type(a) != numpy.ndarray:
      raise TypeError(" Array is not of type numpy !")

    if a.ndim != 2:
      raise TypeError( "Array is not a 2D array ! ")

    v = plFloatMatrix( a.shape[0], a.shape[1]) 
    for i in range(a.shape[0]):
      for j in range(a.shape[1]):
        v.set( i, j, a[i][j] )
    return v

except ImportError:
  pass


class plFloatVector(plObject):
    """Proxy of C++ plFloatVector class"""
    __swig_setmethods__ = {}
    for _s in [plObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plFloatVector, name, value)
    __swig_getmethods__ = {}
    for _s in [plObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plFloatVector, name)
    __repr__ = _swig_repr
    def size(self):
        """size(plFloatVector self) -> size_t"""
        return _pypl.plFloatVector_size(self)

    def __init__(self, *args): 
        """
        __init__(plFloatVector self) -> plFloatVector
        __init__(plFloatVector self, size_t r, double val) -> plFloatVector
        __init__(plFloatVector self, size_t r, float val) -> plFloatVector
        __init__(plFloatVector self, size_t r, long double val) -> plFloatVector
        __init__(plFloatVector self, size_t r) -> plFloatVector
        __init__(plFloatVector self, size_t r, double const * float_vector) -> plFloatVector
        __init__(plFloatVector self, size_t r, float const * float_vector) -> plFloatVector
        __init__(plFloatVector self, size_t r, long double const * float_vector) -> plFloatVector
        __init__(plFloatVector self, DoubleVector float_vector) -> plFloatVector
        __init__(plFloatVector self, FloatVector float_vector) -> plFloatVector
        __init__(plFloatVector self, LongDoubleVector float_vector) -> plFloatVector
        __init__(plFloatVector self, plDataValues values) -> plFloatVector
        __init__(plFloatVector self, plFloatVector v2) -> plFloatVector
        """
        this = _pypl.new_plFloatVector(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plFloatVector
    __del__ = lambda self : None;
    def resize(self, *args):
        """resize(plFloatVector self, size_t r)"""
        return _pypl.plFloatVector_resize(self, *args)

    def assign_from(self, *args):
        """assign_from(plFloatVector self, plFloatVector other) -> plFloatVector"""
        return _pypl.plFloatVector_assign_from(self, *args)

    def __add__(self, *args):
        """__add__(plFloatVector self, plFloatVector arg2) -> plFloatVector"""
        return _pypl.plFloatVector___add__(self, *args)

    def add(self, *args):
        """add(plFloatVector self, plFloatVector other) -> plFloatVector"""
        return _pypl.plFloatVector_add(self, *args)

    def __iadd__(self, *args):
        """__iadd__(plFloatVector self, plFloatVector arg2) -> plFloatVector"""
        return _pypl.plFloatVector___iadd__(self, *args)

    def add_in_place(self, *args):
        """add_in_place(plFloatVector self, plFloatVector other) -> plFloatVector"""
        return _pypl.plFloatVector_add_in_place(self, *args)

    def __sub__(self, *args):
        """__sub__(plFloatVector self, plFloatVector arg2) -> plFloatVector"""
        return _pypl.plFloatVector___sub__(self, *args)

    def subtract(self, *args):
        """subtract(plFloatVector self, plFloatVector other) -> plFloatVector"""
        return _pypl.plFloatVector_subtract(self, *args)

    def __isub__(self, *args):
        """__isub__(plFloatVector self, plFloatVector arg2) -> plFloatVector"""
        return _pypl.plFloatVector___isub__(self, *args)

    def subtract_in_place(self, *args):
        """subtract_in_place(plFloatVector self, plFloatVector other) -> plFloatVector"""
        return _pypl.plFloatVector_subtract_in_place(self, *args)

    def __mul__(self, *args):
        """__mul__(plFloatVector self, plFloat arg2) -> plFloatVector"""
        return _pypl.plFloatVector___mul__(self, *args)

    def multiply(self, *args):
        """multiply(plFloatVector self, plFloat f) -> plFloatVector"""
        return _pypl.plFloatVector_multiply(self, *args)

    def __imul__(self, *args):
        """__imul__(plFloatVector self, plFloat f) -> plFloatVector"""
        return _pypl.plFloatVector___imul__(self, *args)

    def multiply_in_place(self, *args):
        """multiply_in_place(plFloatVector self, plFloat f) -> plFloatVector"""
        return _pypl.plFloatVector_multiply_in_place(self, *args)

    def __div__(self, *args):
        """__div__(plFloatVector self, plFloat arg2) -> plFloatVector"""
        return _pypl.plFloatVector___div__(self, *args)

    def divide(self, *args):
        """divide(plFloatVector self, plFloat f) -> plFloatVector"""
        return _pypl.plFloatVector_divide(self, *args)

    def __idiv__(self, *args):
        """__idiv__(plFloatVector self, plFloat f) -> plFloatVector"""
        return _pypl.plFloatVector___idiv__(self, *args)

    def divide_in_place(self, *args):
        """divide_in_place(plFloatVector self, plFloat f) -> plFloatVector"""
        return _pypl.plFloatVector_divide_in_place(self, *args)

    def at(self, *args):
        """
        at(plFloatVector self, size_t i) -> plFloat
        at(plFloatVector self, size_t i) -> plFloat &
        """
        return _pypl.plFloatVector_at(self, *args)

    def set_value(self, *args):
        """set_value(plFloatVector self, size_t const & i, plFloat const & val)"""
        return _pypl.plFloatVector_set_value(self, *args)

    def get_value(self, *args):
        """get_value(plFloatVector self, size_t i) -> plFloat"""
        return _pypl.plFloatVector_get_value(self, *args)

    def __eq__(self, *args):
        """__eq__(plFloatVector self, plFloatVector arg2) -> bool"""
        return _pypl.plFloatVector___eq__(self, *args)

    def equal(self, *args):
        """equal(plFloatVector self, plFloatVector other) -> bool"""
        return _pypl.plFloatVector_equal(self, *args)

    def dot_product(self, *args):
        """dot_product(plFloatVector self, plFloatVector a) -> plFloat"""
        return _pypl.plFloatVector_dot_product(self, *args)

    def cross_product(self, *args):
        """cross_product(plFloatVector self, plFloatVector a) -> plFloatVector"""
        return _pypl.plFloatVector_cross_product(self, *args)

    def normalize(self, *args):
        """normalize(plFloatVector self, plFloatVector result) -> plFloat"""
        return _pypl.plFloatVector_normalize(self, *args)

    def product(self):
        """product(plFloatVector self) -> plFloat"""
        return _pypl.plFloatVector_product(self)

    def reset(self, val=0.):
        """
        reset(plFloatVector self, plFloat val=0.)
        reset(plFloatVector self)
        """
        return _pypl.plFloatVector_reset(self, val)

    def is_empty(self):
        """is_empty(plFloatVector self) -> bool"""
        return _pypl.plFloatVector_is_empty(self)

    def data(self):
        """data(plFloatVector self) -> DoubleVector"""
        return _pypl.plFloatVector_data(self)

    def set(self, *args):
        """set(plFloatVector self, unsigned int i, plFloat value)"""
        return _pypl.plFloatVector_set(self, *args)

    def __setitem__(self, *args):
        """__setitem__(plFloatVector self, int i, plFloat value) -> void *"""
        return _pypl.plFloatVector___setitem__(self, *args)

plFloatVector_swigregister = _pypl.plFloatVector_swigregister
plFloatVector_swigregister(plFloatVector)

plFloatVector.__str__ = plFloatVector.to_string;
plFloatVector.__repr__ = plFloatVector.__str__;
plFloatVector.__getitem__ = plFloatVector.at;

try:

  def plFloatVector_to_numpy( vec ):
    """
    Converts a plFloatVector to a numpy 1D array 
    """
    n = numpy.zeros(vec.size())
    for i in range(vec.size()):
      n[i] = vec[i]
    return n;

  def numpy_to_plFloatVector( a ):
    """ Converts a numpy array to plFloatVector """
    if type(a) != numpy.ndarray:
      raise TypeError( "Array is not of type numpy !" )

    if a.ndim != 1:
      raise TypeError( "Array is not a one dimensional vector !")

    v = plFloatVector( a.size )
    for i in range(a.size):
      v[i] = a[i]
    return v;

  plFloatVector.to_numpy = plFloatVector_to_numpy;

except ImportError:
  pass


PL_INTEGER = _pypl.PL_INTEGER
PL_REAL = _pypl.PL_REAL
PL_CONTINUOUS_INTERVAL = _pypl.PL_CONTINUOUS_INTERVAL
PL_DISCRETE_INTERVAL = _pypl.PL_DISCRETE_INTERVAL
PL_LABEL = _pypl.PL_LABEL
PL_UNKNOWN_TYPE = _pypl.PL_UNKNOWN_TYPE
class plData(_object):
    """Proxy of C++ plData class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plData, name)
    __repr__ = _swig_repr
    kplNIL = _pypl.plData_kplNIL
    kplINTEGER = _pypl.plData_kplINTEGER
    kplFLOAT = _pypl.plData_kplFLOAT
    INT_INT = _pypl.plData_INT_INT
    INT_FLOAT = _pypl.plData_INT_FLOAT
    FLOAT_INT = _pypl.plData_FLOAT_INT
    FLOAT_FLOAT = _pypl.plData_FLOAT_FLOAT
    def __init__(self, *args): 
        """
        __init__(plData self) -> plData
        __init__(plData self, plData::plData_type type) -> plData
        __init__(plData self, plData other) -> plData
        """
        this = _pypl.new_plData(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plData
    __del__ = lambda self : None;
    def set(self, *args):
        """set(plData self, plData other)"""
        return _pypl.plData_set(self, *args)

    def equal(self, *args):
        """equal(plData self, plData data) -> bool"""
        return _pypl.plData_equal(self, *args)

    def not_equal(self, *args):
        """not_equal(plData self, plData data) -> bool"""
        return _pypl.plData_not_equal(self, *args)

    def greater(self, *args):
        """greater(plData self, plData data) -> bool"""
        return _pypl.plData_greater(self, *args)

    def less_or_equal(self, *args):
        """less_or_equal(plData self, plData data) -> bool"""
        return _pypl.plData_less_or_equal(self, *args)

    def less(self, *args):
        """less(plData self, plData data) -> bool"""
        return _pypl.plData_less(self, *args)

    def greater_or_equal(self, *args):
        """greater_or_equal(plData self, plData other) -> bool"""
        return _pypl.plData_greater_or_equal(self, *args)

    def __sub__(self, *args):
        """__sub__(plData self, plData data) -> plData"""
        return _pypl.plData___sub__(self, *args)

    def to_double(self):
        """to_double(plData self) -> double"""
        return _pypl.plData_to_double(self)

    def to_long_double(self):
        """to_long_double(plData self) -> long double"""
        return _pypl.plData_to_long_double(self)

    def __nonzero__(self):
        return _pypl.plData_to_bool(self)
    __bool__ = __nonzero__


    def to_int(self):
        """to_int(plData self) -> int"""
        return _pypl.plData_to_int(self)

    def to_unsigned_int(self):
        """to_unsigned_int(plData self) -> unsigned int"""
        return _pypl.plData_to_unsigned_int(self)

    def to_long_int(self):
        """to_long_int(plData self) -> long"""
        return _pypl.plData_to_long_int(self)

    def to_long_unsigned_int(self):
        """to_long_unsigned_int(plData self) -> unsigned long"""
        return _pypl.plData_to_long_unsigned_int(self)

    def Input(self, *args):
        """Input(plData self, std::istream & _in)"""
        return _pypl.plData_Input(self, *args)

    def _print(self):
        """_print(plData self)"""
        return _pypl.plData__print(self)

    def is_label(self):
        """is_label(plData self) -> bool"""
        return _pypl.plData_is_label(self)

    def get_data_type(self):
        """get_data_type(plData self) -> plData::plData_type"""
        return _pypl.plData_get_data_type(self)

    def as_int(self):
        """as_int(plData self) -> int"""
        return _pypl.plData_as_int(self)

    def as_double(self):
        """as_double(plData self) -> double"""
        return _pypl.plData_as_double(self)

    def as_label(self):
        """as_label(plData self) -> std::string"""
        return _pypl.plData_as_label(self)

    def set_data(self, *args):
        """
        set_data(plData self, plData data) -> plData
        set_data(plData self, std::string const & label) -> plData
        set_data(plData self, char const * label) -> plData
        set_data(plData self, bool const & number) -> plData
        set_data(plData self, int const & number) -> plData
        set_data(plData self, double const & number) -> plData
        """
        return _pypl.plData_set_data(self, *args)

    def __add__(self, *args):
        """
        __add__(plData self, plData data) -> plData
        __add__(plData self, int const & number) -> plData
        __add__(plData self, double const & number) -> plData
        """
        return _pypl.plData___add__(self, *args)

    def __mul__(self, *args):
        """
        __mul__(plData self, plData data) -> plData
        __mul__(plData self, int const & number) -> plData
        __mul__(plData self, double const & number) -> plData
        """
        return _pypl.plData___mul__(self, *args)

    def __div__(self, *args):
        """
        __div__(plData self, plData data) -> plData
        __div__(plData self, int const & number) -> plData
        __div__(plData self, double const & number) -> plData
        """
        return _pypl.plData___div__(self, *args)

    def __mod__(self, *args):
        """__mod__(plData self, int const & int_number) -> long"""
        return _pypl.plData___mod__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(plData self, plData data) -> bool
        __gt__(plData self, int const & number) -> bool
        __gt__(plData self, double const & number) -> bool
        """
        return _pypl.plData___gt__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(plData self, plData data) -> bool
        __lt__(plData self, int const & number) -> bool
        __lt__(plData self, double const & number) -> bool
        """
        return _pypl.plData___lt__(self, *args)

    def __eq__(self, *args):
        """
        __eq__(plData self, plData data) -> bool
        __eq__(plData self, int const & number) -> bool
        __eq__(plData self, double const & number) -> bool
        """
        return _pypl.plData___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(plData self, int const & other) -> bool
        __ne__(plData self, double const & other) -> bool
        """
        return _pypl.plData___ne__(self, *args)

    def __le__(self, *args):
        """
        __le__(plData self, int const & data) -> bool
        __le__(plData self, double const & data) -> bool
        """
        return _pypl.plData___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(plData self, int const & other) -> bool
        __ge__(plData self, double const & other) -> bool
        """
        return _pypl.plData___ge__(self, *args)

    def __neg__(self):
        """__neg__(plData self) -> plData"""
        return _pypl.plData___neg__(self)

    def __rmul__(self, *args):
        """
        __rmul__(plData self, double input) -> plData
        __rmul__(plData self, int input) -> plData
        """
        return _pypl.plData___rmul__(self, *args)

    def __radd__(self, *args):
        """
        __radd__(plData self, double input) -> plData
        __radd__(plData self, int input) -> plData
        """
        return _pypl.plData___radd__(self, *args)

    def __rdiv__(self, *args):
        """
        __rdiv__(plData self, double input) -> plData
        __rdiv__(plData self, int input) -> plData
        """
        return _pypl.plData___rdiv__(self, *args)

    def __rsub__(self, *args):
        """
        __rsub__(plData self, double input) -> plData
        __rsub__(plData self, int input) -> plData
        """
        return _pypl.plData___rsub__(self, *args)

    def __str__(self):
        """__str__(plData self) -> std::string"""
        return _pypl.plData___str__(self)

    def __float__(self):
        """__float__(plData self) -> double"""
        return _pypl.plData___float__(self)

    def __int__(self):
        """__int__(plData self) -> int"""
        return _pypl.plData___int__(self)

    def to_float(self, *args):
        """
        to_float(plData self) -> float
        to_float(plData self) -> double
        """
        return _pypl.plData_to_float(self, *args)

plData_swigregister = _pypl.plData_swigregister
plData_swigregister(plData)

plData.__repr__ = plData.__str__; 

class plType(plSampleSpaceObject):
    """Proxy of C++ plType class"""
    __swig_setmethods__ = {}
    for _s in [plSampleSpaceObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plType, name, value)
    __swig_getmethods__ = {}
    for _s in [plSampleSpaceObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plType, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plType self) -> plType
        __init__(plType self, plType other) -> plType
        """
        this = _pypl.new_plType(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plType
    __del__ = lambda self : None;
    def assign_from(self, *args):
        """assign_from(plType self, plType other) -> plType"""
        return _pypl.plType_assign_from(self, *args)

    def first_value(self):
        """first_value(plType self) -> plData"""
        return _pypl.plType_first_value(self)

    def get_min(self):
        """get_min(plType self) -> plData"""
        return _pypl.plType_get_min(self)

    def get_max(self):
        """get_max(plType self) -> plData"""
        return _pypl.plType_get_max(self)

    def next_value(self, *args):
        """next_value(plType self, plData v) -> bool"""
        return _pypl.plType_next_value(self, *args)

    def cardinality(self):
        """cardinality(plType self) -> unsigned int"""
        return _pypl.plType_cardinality(self)

    def get_var_type(self):
        """get_var_type(plType self) -> plVariableType"""
        return _pypl.plType_get_var_type(self)

    def value_is_valid(self, *args):
        """value_is_valid(plType self, plData v) -> bool"""
        return _pypl.plType_value_is_valid(self, *args)

    def is_empty(self):
        """is_empty(plType self) -> bool"""
        return _pypl.plType_is_empty(self)

    def get_value_from_index(self, *args):
        """get_value_from_index(plType self, unsigned int index) -> bool"""
        return _pypl.plType_get_value_from_index(self, *args)

    def get_random_value_from_index(self, *args):
        """get_random_value_from_index(plType self, unsigned int index) -> bool"""
        return _pypl.plType_get_random_value_from_index(self, *args)

    def get_values_as_strings(self):
        """get_values_as_strings(plType self) -> StringVector"""
        return _pypl.plType_get_values_as_strings(self)

    def __eq__(self, *args):
        """__eq__(plType self, plType other) -> bool"""
        return _pypl.plType___eq__(self, *args)

    def equal(self, *args):
        """equal(plType self, plType other) -> bool"""
        return _pypl.plType_equal(self, *args)

    def __ne__(self, *args):
        """__ne__(plType self, plType other) -> bool"""
        return _pypl.plType___ne__(self, *args)

    def not_equal(self, *args):
        """not_equal(plType self, plType other) -> bool"""
        return _pypl.plType_not_equal(self, *args)

    def next_value_double(self):
        """next_value_double(plType self) -> bool"""
        return _pypl.plType_next_value_double(self)

    def get_value_index(self, *args):
        """
        get_value_index(plType self, unsigned int & result, plData value) -> bool
        get_value_index(plType self, unsigned int & result, int const & value) -> bool
        get_value_index(plType self, unsigned int & result, double const & value) -> bool
        """
        return _pypl.plType_get_value_index(self, *args)

plType_swigregister = _pypl.plType_swigregister
plType_swigregister(plType)

class plDiscreteType(plType):
    """Proxy of C++ plDiscreteType class"""
    __swig_setmethods__ = {}
    for _s in [plType]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plDiscreteType, name, value)
    __swig_getmethods__ = {}
    for _s in [plType]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plDiscreteType, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plDiscreteType self) -> plDiscreteType
        __init__(plDiscreteType self, plType other) -> plDiscreteType
        """
        this = _pypl.new_plDiscreteType(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plDiscreteType
    __del__ = lambda self : None;
plDiscreteType_swigregister = _pypl.plDiscreteType_swigregister
plDiscreteType_swigregister(plDiscreteType)

class plContinuousType(plType):
    """Proxy of C++ plContinuousType class"""
    __swig_setmethods__ = {}
    for _s in [plType]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plContinuousType, name, value)
    __swig_getmethods__ = {}
    for _s in [plType]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plContinuousType, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plContinuousType self) -> plContinuousType
        __init__(plContinuousType self, plType other) -> plContinuousType
        """
        this = _pypl.new_plContinuousType(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plContinuousType
    __del__ = lambda self : None;
plContinuousType_swigregister = _pypl.plContinuousType_swigregister
plContinuousType_swigregister(plContinuousType)

def plType_iter( s  ):
  val = s.first_value()
  yield val

  while s.next_value( val ):
    yield val

plType.iterator = plType_iter


class plLabelType(plDiscreteType):
    """Proxy of C++ plLabelType class"""
    __swig_setmethods__ = {}
    for _s in [plDiscreteType]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLabelType, name, value)
    __swig_getmethods__ = {}
    for _s in [plDiscreteType]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLabelType, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plLabelType
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plLabelType self) -> plLabelType
        __init__(plLabelType self, StringVector vals) -> plLabelType
        __init__(plLabelType self, plType arg2) -> plLabelType
        """
        this = _pypl.new_plLabelType(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_values(self):
        """get_values(plLabelType self) -> StringVector"""
        return _pypl.plLabelType_get_values(self)

    def label_to_index(self, *args):
        """label_to_index(plLabelType self, std::string const & label) -> unsigned int"""
        return _pypl.plLabelType_label_to_index(self, *args)

plLabelType_swigregister = _pypl.plLabelType_swigregister
plLabelType_swigregister(plLabelType)

class plRealType(plContinuousType):
    """Proxy of C++ plRealType class"""
    __swig_setmethods__ = {}
    for _s in [plContinuousType]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plRealType, name, value)
    __swig_getmethods__ = {}
    for _s in [plContinuousType]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plRealType, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plRealType
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plRealType self) -> plRealType
        __init__(plRealType self, plFloat min, plFloat max, unsigned int n_intervals) -> plRealType
        __init__(plRealType self, plFloat min, plFloat max) -> plRealType
        __init__(plRealType self, plType arg2) -> plRealType
        """
        this = _pypl.new_plRealType(*args)
        try: self.this.append(this)
        except: self.this = this
plRealType_swigregister = _pypl.plRealType_swigregister
plRealType_swigregister(plRealType)

class plContinuousIntervalType(plContinuousType):
    """Proxy of C++ plContinuousIntervalType class"""
    __swig_setmethods__ = {}
    for _s in [plContinuousType]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plContinuousIntervalType, name, value)
    __swig_getmethods__ = {}
    for _s in [plContinuousType]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plContinuousIntervalType, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plContinuousIntervalType
    __del__ = lambda self : None;
    def get_interval_number(self, *args):
        """get_interval_number(plContinuousIntervalType self, plFloat val) -> int"""
        return _pypl.plContinuousIntervalType_get_interval_number(self, *args)

    def __init__(self, *args): 
        """
        __init__(plContinuousIntervalType self) -> plContinuousIntervalType
        __init__(plContinuousIntervalType self, DoubleVector interval_values) -> plContinuousIntervalType
        __init__(plContinuousIntervalType self, FloatVector interval_values) -> plContinuousIntervalType
        __init__(plContinuousIntervalType self, LongDoubleVector interval_values) -> plContinuousIntervalType
        __init__(plContinuousIntervalType self, unsigned int n_plus_one, double const * interval_values) -> plContinuousIntervalType
        __init__(plContinuousIntervalType self, unsigned int n_plus_one, float const * interval_values) -> plContinuousIntervalType
        __init__(plContinuousIntervalType self, unsigned int n_plus_one, long double const * interval_values) -> plContinuousIntervalType
        __init__(plContinuousIntervalType self, plFloat min, plFloat max, unsigned int n_intervals) -> plContinuousIntervalType
        __init__(plContinuousIntervalType self, plType arg2) -> plContinuousIntervalType
        """
        this = _pypl.new_plContinuousIntervalType(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_values(self):
        """get_values(plContinuousIntervalType self) -> DoubleVector"""
        return _pypl.plContinuousIntervalType_get_values(self)

plContinuousIntervalType_swigregister = _pypl.plContinuousIntervalType_swigregister
plContinuousIntervalType_swigregister(plContinuousIntervalType)

class plDiscreteIntervalType(plDiscreteType):
    """Proxy of C++ plDiscreteIntervalType class"""
    __swig_setmethods__ = {}
    for _s in [plDiscreteType]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plDiscreteIntervalType, name, value)
    __swig_getmethods__ = {}
    for _s in [plDiscreteType]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plDiscreteIntervalType, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plDiscreteIntervalType
    __del__ = lambda self : None;
    def get_interval_number(self, *args):
        """get_interval_number(plDiscreteIntervalType self, plFloat val) -> int"""
        return _pypl.plDiscreteIntervalType_get_interval_number(self, *args)

    def __init__(self, *args): 
        """
        __init__(plDiscreteIntervalType self) -> plDiscreteIntervalType
        __init__(plDiscreteIntervalType self, DoubleVector interval_values) -> plDiscreteIntervalType
        __init__(plDiscreteIntervalType self, FloatVector interval_values) -> plDiscreteIntervalType
        __init__(plDiscreteIntervalType self, LongDoubleVector interval_values) -> plDiscreteIntervalType
        __init__(plDiscreteIntervalType self, unsigned int n_plus_one, double const * interval_values) -> plDiscreteIntervalType
        __init__(plDiscreteIntervalType self, unsigned int n_plus_one, float const * interval_values) -> plDiscreteIntervalType
        __init__(plDiscreteIntervalType self, unsigned int n_plus_one, long double const * interval_values) -> plDiscreteIntervalType
        __init__(plDiscreteIntervalType self, plFloat min, plFloat max, unsigned int n_intervals) -> plDiscreteIntervalType
        __init__(plDiscreteIntervalType self, plType arg2) -> plDiscreteIntervalType
        """
        this = _pypl.new_plDiscreteIntervalType(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_values(self):
        """get_values(plDiscreteIntervalType self) -> DoubleVector"""
        return _pypl.plDiscreteIntervalType_get_values(self)

plDiscreteIntervalType_swigregister = _pypl.plDiscreteIntervalType_swigregister
plDiscreteIntervalType_swigregister(plDiscreteIntervalType)

class plIntegerType(plDiscreteType):
    """Proxy of C++ plIntegerType class"""
    __swig_setmethods__ = {}
    for _s in [plDiscreteType]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plIntegerType, name, value)
    __swig_getmethods__ = {}
    for _s in [plDiscreteType]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plIntegerType, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plIntegerType
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plIntegerType self) -> plIntegerType
        __init__(plIntegerType self, int min, int max) -> plIntegerType
        __init__(plIntegerType self, plType arg2) -> plIntegerType
        """
        this = _pypl.new_plIntegerType(*args)
        try: self.this.append(this)
        except: self.this = this
plIntegerType_swigregister = _pypl.plIntegerType_swigregister
plIntegerType_swigregister(plIntegerType)

PL_BINARY_TYPE=plIntegerType(0, 1)

class plVariablesConjunction(plSampleSpaceObject):
    """Proxy of C++ plVariablesConjunction class"""
    __swig_setmethods__ = {}
    for _s in [plSampleSpaceObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plVariablesConjunction, name, value)
    __swig_getmethods__ = {}
    for _s in [plSampleSpaceObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plVariablesConjunction, name)
    __repr__ = _swig_repr
    def get_variable_list(self):
        """get_variable_list(plVariablesConjunction self) -> kplVariableList const &"""
        return _pypl.plVariablesConjunction_get_variable_list(self)

    __swig_destroy__ = _pypl.delete_plVariablesConjunction
    __del__ = lambda self : None;
    def __xor__(self, *args):
        """__xor__(plVariablesConjunction self, plVariablesConjunction variable) -> plVariablesConjunction"""
        return _pypl.plVariablesConjunction___xor__(self, *args)

    def concatenate(self, *args):
        """concatenate(plVariablesConjunction self, plVariablesConjunction variable) -> plVariablesConjunction"""
        return _pypl.plVariablesConjunction_concatenate(self, *args)

    def is_discretized(self):
        """is_discretized(plVariablesConjunction self) -> bool"""
        return _pypl.plVariablesConjunction_is_discretized(self)

    def is_discrete(self):
        """is_discrete(plVariablesConjunction self) -> bool"""
        return _pypl.plVariablesConjunction_is_discrete(self)

    def is_continuous(self):
        """is_continuous(plVariablesConjunction self) -> bool"""
        return _pypl.plVariablesConjunction_is_continuous(self)

    def dim(self):
        """dim(plVariablesConjunction self) -> size_t"""
        return _pypl.plVariablesConjunction_dim(self)

    def size(self):
        """size(plVariablesConjunction self) -> size_t"""
        return _pypl.plVariablesConjunction_size(self)

    def is_empty(self):
        """is_empty(plVariablesConjunction self) -> bool"""
        return _pypl.plVariablesConjunction_is_empty(self)

    def get_var_type(self):
        """get_var_type(plVariablesConjunction self) -> plVariableType"""
        return _pypl.plVariablesConjunction_get_var_type(self)

    def get_type(self):
        """get_type(plVariablesConjunction self) -> plType"""
        return _pypl.plVariablesConjunction_get_type(self)

    def name(self):
        """name(plVariablesConjunction self) -> std::string"""
        return _pypl.plVariablesConjunction_name(self)

    def get_names(self):
        """get_names(plVariablesConjunction self) -> StringVector"""
        return _pypl.plVariablesConjunction_get_names(self)

    def begin(self):
        """begin(plVariablesConjunction self) -> plVariablesConjunction::const_iterator"""
        return _pypl.plVariablesConjunction_begin(self)

    def end(self):
        """end(plVariablesConjunction self) -> plVariablesConjunction::const_iterator"""
        return _pypl.plVariablesConjunction_end(self)

    def contains(self, *args):
        """contains(plVariablesConjunction self, plVariablesConjunction other) -> bool"""
        return _pypl.plVariablesConjunction_contains(self, *args)

    def has_same_symbols_as(self, *args):
        """has_same_symbols_as(plVariablesConjunction self, plVariablesConjunction other) -> bool"""
        return _pypl.plVariablesConjunction_has_same_symbols_as(self, *args)

    def assign_from(self, *args):
        """assign_from(plVariablesConjunction self, plVariablesConjunction other) -> plVariablesConjunction"""
        return _pypl.plVariablesConjunction_assign_from(self, *args)

    def __init__(self, *args): 
        """
        __init__(plVariablesConjunction self) -> plVariablesConjunction
        __init__(plVariablesConjunction self, plVariablesConjunction other) -> plVariablesConjunction
        """
        this = _pypl.new_plVariablesConjunction(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_all_symbols(self, *args):
        """get_all_symbols(plVariablesConjunction self, std::vector< plSymbol,std::allocator< plSymbol > > & symbols)"""
        return _pypl.plVariablesConjunction_get_all_symbols(self, *args)

    def as_symbol_vector(self):
        """as_symbol_vector(plVariablesConjunction self) -> std::vector< plSymbol,std::allocator< plSymbol > >"""
        return _pypl.plVariablesConjunction_as_symbol_vector(self)

    def at(self, *args):
        """at(plVariablesConjunction self, size_t n) -> plSymbol"""
        return _pypl.plVariablesConjunction_at(self, *args)

    def __eq__(self, *args):
        """__eq__(plVariablesConjunction self, plVariablesConjunction other) -> bool"""
        return _pypl.plVariablesConjunction___eq__(self, *args)

    def equal(self, *args):
        """equal(plVariablesConjunction self, plVariablesConjunction other) -> bool"""
        return _pypl.plVariablesConjunction_equal(self, *args)

    def __ne__(self, *args):
        """__ne__(plVariablesConjunction self, plVariablesConjunction other) -> bool"""
        return _pypl.plVariablesConjunction___ne__(self, *args)

    def not_equal(self, *args):
        """not_equal(plVariablesConjunction self, plVariablesConjunction other) -> bool"""
        return _pypl.plVariablesConjunction_not_equal(self, *args)

    def empty():
        """empty() -> plVariablesConjunction"""
        return _pypl.plVariablesConjunction_empty()

    if _newclass:empty = staticmethod(empty)
    __swig_getmethods__["empty"] = lambda x: empty
    def get_symbol_position(self, *args):
        """get_symbol_position(plVariablesConjunction self, plSymbol s) -> int"""
        return _pypl.plVariablesConjunction_get_symbol_position(self, *args)

    def __ixor__(self, *args):
        """__ixor__(plVariablesConjunction self, plVariablesConjunction var) -> plVariablesConjunction"""
        return _pypl.plVariablesConjunction___ixor__(self, *args)

    def push_back(self, *args):
        """push_back(plVariablesConjunction self, plVariablesConjunction var) -> plVariablesConjunction"""
        return _pypl.plVariablesConjunction_push_back(self, *args)

    def remove(self, *args):
        """remove(plVariablesConjunction self, plSymbol symbol) -> plVariablesConjunction"""
        return _pypl.plVariablesConjunction_remove(self, *args)

    def clear(self):
        """clear(plVariablesConjunction self)"""
        return _pypl.plVariablesConjunction_clear(self)

    def get_symbol_with_name(self, *args):
        """get_symbol_with_name(plVariablesConjunction self, std::string const & name) -> plSymbol"""
        return _pypl.plVariablesConjunction_get_symbol_with_name(self, *args)

    def __sub__(self, *args):
        """__sub__(plVariablesConjunction self, plVariablesConjunction other) -> plVariablesConjunction"""
        return _pypl.plVariablesConjunction___sub__(self, *args)

    def subtract(self, *args):
        """subtract(plVariablesConjunction self, plVariablesConjunction other) -> plVariablesConjunction"""
        return _pypl.plVariablesConjunction_subtract(self, *args)

    def sort_by_name(self):
        """sort_by_name(plVariablesConjunction self) -> plVariablesConjunction"""
        return _pypl.plVariablesConjunction_sort_by_name(self)

    def get_discrete_variables(self):
        """get_discrete_variables(plVariablesConjunction self) -> plVariablesConjunction"""
        return _pypl.plVariablesConjunction_get_discrete_variables(self)

    def __lt__(self, *args):
        """__lt__(plVariablesConjunction self, plVariablesConjunction other) -> bool"""
        return _pypl.plVariablesConjunction___lt__(self, *args)

    def less(self, *args):
        """less(plVariablesConjunction self, plVariablesConjunction other) -> bool"""
        return _pypl.plVariablesConjunction_less(self, *args)

    def __getitem__(self, *args):
        """__getitem__(plVariablesConjunction self, int n) -> plSymbol"""
        return _pypl.plVariablesConjunction___getitem__(self, *args)

    def get_cardinality(self):
        """get_cardinality(plVariablesConjunction self) -> double"""
        return _pypl.plVariablesConjunction_get_cardinality(self)

plVariablesConjunction_swigregister = _pypl.plVariablesConjunction_swigregister
plVariablesConjunction_swigregister(plVariablesConjunction)

def plVariablesConjunction_empty():
  """plVariablesConjunction_empty() -> plVariablesConjunction"""
  return _pypl.plVariablesConjunction_empty()

def varConj_iter( s ):
  s.count = -1
  return s;

def varConj_next( s ):
  s.count = s.count + 1
  if s.count >=s.dim():
      raise StopIteration
  else:
      return s[s.count]

plVariablesConjunction.next = varConj_next
plVariablesConjunction.__iter__ = varConj_iter
plVariablesConjunction.count = -1

class plSymbol(plVariablesConjunction):
    """Proxy of C++ plSymbol class"""
    __swig_setmethods__ = {}
    for _s in [plVariablesConjunction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plSymbol, name, value)
    __swig_getmethods__ = {}
    for _s in [plVariablesConjunction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plSymbol, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plSymbol
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plSymbol self, std::string const & print_name, plType variable_type) -> plSymbol
        __init__(plSymbol self, std::string const & print_name, plSymbol symbol) -> plSymbol
        __init__(plSymbol self) -> plSymbol
        __init__(plSymbol self, plVariablesConjunction arg2) -> plSymbol
        """
        this = _pypl.new_plSymbol(*args)
        try: self.this.append(this)
        except: self.this = this
plSymbol_swigregister = _pypl.plSymbol_swigregister
plSymbol_swigregister(plSymbol)

plSymbol.__repr__ = plSymbol.__str__


class plArray(plVariablesConjunction):
    """Proxy of C++ plArray class"""
    __swig_setmethods__ = {}
    for _s in [plVariablesConjunction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plArray, name, value)
    __swig_getmethods__ = {}
    for _s in [plVariablesConjunction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plArray self, std::string const & print_name, plType variable_type, int tab_dim, int arg5=0, int arg6=0, 
            int arg7=0, int arg8=0) -> plArray
        __init__(plArray self, std::string const & print_name, plType variable_type, int tab_dim, int arg5=0, int arg6=0, 
            int arg7=0) -> plArray
        __init__(plArray self, std::string const & print_name, plType variable_type, int tab_dim, int arg5=0, int arg6=0) -> plArray
        __init__(plArray self, std::string const & print_name, plType variable_type, int tab_dim, int arg5=0) -> plArray
        __init__(plArray self, std::string const & print_name, plType variable_type, int tab_dim) -> plArray
        __init__(plArray self) -> plArray
        __init__(plArray self, plArray array) -> plArray
        """
        this = _pypl.new_plArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plArray
    __del__ = lambda self : None;
    def at(self, *args):
        """
        at(plArray self, int first_index, int arg3=0, int arg4=0, int arg5=0, int arg6=0) -> plSymbol
        at(plArray self, int first_index, int arg3=0, int arg4=0, int arg5=0) -> plSymbol
        at(plArray self, int first_index, int arg3=0, int arg4=0) -> plSymbol
        at(plArray self, int first_index, int arg3=0) -> plSymbol
        at(plArray self, int first_index) -> plSymbol
        """
        return _pypl.plArray_at(self, *args)

    def name(self):
        """name(plArray self) -> std::string"""
        return _pypl.plArray_name(self)

plArray_swigregister = _pypl.plArray_swigregister
plArray_swigregister(plArray)

class pl1DArray(plArray):
    """Proxy of C++ pl1DArray class"""
    __swig_setmethods__ = {}
    for _s in [plArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, pl1DArray, name, value)
    __swig_getmethods__ = {}
    for _s in [plArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, pl1DArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(pl1DArray self, std::string const & print_name, plType variable_type, unsigned int n) -> pl1DArray
        __init__(pl1DArray self) -> pl1DArray
        """
        this = _pypl.new_pl1DArray(*args)
        try: self.this.append(this)
        except: self.this = this
    def at(self, *args):
        """at(pl1DArray self, int index) -> plSymbol"""
        return _pypl.pl1DArray_at(self, *args)

    __swig_destroy__ = _pypl.delete_pl1DArray
    __del__ = lambda self : None;
pl1DArray_swigregister = _pypl.pl1DArray_swigregister
pl1DArray_swigregister(pl1DArray)

class pl2DArray(plArray):
    """Proxy of C++ pl2DArray class"""
    __swig_setmethods__ = {}
    for _s in [plArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, pl2DArray, name, value)
    __swig_getmethods__ = {}
    for _s in [plArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, pl2DArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(pl2DArray self, std::string const & print_name, plType variable_type, unsigned int n, unsigned int m) -> pl2DArray
        __init__(pl2DArray self) -> pl2DArray
        """
        this = _pypl.new_pl2DArray(*args)
        try: self.this.append(this)
        except: self.this = this
    def at(self, *args):
        """at(pl2DArray self, int index1, int index2) -> plSymbol"""
        return _pypl.pl2DArray_at(self, *args)

    __swig_destroy__ = _pypl.delete_pl2DArray
    __del__ = lambda self : None;
pl2DArray_swigregister = _pypl.pl2DArray_swigregister
pl2DArray_swigregister(pl2DArray)

class plValues(plSampleSpaceObject):
    """Proxy of C++ plValues class"""
    __swig_setmethods__ = {}
    for _s in [plSampleSpaceObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plValues, name, value)
    __swig_getmethods__ = {}
    for _s in [plSampleSpaceObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plValues, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plValues self) -> plValues
        __init__(plValues self, plValues val) -> plValues
        __init__(plValues self, plVariablesConjunction variables) -> plValues
        __init__(plValues self, plSymbol variable) -> plValues
        __init__(plValues self, kplVariableList const & vars) -> plValues
        __init__(plValues self, kplVariableList const & vars, plDataValues val) -> plValues
        """
        this = _pypl.new_plValues(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plValues
    __del__ = lambda self : None;
    def is_empty(self):
        """is_empty(plValues self) -> bool"""
        return _pypl.plValues_is_empty(self)

    def is_valid(self, *args):
        """
        is_valid(plValues self) -> bool
        is_valid(plValues self, BoolVector check_variable) -> bool
        """
        return _pypl.plValues_is_valid(self, *args)

    def size(self):
        """size(plValues self) -> size_t"""
        return _pypl.plValues_size(self)

    def reset(self, *args):
        """
        reset(plValues self)
        reset(plValues self, plVariablesConjunction variables)
        """
        return _pypl.plValues_reset(self, *args)

    def plNext(self, *args):
        """
        plNext(plValues self) -> bool
        plNext(plValues self, plVariablesConjunction variable) -> bool
        """
        return _pypl.plValues_plNext(self, *args)

    def get_variables(self):
        """get_variables(plValues self) -> plVariablesConjunction"""
        return _pypl.plValues_get_variables(self)

    def assign_from(self, *args):
        """assign_from(plValues self, plValues other) -> plValues"""
        return _pypl.plValues_assign_from(self, *args)

    def __eq__(self, *args):
        """__eq__(plValues self, plValues v) -> bool"""
        return _pypl.plValues___eq__(self, *args)

    def equal(self, *args):
        """equal(plValues self, plValues v) -> bool"""
        return _pypl.plValues_equal(self, *args)

    def __ne__(self, *args):
        """__ne__(plValues self, plValues v) -> bool"""
        return _pypl.plValues___ne__(self, *args)

    def not_equal(self, *args):
        """not_equal(plValues self, plValues v) -> bool"""
        return _pypl.plValues_not_equal(self, *args)

    def __lt__(self, *args):
        """__lt__(plValues self, plValues v) -> bool"""
        return _pypl.plValues___lt__(self, *args)

    def less(self, *args):
        """less(plValues self, plValues v) -> bool"""
        return _pypl.plValues_less(self, *args)

    def __ge__(self, *args):
        """__ge__(plValues self, plValues v) -> bool"""
        return _pypl.plValues___ge__(self, *args)

    def greater_or_equal(self, *args):
        """greater_or_equal(plValues self, plValues v) -> bool"""
        return _pypl.plValues_greater_or_equal(self, *args)

    def __gt__(self, *args):
        """__gt__(plValues self, plValues v) -> bool"""
        return _pypl.plValues___gt__(self, *args)

    def greater(self, *args):
        """greater(plValues self, plValues v) -> bool"""
        return _pypl.plValues_greater(self, *args)

    def __le__(self, *args):
        """__le__(plValues self, plValues v) -> bool"""
        return _pypl.plValues___le__(self, *args)

    def less_or_equal(self, *args):
        """less_or_equal(plValues self, plValues v) -> bool"""
        return _pypl.plValues_less_or_equal(self, *args)

    def add(self, *args):
        """
        add(plValues self, plSymbol variable, plData value) -> plValues
        add(plValues self, plSymbol variable, int const & value) -> plValues
        add(plValues self, plSymbol variable, unsigned int const & value) -> plValues
        add(plValues self, plSymbol variable, float const & value) -> plValues
        add(plValues self, plSymbol variable, double const & value) -> plValues
        """
        return _pypl.plValues_add(self, *args)

    def remove(self, *args):
        """remove(plValues self, plVariablesConjunction variables) -> plValues"""
        return _pypl.plValues_remove(self, *args)

    def rename(self, *args):
        """rename(plValues self, plVariablesConjunction new_variable)"""
        return _pypl.plValues_rename(self, *args)

    def set_partially(self, *args):
        """set_partially(plValues self, plValues partial_value)"""
        return _pypl.plValues_set_partially(self, *args)

    def __xor__(self, *args):
        """__xor__(plValues self, plValues other) -> plValues"""
        return _pypl.plValues___xor__(self, *args)

    def concatenate(self, *args):
        """concatenate(plValues self, plValues other) -> plValues"""
        return _pypl.plValues_concatenate(self, *args)

    def __ixor__(self, *args):
        """__ixor__(plValues self, plValues other) -> plValues"""
        return _pypl.plValues___ixor__(self, *args)

    def push_back(self, *args):
        """push_back(plValues self, plValues other) -> plValues"""
        return _pypl.plValues_push_back(self, *args)

    def support_area(self):
        """support_area(plValues self) -> plFloat"""
        return _pypl.plValues_support_area(self)

    def set_values_address(self, *args):
        """set_values_address(plValues self, plDataValues val)"""
        return _pypl.plValues_set_values_address(self, *args)

    def values(self, *args):
        """
        values(plValues self) -> plDataValues
        values(plValues self) -> plDataValues
        """
        return _pypl.plValues_values(self, *args)

    def to_data_values(self, *args):
        """
        to_data_values(plValues self, kplVariableList const & variable, plDataValues ptr, BoolVector definition)
        to_data_values(plValues self, kplVariableList const & variable, plDataValues ptr)
        """
        return _pypl.plValues_to_data_values(self, *args)

    def set_variable_value(self, *args):
        """set_variable_value(plValues self, kplVariable const * variable, plData value) -> bool"""
        return _pypl.plValues_set_variable_value(self, *args)

    def get_value(self, *args):
        """
        get_value(plValues self, plSymbol s) -> plData
        get_value(plValues self, size_t i) -> plData
        """
        return _pypl.plValues_get_value(self, *args)

    def get_value_as_int(self, *args):
        """
        get_value_as_int(plValues self, plSymbol s) -> int
        get_value_as_int(plValues self, size_t i) -> int
        """
        return _pypl.plValues_get_value_as_int(self, *args)

    def get_value_as_double(self, *args):
        """
        get_value_as_double(plValues self, plSymbol s) -> double
        get_value_as_double(plValues self, size_t i) -> double
        """
        return _pypl.plValues_get_value_as_double(self, *args)

    def get_value_as_label(self, *args):
        """
        get_value_as_label(plValues self, plSymbol s) -> std::string
        get_value_as_label(plValues self, size_t i) -> std::string
        """
        return _pypl.plValues_get_value_as_label(self, *args)

    def set_value(self, *args):
        """
        set_value(plValues self, plSymbol s, plData data)
        set_value(plValues self, size_t i, plData data)
        set_value(plValues self, plSymbol s, int data)
        set_value(plValues self, size_t i, int data)
        set_value(plValues self, plSymbol s, unsigned int data)
        set_value(plValues self, size_t i, unsigned int data)
        set_value(plValues self, plSymbol s, double data)
        set_value(plValues self, size_t i, double data)
        set_value(plValues self, plSymbol s, float data)
        set_value(plValues self, size_t i, float data)
        """
        return _pypl.plValues_set_value(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(plValues self, int index) -> plData
        __getitem__(plValues self, plSymbol var) -> plData
        __getitem__(plValues self, plData index) -> plData
        """
        return _pypl.plValues___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(plValues self, int index, plData value)
        __setitem__(plValues self, plData index, plData value)
        __setitem__(plValues self, plData index, plFloat const & value)
        __setitem__(plValues self, plData index, std::string const & value)
        __setitem__(plValues self, plSymbol index, std::string const & value)
        __setitem__(plValues self, plData index, int value)
        __setitem__(plValues self, plSymbol index, plData value)
        __setitem__(plValues self, plSymbol index, plFloat const & value)
        __setitem__(plValues self, plSymbol index, int value)
        __setitem__(plValues self, int index, plFloat const & value)
        __setitem__(plValues self, int index, int value)
        __setitem__(plValues self, int index, std::string const & value)
        """
        return _pypl.plValues___setitem__(self, *args)

plValues_swigregister = _pypl.plValues_swigregister
plValues_swigregister(plValues)

def plValues_iter(self ):
  self.reset()
  while 1:
    yield self
    if not self.plNext():
      raise StopIteration
        
plValues.__iter__ = plValues_iter


class plValuesVector(_object):
    """Proxy of C++ std::vector<(plValues)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plValuesVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plValuesVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(plValuesVector self) -> SwigPyIterator"""
        return _pypl.plValuesVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(plValuesVector self) -> bool"""
        return _pypl.plValuesVector___nonzero__(self)

    def __bool__(self):
        """__bool__(plValuesVector self) -> bool"""
        return _pypl.plValuesVector___bool__(self)

    def __len__(self):
        """__len__(plValuesVector self) -> std::vector< plValues >::size_type"""
        return _pypl.plValuesVector___len__(self)

    def pop(self):
        """pop(plValuesVector self) -> plValues"""
        return _pypl.plValuesVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(plValuesVector self, std::vector< plValues >::difference_type i, std::vector< plValues >::difference_type j) -> plValuesVector"""
        return _pypl.plValuesVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(plValuesVector self, std::vector< plValues >::difference_type i, std::vector< plValues >::difference_type j, 
            plValuesVector v=std::vector< plValues,std::allocator< plValues > >())
        __setslice__(plValuesVector self, std::vector< plValues >::difference_type i, std::vector< plValues >::difference_type j)
        """
        return _pypl.plValuesVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(plValuesVector self, std::vector< plValues >::difference_type i, std::vector< plValues >::difference_type j)"""
        return _pypl.plValuesVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(plValuesVector self, std::vector< plValues >::difference_type i)
        __delitem__(plValuesVector self, PySliceObject * slice)
        """
        return _pypl.plValuesVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(plValuesVector self, PySliceObject * slice) -> plValuesVector
        __getitem__(plValuesVector self, std::vector< plValues >::difference_type i) -> plValues
        """
        return _pypl.plValuesVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(plValuesVector self, PySliceObject * slice, plValuesVector v)
        __setitem__(plValuesVector self, PySliceObject * slice)
        __setitem__(plValuesVector self, std::vector< plValues >::difference_type i, plValues x)
        """
        return _pypl.plValuesVector___setitem__(self, *args)

    def append(self, *args):
        """append(plValuesVector self, plValues x)"""
        return _pypl.plValuesVector_append(self, *args)

    def empty(self):
        """empty(plValuesVector self) -> bool"""
        return _pypl.plValuesVector_empty(self)

    def size(self):
        """size(plValuesVector self) -> std::vector< plValues >::size_type"""
        return _pypl.plValuesVector_size(self)

    def clear(self):
        """clear(plValuesVector self)"""
        return _pypl.plValuesVector_clear(self)

    def swap(self, *args):
        """swap(plValuesVector self, plValuesVector v)"""
        return _pypl.plValuesVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(plValuesVector self) -> std::vector< plValues >::allocator_type"""
        return _pypl.plValuesVector_get_allocator(self)

    def begin(self):
        """begin(plValuesVector self) -> std::vector< plValues >::iterator"""
        return _pypl.plValuesVector_begin(self)

    def end(self):
        """end(plValuesVector self) -> std::vector< plValues >::iterator"""
        return _pypl.plValuesVector_end(self)

    def rbegin(self):
        """rbegin(plValuesVector self) -> std::vector< plValues >::reverse_iterator"""
        return _pypl.plValuesVector_rbegin(self)

    def rend(self):
        """rend(plValuesVector self) -> std::vector< plValues >::reverse_iterator"""
        return _pypl.plValuesVector_rend(self)

    def pop_back(self):
        """pop_back(plValuesVector self)"""
        return _pypl.plValuesVector_pop_back(self)

    def erase(self, *args):
        """
        erase(plValuesVector self, std::vector< plValues >::iterator pos) -> std::vector< plValues >::iterator
        erase(plValuesVector self, std::vector< plValues >::iterator first, std::vector< plValues >::iterator last) -> std::vector< plValues >::iterator
        """
        return _pypl.plValuesVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(plValues)> self) -> plValuesVector
        __init__(std::vector<(plValues)> self, plValuesVector arg2) -> plValuesVector
        __init__(std::vector<(plValues)> self, std::vector< plValues >::size_type size) -> plValuesVector
        __init__(std::vector<(plValues)> self, std::vector< plValues >::size_type size, plValues value) -> plValuesVector
        """
        this = _pypl.new_plValuesVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(plValuesVector self, plValues x)"""
        return _pypl.plValuesVector_push_back(self, *args)

    def front(self):
        """front(plValuesVector self) -> plValues"""
        return _pypl.plValuesVector_front(self)

    def back(self):
        """back(plValuesVector self) -> plValues"""
        return _pypl.plValuesVector_back(self)

    def assign(self, *args):
        """assign(plValuesVector self, std::vector< plValues >::size_type n, plValues x)"""
        return _pypl.plValuesVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(plValuesVector self, std::vector< plValues >::size_type new_size)
        resize(plValuesVector self, std::vector< plValues >::size_type new_size, plValues x)
        """
        return _pypl.plValuesVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(plValuesVector self, std::vector< plValues >::iterator pos, plValues x) -> std::vector< plValues >::iterator
        insert(plValuesVector self, std::vector< plValues >::iterator pos, std::vector< plValues >::size_type n, plValues x)
        """
        return _pypl.plValuesVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(plValuesVector self, std::vector< plValues >::size_type n)"""
        return _pypl.plValuesVector_reserve(self, *args)

    def capacity(self):
        """capacity(plValuesVector self) -> std::vector< plValues >::size_type"""
        return _pypl.plValuesVector_capacity(self)

    __swig_destroy__ = _pypl.delete_plValuesVector
    __del__ = lambda self : None;
plValuesVector_swigregister = _pypl.plValuesVector_swigregister
plValuesVector_swigregister(plValuesVector)

PLCndNormal = _pypl.PLCndNormal
PLComputableObject = _pypl.PLComputableObject
PLCndDistribution = _pypl.PLCndDistribution
PLCndUnknown = _pypl.PLCndUnknown
PLJointDistribution = _pypl.PLJointDistribution
PLDeterministic = _pypl.PLDeterministic
PLCndDeterministic = _pypl.PLCndDeterministic
PLGamma = _pypl.PLGamma
PLNormal = _pypl.PLNormal
PLDistribution = _pypl.PLDistribution
PLDistributionTable = _pypl.PLDistributionTable
PLPoisson = _pypl.PLPoisson
PLProbTable = _pypl.PLProbTable
PLUniform = _pypl.PLUniform
PLUnknown = _pypl.PLUnknown
PLAnonymousDistribution = _pypl.PLAnonymousDistribution
PLCndAnonymousDistribution = _pypl.PLCndAnonymousDistribution
PLIneqConstraint = _pypl.PLIneqConstraint
PLLogNormal = _pypl.PLLogNormal
PLCndLogNormal = _pypl.PLCndLogNormal
PLExponential = _pypl.PLExponential
PLBeta = _pypl.PLBeta
PLBinomial = _pypl.PLBinomial
PLDirichlet = _pypl.PLDirichlet
PLCndUniform = _pypl.PLCndUniform
PLCndPoisson = _pypl.PLCndPoisson
PLJtDistribution = _pypl.PLJtDistribution
PLCndJtDistribution = _pypl.PLCndJtDistribution
PLCndBinomial = _pypl.PLCndBinomial
PLWeibull = _pypl.PLWeibull
PLNoisyOR = _pypl.PLNoisyOR
PLLinearRegression = _pypl.PLLinearRegression
PLSoftmax = _pypl.PLSoftmax
PLCndBeta = _pypl.PLCndBeta
PLCndExponential = _pypl.PLCndExponential
PLCndGamma = _pypl.PLCndGamma
PLCndWeibull = _pypl.PLCndWeibull
PLVonMises = _pypl.PLVonMises
PLCndVonMises = _pypl.PLCndVonMises
NUMBER_OF_PL_COMPUTABLE_OBJECTS = _pypl.NUMBER_OF_PL_COMPUTABLE_OBJECTS

def pl_get_computable_object_type_name(*args):
  """pl_get_computable_object_type_name(plComputableObjectType arg1) -> std::string"""
  return _pypl.pl_get_computable_object_type_name(*args)

def pl_get_computable_object_type(*args):
  """
    pl_get_computable_object_type(std::string const & name) -> plComputableObjectType
    pl_get_computable_object_type(plSignature const & signature) -> plComputableObjectType
    """
  return _pypl.pl_get_computable_object_type(*args)
class plComputableObjectList(plObject):
    """Proxy of C++ plComputableObjectList class"""
    __swig_setmethods__ = {}
    for _s in [plObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plComputableObjectList, name, value)
    __swig_getmethods__ = {}
    for _s in [plObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plComputableObjectList, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plComputableObjectList self) -> plComputableObjectList
        __init__(plComputableObjectList self, plComputableObject obj) -> plComputableObjectList
        __init__(plComputableObjectList self, plComputableObjectList l) -> plComputableObjectList
        """
        this = _pypl.new_plComputableObjectList(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plComputableObjectList
    __del__ = lambda self : None;
    def assign_from(self, *args):
        """assign_from(plComputableObjectList self, plComputableObjectList l) -> plComputableObjectList"""
        return _pypl.plComputableObjectList_assign_from(self, *args)

    def __mul__(self, *args):
        """
        __mul__(plComputableObjectList self, plComputableObject f1) -> plComputableObjectList
        __mul__(plComputableObjectList self, plComputableObjectList r_list) -> plComputableObjectList
        """
        return _pypl.plComputableObjectList___mul__(self, *args)

    def concatenate(self, *args):
        """
        concatenate(plComputableObjectList self, plComputableObject f1) -> plComputableObjectList
        concatenate(plComputableObjectList self, plComputableObjectList r_list) -> plComputableObjectList
        """
        return _pypl.plComputableObjectList_concatenate(self, *args)

    def __imul__(self, *args):
        """
        __imul__(plComputableObjectList self, plComputableObject f1) -> plComputableObjectList
        __imul__(plComputableObjectList self, plComputableObjectList r_list) -> plComputableObjectList
        """
        return _pypl.plComputableObjectList___imul__(self, *args)

    def push_back(self, *args):
        """
        push_back(plComputableObjectList self, plComputableObject f1) -> plComputableObjectList
        push_back(plComputableObjectList self, plComputableObjectList r_list) -> plComputableObjectList
        """
        return _pypl.plComputableObjectList_push_back(self, *args)

    def clear(self):
        """clear(plComputableObjectList self)"""
        return _pypl.plComputableObjectList_clear(self)

    def size(self):
        """size(plComputableObjectList self) -> size_t"""
        return _pypl.plComputableObjectList_size(self)

    def __getitem__(self, *args):
        """__getitem__(plComputableObjectList self, size_t i) -> plComputableObject"""
        return _pypl.plComputableObjectList___getitem__(self, *args)

    def at(self, *args):
        """at(plComputableObjectList self, size_t i) -> plComputableObject"""
        return _pypl.plComputableObjectList_at(self, *args)

    def empty(self):
        """empty(plComputableObjectList self) -> bool"""
        return _pypl.plComputableObjectList_empty(self)

    def begin(self):
        """begin(plComputableObjectList self) -> plComputableObjectList::const_iterator"""
        return _pypl.plComputableObjectList_begin(self)

    def end(self):
        """end(plComputableObjectList self) -> plComputableObjectList::const_iterator"""
        return _pypl.plComputableObjectList_end(self)

    def get_distribution_over(self, *args):
        """get_distribution_over(plComputableObjectList self, plVariablesConjunction variable) -> plComputableObject"""
        return _pypl.plComputableObjectList_get_distribution_over(self, *args)

plComputableObjectList_swigregister = _pypl.plComputableObjectList_swigregister
plComputableObjectList_swigregister(plComputableObjectList)

class plComputableObject(plObject):
    """Proxy of C++ plComputableObject class"""
    __swig_setmethods__ = {}
    for _s in [plObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plComputableObject, name, value)
    __swig_getmethods__ = {}
    for _s in [plObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plComputableObject, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plComputableObject
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plComputableObject self) -> plComputableObject
        __init__(plComputableObject self, plComputableObjectList func_lis) -> plComputableObject
        __init__(plComputableObject self, plComputableObjectList func_lis, plVariablesConjunction left_variables, plVariablesConjunction right_variables) -> plComputableObject
        __init__(plComputableObject self, plComputableObject arg2) -> plComputableObject
        """
        this = _pypl.new_plComputableObject(*args)
        try: self.this.append(this)
        except: self.this = this
    def assign_from(self, *args):
        """assign_from(plComputableObject self, plComputableObject other) -> plComputableObject"""
        return _pypl.plComputableObject_assign_from(self, *args)

    def get_print_name(self):
        """get_print_name(plComputableObject self) -> std::string"""
        return _pypl.plComputableObject_get_print_name(self)

    def isObject(self, *args):
        """isObject(plComputableObject self, plComputableObjectType const & type) -> bool"""
        return _pypl.plComputableObject_isObject(self, *args)

    def is_some_on_signature(self, *args):
        """is_some_on_signature(plComputableObject self, plSignature const & prototype_signature) -> bool"""
        return _pypl.plComputableObject_is_some_on_signature(self, *args)

    def is_conditional(self):
        """is_conditional(plComputableObject self) -> bool"""
        return _pypl.plComputableObject_is_conditional(self)

    def is_empty(self):
        """is_empty(plComputableObject self) -> bool"""
        return _pypl.plComputableObject_is_empty(self)

    def get_signature(self):
        """get_signature(plComputableObject self) -> plSignature const &"""
        return _pypl.plComputableObject_get_signature(self)

    def get_computable_object_type(self):
        """get_computable_object_type(plComputableObject self) -> plComputableObjectType"""
        return _pypl.plComputableObject_get_computable_object_type(self)

    def get_variables(self):
        """get_variables(plComputableObject self) -> plVariablesConjunction"""
        return _pypl.plComputableObject_get_variables(self)

    def get_left_variables(self):
        """get_left_variables(plComputableObject self) -> plVariablesConjunction"""
        return _pypl.plComputableObject_get_left_variables(self)

    def get_right_variables(self):
        """get_right_variables(plComputableObject self) -> plVariablesConjunction"""
        return _pypl.plComputableObject_get_right_variables(self)

    def compute(self, *args):
        """
        compute(plComputableObject self, plValues values) -> plProbValue
        compute(plComputableObject self, int const * values) -> plProbValue
        compute(plComputableObject self, unsigned int const * values) -> plProbValue
        compute(plComputableObject self, float const * values) -> plProbValue
        compute(plComputableObject self, double const * values) -> plProbValue
        compute(plComputableObject self, IntVector parameter) -> plProbValue
        compute(plComputableObject self, UnsignedIntVector parameter) -> plProbValue
        compute(plComputableObject self, FloatVector parameter) -> plProbValue
        compute(plComputableObject self, DoubleVector parameter) -> plProbValue
        """
        return _pypl.plComputableObject_compute(self, *args)

    def compute_log(self, *args):
        """
        compute_log(plComputableObject self, plValues values) -> plFloat
        compute_log(plComputableObject self, int const * values) -> plFloat
        compute_log(plComputableObject self, unsigned int const * values) -> plFloat
        compute_log(plComputableObject self, float const * values) -> plFloat
        compute_log(plComputableObject self, double const * values) -> plFloat
        compute_log(plComputableObject self, IntVector parameter) -> plFloat
        compute_log(plComputableObject self, UnsignedIntVector parameter) -> plFloat
        compute_log(plComputableObject self, FloatVector parameter) -> plFloat
        compute_log(plComputableObject self, DoubleVector parameter) -> plFloat
        """
        return _pypl.plComputableObject_compute_log(self, *args)

    def rename(self, *args):
        """rename(plComputableObject self, plVariablesConjunction new_variables) -> plComputableObject"""
        return _pypl.plComputableObject_rename(self, *args)

    def write_head(self):
        """
        write_head(plComputableObject self) -> std::ostream
        write_head(plComputableObject self) -> std::ostream &
        """
        return _pypl.plComputableObject_write_head(self)

    def get_head_string(self):
        """get_head_string(plComputableObject self) -> std::string"""
        return _pypl.plComputableObject_get_head_string(self)

    def write_body(self):
        """
        write_body(plComputableObject self) -> std::ostream
        write_body(plComputableObject self) -> std::ostream &
        """
        return _pypl.plComputableObject_write_body(self)

    def get_body_string(self):
        """get_body_string(plComputableObject self) -> std::string"""
        return _pypl.plComputableObject_get_body_string(self)

    def __mul__(self, *args):
        """
        __mul__(plComputableObject self, plComputableObject f2) -> plComputableObjectList
        __mul__(plComputableObject self, plComputableObjectList v_list) -> plComputableObjectList
        """
        return _pypl.plComputableObject___mul__(self, *args)

    def concatenate(self, *args):
        """
        concatenate(plComputableObject self, plComputableObject f2) -> plComputableObjectList
        concatenate(plComputableObject self, plComputableObjectList v_list) -> plComputableObjectList
        """
        return _pypl.plComputableObject_concatenate(self, *args)

    def replace(self, *args):
        """
        replace(plComputableObject self, plVariablesConjunction left_vars, plVariablesConjunction right_vars, plComputableObject new_co)
        replace(plComputableObject self, plVariablesConjunction left_vars, plDistribution new_distribution)
        """
        return _pypl.plComputableObject_replace(self, *args)

    def __eq__(self, *args):
        """__eq__(plComputableObject self, plComputableObject other) -> bool"""
        return _pypl.plComputableObject___eq__(self, *args)

    def equal(self, *args):
        """equal(plComputableObject self, plComputableObject other) -> bool"""
        return _pypl.plComputableObject_equal(self, *args)

    def __ne__(self, *args):
        """__ne__(plComputableObject self, plComputableObject other) -> bool"""
        return _pypl.plComputableObject___ne__(self, *args)

    def not_equal(self, *args):
        """not_equal(plComputableObject self, plComputableObject other) -> bool"""
        return _pypl.plComputableObject_not_equal(self, *args)

    def is_builtin(self):
        """is_builtin(plComputableObject self) -> bool"""
        return _pypl.plComputableObject_is_builtin(self)

    def print_evaluation_tree_infos(self):
        """print_evaluation_tree_infos(plComputableObject self) -> std::ostream &"""
        return _pypl.plComputableObject_print_evaluation_tree_infos(self)

    def get_exhaustive_compilation_complexity(self):
        """get_exhaustive_compilation_complexity(plComputableObject self) -> long double"""
        return _pypl.plComputableObject_get_exhaustive_compilation_complexity(self)

    def get_exhaustive_update_complexity(self):
        """get_exhaustive_update_complexity(plComputableObject self) -> long double"""
        return _pypl.plComputableObject_get_exhaustive_update_complexity(self)

    def is_mutable(self):
        """is_mutable(plComputableObject self) -> bool"""
        return _pypl.plComputableObject_is_mutable(self)

    def tabulate(self, *args):
        """tabulate(plComputableObject self, DoubleVector output)"""
        return _pypl.plComputableObject_tabulate(self, *args)

    def n_tabulate(self, *args):
        """n_tabulate(plComputableObject self, DoubleVector output, unsigned long n)"""
        return _pypl.plComputableObject_n_tabulate(self, *args)

    def time_tabulate(self, *args):
        """time_tabulate(plComputableObject self, DoubleVector output, double time_in_seconds)"""
        return _pypl.plComputableObject_time_tabulate(self, *args)

    def get_factors(self):
        """get_factors(plComputableObject self) -> plComputableObjectList"""
        return _pypl.plComputableObject_get_factors(self)

    def get_children(self):
        """get_children(plComputableObject self) -> plComputableObjectList"""
        return _pypl.plComputableObject_get_children(self)

    def get_marginalized_variables(self):
        """get_marginalized_variables(plComputableObject self) -> plVariablesConjunction"""
        return _pypl.plComputableObject_get_marginalized_variables(self)

plComputableObject_swigregister = _pypl.plComputableObject_swigregister
plComputableObject_swigregister(plComputableObject)

def plComputableObjectList_str( cls ):
  s = "[ "
  for i in xrange(cls.size()):
    s = s + cls[i].to_string()
    if i!=cls.size()-1:
      s = s +  ", "
    s = s + "] "
  return s;

def plComputableObjectList_iter ( cls ):
  cls.index = -1
  return cls;

def plComputableObjectList_next( cls ):
  cls.index = cls.index + 1
  if cls.index<cls.size():
    return cls[cls.index]
  else:
    raise StopIteration

plComputableObjectList.__str__ = plComputableObjectList_str
plComputableObjectList.__repr__ = plComputableObjectList.__str__

plComputableObjectList.__iter__ = plComputableObjectList_iter
plComputableObjectList.next = plComputableObjectList_next



class plDistribution(plComputableObject):
    """Proxy of C++ plDistribution class"""
    __swig_setmethods__ = {}
    for _s in [plComputableObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plDistribution, name, value)
    __swig_getmethods__ = {}
    for _s in [plComputableObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plDistribution, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plDistribution self) -> plDistribution
        __init__(plDistribution self, plVariablesConjunction variables, plComputableObjectType const & sig) -> plDistribution
        __init__(plDistribution self, plDistribution arg2) -> plDistribution
        __init__(plDistribution self, plComputableObject arg2) -> plDistribution
        __init__(plDistribution self, plCndDistribution arg2) -> plDistribution
        __init__(plDistribution self, plComputableObjectList arg2) -> plDistribution
        __init__(plDistribution self, plComputableObjectList fun_list, plVariablesConjunction variables) -> plDistribution
        __init__(plDistribution self, plVariablesConjunction variables, plProbValue const * table, bool already_normalized=False) -> plDistribution
        __init__(plDistribution self, plVariablesConjunction variables, plProbValue const * table) -> plDistribution
        __init__(plDistribution self, plVariablesConjunction variables, DoubleVector table, bool already_normalized=False) -> plDistribution
        __init__(plDistribution self, plVariablesConjunction variables, DoubleVector table) -> plDistribution
        __init__(plDistribution self, plVariablesConjunction variables) -> plDistribution
        """
        this = _pypl.new_plDistribution(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plDistribution
    __del__ = lambda self : None;
    def n_compile(self, *args):
        """
        n_compile(plDistribution self, plDistribution result, unsigned int n, plGeneratorType generator_type=PL_CHOOSE_GENERATOR_FOR_ME, 
            plCompiledDistributionType compiled_distrib_type=PL_CHOOSE_COMP_TYPE_FOR_ME)
        n_compile(plDistribution self, plDistribution result, unsigned int n, plGeneratorType generator_type=PL_CHOOSE_GENERATOR_FOR_ME)
        n_compile(plDistribution self, plDistribution result, unsigned int n)
        """
        return _pypl.plDistribution_n_compile(self, *args)

    def time_compile(self, *args):
        """
        time_compile(plDistribution self, plDistribution result, double time_in_seconds, plGeneratorType generator_type=PL_CHOOSE_GENERATOR_FOR_ME, 
            plCompiledDistributionType compiled_distrib_type=PL_CHOOSE_COMP_TYPE_FOR_ME)
        time_compile(plDistribution self, plDistribution result, double time_in_seconds, plGeneratorType generator_type=PL_CHOOSE_GENERATOR_FOR_ME)
        time_compile(plDistribution self, plDistribution result, double time_in_seconds)
        time_compile(plDistribution self, double time_in_seconds, plGeneratorType generator_type=PL_CHOOSE_GENERATOR_FOR_ME, 
            plCompiledDistributionType compliled_distrib_type=PL_CHOOSE_COMP_TYPE_FOR_ME) -> plDistribution
        time_compile(plDistribution self, double time_in_seconds, plGeneratorType generator_type=PL_CHOOSE_GENERATOR_FOR_ME) -> plDistribution
        time_compile(plDistribution self, double time_in_seconds) -> plDistribution
        """
        return _pypl.plDistribution_time_compile(self, *args)

    def compile_low_memory_use(self, *args):
        """compile_low_memory_use(plDistribution self, plDistribution result)"""
        return _pypl.plDistribution_compile_low_memory_use(self, *args)

    def compile(self, *args):
        """
        compile(plDistribution self, plDistribution result)
        compile(plDistribution self) -> plDistribution
        compile(plDistribution self, plDistribution result, plCompiledDistributionType compiled_distrib_type)
        """
        return _pypl.plDistribution_compile(self, *args)

    def incremental_n_compile(self, *args):
        """
        incremental_n_compile(plDistribution self, plDistribution result, unsigned int n_iterations, plGeneratorType generatorType=PL_CHOOSE_GENERATOR_FOR_ME, 
            plCompiledDistributionType distrib_type=PL_CHOOSE_COMP_TYPE_FOR_ME)
        incremental_n_compile(plDistribution self, plDistribution result, unsigned int n_iterations, plGeneratorType generatorType=PL_CHOOSE_GENERATOR_FOR_ME)
        incremental_n_compile(plDistribution self, plDistribution result, unsigned int n_iterations)
        """
        return _pypl.plDistribution_incremental_n_compile(self, *args)

    def incremental_time_compile(self, *args):
        """
        incremental_time_compile(plDistribution self, plDistribution result, double time_in_seconds, plGeneratorType generatorType=PL_CHOOSE_GENERATOR_FOR_ME, 
            plCompiledDistributionType distrib_type=PL_CHOOSE_COMP_TYPE_FOR_ME)
        incremental_time_compile(plDistribution self, plDistribution result, double time_in_seconds, plGeneratorType generatorType=PL_CHOOSE_GENERATOR_FOR_ME)
        incremental_time_compile(plDistribution self, plDistribution result, double time_in_seconds)
        """
        return _pypl.plDistribution_incremental_time_compile(self, *args)

    def tabulate(self, *args):
        """
        tabulate(plDistribution self, DoubleVector output)
        tabulate(plDistribution self)
        """
        return _pypl.plDistribution_tabulate(self, *args)

    def sorted_tabulate(self, *args):
        """sorted_tabulate(plDistribution self, std::vector< std::pair< plValues,plProbValue >,std::allocator< std::pair< plValues,plProbValue > > > & output)"""
        return _pypl.plDistribution_sorted_tabulate(self, *args)

    def plot(self, *args):
        """
        plot(plDistribution self, std::string const & file_name, plPlotType plottype=PL_DEFAULT_PLOT, int n_samples=100)
        plot(plDistribution self, std::string const & file_name, plPlotType plottype=PL_DEFAULT_PLOT)
        plot(plDistribution self, std::string const & file_name)
        plot(plDistribution self, char const * file_name, plPlotType plottype=PL_DEFAULT_PLOT, int n_samples=100)
        """
        return _pypl.plDistribution_plot(self, *args)

    def time_best(self, *args):
        """
        time_best(plDistribution self, int * result, double time_in_seconds)
        time_best(plDistribution self, unsigned int * result, double time_in_seconds)
        time_best(plDistribution self, float * result, double time_in_seconds)
        time_best(plDistribution self, double * result, double time_in_seconds)
        time_best(plDistribution self, long double * result, double time_in_seconds)
        time_best(plDistribution self, int & result, double time_in_seconds)
        time_best(plDistribution self, unsigned int & result, double time_in_seconds)
        time_best(plDistribution self, float & result, double time_in_seconds)
        time_best(plDistribution self, double & result, double time_in_seconds)
        time_best(plDistribution self, long double & result, double time_in_seconds)
        time_best(plDistribution self, IntVector result, double time_in_seconds)
        time_best(plDistribution self, UnsignedIntVector result, double time_in_seconds)
        time_best(plDistribution self, FloatVector result, double time_in_seconds)
        time_best(plDistribution self, DoubleVector result, double time_in_seconds)
        time_best(plDistribution self, LongDoubleVector result, double time_in_seconds)
        time_best(plDistribution self, plValues res, double time_in_seconds)
        time_best(plDistribution self, double time_in_seconds) -> plValues
        """
        return _pypl.plDistribution_time_best(self, *args)

    def n_best(self, *args):
        """
        n_best(plDistribution self, plValues res, unsigned int n)
        n_best(plDistribution self, unsigned int n) -> plValues
        n_best(plDistribution self, int * result, unsigned int n)
        n_best(plDistribution self, unsigned int * result, unsigned int n)
        n_best(plDistribution self, float * result, unsigned int n)
        n_best(plDistribution self, double * result, unsigned int n)
        n_best(plDistribution self, long double * result, unsigned int n)
        n_best(plDistribution self, int & result, unsigned int n)
        n_best(plDistribution self, unsigned int & result, unsigned int n)
        n_best(plDistribution self, float & result, unsigned int n)
        n_best(plDistribution self, double & result, unsigned int n)
        n_best(plDistribution self, long double & result, unsigned int n)
        n_best(plDistribution self, IntVector parameter, unsigned int n)
        n_best(plDistribution self, UnsignedIntVector parameter, unsigned int n)
        n_best(plDistribution self, FloatVector parameter, unsigned int n)
        n_best(plDistribution self, DoubleVector parameter, unsigned int n)
        n_best(plDistribution self, LongDoubleVector parameter, unsigned int n)
        """
        return _pypl.plDistribution_n_best(self, *args)

    def draw(self, *args):
        """
        draw(plDistribution self, plValues res)
        draw(plDistribution self) -> plValues
        draw(plDistribution self, int * resuls)
        draw(plDistribution self, unsigned int * resuls)
        draw(plDistribution self, float * resuls)
        draw(plDistribution self, double * resuls)
        draw(plDistribution self, long double * resuls)
        draw(plDistribution self, int & result)
        draw(plDistribution self, unsigned int & result)
        draw(plDistribution self, float & result)
        draw(plDistribution self, double & result)
        draw(plDistribution self, long double & result)
        draw(plDistribution self, IntVector result)
        draw(plDistribution self, UnsignedIntVector result)
        draw(plDistribution self, FloatVector result)
        draw(plDistribution self, DoubleVector result)
        draw(plDistribution self, LongDoubleVector result)
        draw(plDistribution self, plValues res, plValues initial_state, DoubleVector proposal_standard_deviation, unsigned int n, 
            plFloat & probability_log)
        draw(plDistribution self, int * parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        draw(plDistribution self, unsigned int * parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        draw(plDistribution self, float * parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        draw(plDistribution self, double * parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        draw(plDistribution self, long double * parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        draw(plDistribution self, int & parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        draw(plDistribution self, unsigned int & parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        draw(plDistribution self, float & parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        draw(plDistribution self, double & parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        draw(plDistribution self, long double & parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        draw(plDistribution self, IntVector parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        draw(plDistribution self, UnsignedIntVector parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        draw(plDistribution self, FloatVector parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        draw(plDistribution self, DoubleVector parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        draw(plDistribution self, LongDoubleVector parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        """
        return _pypl.plDistribution_draw(self, *args)

    def best(self, *args):
        """
        best(plDistribution self, plValues res)
        best(plDistribution self) -> plValues
        best(plDistribution self, int * result)
        best(plDistribution self, unsigned int * result)
        best(plDistribution self, float * result)
        best(plDistribution self, double * result)
        best(plDistribution self, long double * result)
        best(plDistribution self, int & result)
        best(plDistribution self, unsigned int & result)
        best(plDistribution self, float & result)
        best(plDistribution self, double & result)
        best(plDistribution self, long double & result)
        best(plDistribution self, IntVector result)
        best(plDistribution self, UnsignedIntVector result)
        best(plDistribution self, FloatVector result)
        best(plDistribution self, DoubleVector result)
        best(plDistribution self, LongDoubleVector result)
        best(plDistribution self, plValues res, plValues initial_state, DoubleVector proposal_standard_deviation, unsigned int n, 
            plFloat & probability_log)
        best(plDistribution self, int * parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        best(plDistribution self, unsigned int * parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        best(plDistribution self, float * parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        best(plDistribution self, double * parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        best(plDistribution self, long double * parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        best(plDistribution self, int & parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        best(plDistribution self, unsigned int & parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        best(plDistribution self, float & parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        best(plDistribution self, double & parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        best(plDistribution self, long double & parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        best(plDistribution self, IntVector parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        best(plDistribution self, UnsignedIntVector parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        best(plDistribution self, FloatVector parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        best(plDistribution self, DoubleVector parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        best(plDistribution self, LongDoubleVector parameter, plValues initial_state, DoubleVector proposal_standard_deviation, 
            unsigned int n, plFloat & probability_log)
        """
        return _pypl.plDistribution_best(self, *args)

    def compute_shannon_entropy(self):
        """compute_shannon_entropy(plDistribution self) -> plFloat"""
        return _pypl.plDistribution_compute_shannon_entropy(self)

    def kullback_leibler_divergence_to(self, *args):
        """kullback_leibler_divergence_to(plDistribution self, plDistribution q) -> plFloat"""
        return _pypl.plDistribution_kullback_leibler_divergence_to(self, *args)

    def is_null(self):
        """is_null(plDistribution self) -> bool"""
        return _pypl.plDistribution_is_null(self)

    def as_builtin(*args):
        """as_builtin(plDistribution k) -> plDistribution"""
        return _pypl.plDistribution_as_builtin(*args)

    if _newclass:as_builtin = staticmethod(as_builtin)
    __swig_getmethods__["as_builtin"] = lambda x: as_builtin
    def compute(self, *args):
        """
        compute(plDistribution self, plValues values) -> plProbValue
        compute(plDistribution self, int const * values) -> plProbValue
        compute(plDistribution self, unsigned int const * values) -> plProbValue
        compute(plDistribution self, float const * values) -> plProbValue
        compute(plDistribution self, double const * values) -> plProbValue
        compute(plDistribution self, IntVector parameter) -> plProbValue
        compute(plDistribution self, UnsignedIntVector parameter) -> plProbValue
        compute(plDistribution self, FloatVector parameter) -> plProbValue
        compute(plDistribution self, DoubleVector parameter) -> plProbValue
        compute(plDistribution self, int value) -> plProbValue
        compute(plDistribution self, unsigned int value) -> plProbValue
        compute(plDistribution self, float value) -> plProbValue
        compute(plDistribution self, double value) -> plProbValue
        compute(plDistribution self, long double value) -> plProbValue
        compute(plDistribution self, std::string const & value) -> plProbValue
        """
        return _pypl.plDistribution_compute(self, *args)

    def compute_log(self, *args):
        """
        compute_log(plDistribution self, plValues values) -> plFloat
        compute_log(plDistribution self, int const * values) -> plFloat
        compute_log(plDistribution self, unsigned int const * values) -> plFloat
        compute_log(plDistribution self, float const * values) -> plFloat
        compute_log(plDistribution self, double const * values) -> plFloat
        compute_log(plDistribution self, IntVector parameter) -> plFloat
        compute_log(plDistribution self, UnsignedIntVector parameter) -> plFloat
        compute_log(plDistribution self, FloatVector parameter) -> plFloat
        compute_log(plDistribution self, DoubleVector parameter) -> plFloat
        compute_log(plDistribution self, int value) -> plFloat
        compute_log(plDistribution self, unsigned int value) -> plFloat
        compute_log(plDistribution self, float value) -> plFloat
        compute_log(plDistribution self, double value) -> plFloat
        compute_log(plDistribution self, long double value) -> plFloat
        compute_log(plDistribution self, std::string const & value) -> plFloat
        """
        return _pypl.plDistribution_compute_log(self, *args)

    def set_soft_evidence(self, *args):
        """set_soft_evidence(plDistribution self, plDistribution soft_evidence)"""
        return _pypl.plDistribution_set_soft_evidence(self, *args)

    def set_soft_evidences(self, *args):
        """set_soft_evidences(plDistribution self, plComputableObjectList soft_evidences)"""
        return _pypl.plDistribution_set_soft_evidences(self, *args)

    def remove_soft_evidence(self, *args):
        """remove_soft_evidence(plDistribution self, plSymbol variable)"""
        return _pypl.plDistribution_remove_soft_evidence(self, *args)

    def clear_soft_evidences(self):
        """clear_soft_evidences(plDistribution self)"""
        return _pypl.plDistribution_clear_soft_evidences(self)

    def compute_expectation(self, *args):
        """
        compute_expectation(plDistribution self, plValues res)
        compute_expectation(plDistribution self, DoubleVector res)
        compute_expectation(plDistribution self) -> plValues
        """
        return _pypl.plDistribution_compute_expectation(self, *args)

plDistribution_swigregister = _pypl.plDistribution_swigregister
plDistribution_swigregister(plDistribution)

def plDistribution_as_builtin(*args):
  """plDistribution_as_builtin(plDistribution k) -> plDistribution"""
  return _pypl.plDistribution_as_builtin(*args)

class plAnonymousDistribution(plDistribution):
    """Proxy of C++ plAnonymousDistribution class"""
    __swig_setmethods__ = {}
    for _s in [plDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plAnonymousDistribution, name, value)
    __swig_getmethods__ = {}
    for _s in [plDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plAnonymousDistribution, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plAnonymousDistribution
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plAnonymousDistribution self) -> plAnonymousDistribution
        __init__(plAnonymousDistribution self, plVariablesConjunction variable, plExternalProbFunction function) -> plAnonymousDistribution
        __init__(plAnonymousDistribution self, plExternalProbFunction function) -> plAnonymousDistribution
        __init__(plAnonymousDistribution self, plDistribution arg2) -> plAnonymousDistribution
        """
        this = _pypl.new_plAnonymousDistribution(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_prob_function(self):
        """get_prob_function(plAnonymousDistribution self) -> plExternalProbFunction"""
        return _pypl.plAnonymousDistribution_get_prob_function(self)

    def is_base_class(self):
        """is_base_class(plAnonymousDistribution self) -> bool"""
        return _pypl.plAnonymousDistribution_is_base_class(self)

plAnonymousDistribution_swigregister = _pypl.plAnonymousDistribution_swigregister
plAnonymousDistribution_swigregister(plAnonymousDistribution)

class plBeta(plDistribution):
    """Proxy of C++ plBeta class"""
    __swig_setmethods__ = {}
    for _s in [plDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plBeta, name, value)
    __swig_getmethods__ = {}
    for _s in [plDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plBeta, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plBeta
    __del__ = lambda self : None;
    def get_parameters(self):
        """get_parameters(plBeta self)"""
        return _pypl.plBeta_get_parameters(self)

    def __init__(self, *args): 
        """
        __init__(plBeta self) -> plBeta
        __init__(plBeta self, plSymbol V, plFloat p, plFloat q, plFloat a=0.0, plFloat b=1.0) -> plBeta
        __init__(plBeta self, plSymbol V, plFloat p, plFloat q, plFloat a=0.0) -> plBeta
        __init__(plBeta self, plSymbol V, plFloat p, plFloat q) -> plBeta
        __init__(plBeta self, plDistribution arg2) -> plBeta
        """
        this = _pypl.new_plBeta(*args)
        try: self.this.append(this)
        except: self.this = this
    def is_base_class(self):
        """is_base_class(plBeta self) -> bool"""
        return _pypl.plBeta_is_base_class(self)

plBeta_swigregister = _pypl.plBeta_swigregister
plBeta_swigregister(plBeta)

class plDirichlet(plDistribution):
    """Proxy of C++ plDirichlet class"""
    __swig_setmethods__ = {}
    for _s in [plDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plDirichlet, name, value)
    __swig_getmethods__ = {}
    for _s in [plDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plDirichlet, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plDirichlet
    __del__ = lambda self : None;
    def get_parameters(self, *args):
        """get_parameters(plDirichlet self, DoubleVector alpha)"""
        return _pypl.plDirichlet_get_parameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(plDirichlet self) -> plDirichlet
        __init__(plDirichlet self, plVariablesConjunction variables, DoubleVector alpha) -> plDirichlet
        __init__(plDirichlet self, plDistribution arg2) -> plDirichlet
        """
        this = _pypl.new_plDirichlet(*args)
        try: self.this.append(this)
        except: self.this = this
    def is_base_class(self):
        """is_base_class(plDirichlet self) -> bool"""
        return _pypl.plDirichlet_is_base_class(self)

plDirichlet_swigregister = _pypl.plDirichlet_swigregister
plDirichlet_swigregister(plDirichlet)

class plExponential(plDistribution):
    """Proxy of C++ plExponential class"""
    __swig_setmethods__ = {}
    for _s in [plDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plExponential, name, value)
    __swig_getmethods__ = {}
    for _s in [plDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plExponential, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plExponential
    __del__ = lambda self : None;
    def get_parameters(self):
        """get_parameters(plExponential self)"""
        return _pypl.plExponential_get_parameters(self)

    def __init__(self, *args): 
        """
        __init__(plExponential self) -> plExponential
        __init__(plExponential self, plSymbol V, plFloat beta, plFloat mu=0.0) -> plExponential
        __init__(plExponential self, plSymbol V, plFloat beta) -> plExponential
        __init__(plExponential self, plDistribution arg2) -> plExponential
        """
        this = _pypl.new_plExponential(*args)
        try: self.this.append(this)
        except: self.this = this
    def is_base_class(self):
        """is_base_class(plExponential self) -> bool"""
        return _pypl.plExponential_is_base_class(self)

plExponential_swigregister = _pypl.plExponential_swigregister
plExponential_swigregister(plExponential)

class plGamma(plDistribution):
    """Proxy of C++ plGamma class"""
    __swig_setmethods__ = {}
    for _s in [plDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plGamma, name, value)
    __swig_getmethods__ = {}
    for _s in [plDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plGamma, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plGamma
    __del__ = lambda self : None;
    def get_parameters(self):
        """get_parameters(plGamma self)"""
        return _pypl.plGamma_get_parameters(self)

    def __init__(self, *args): 
        """
        __init__(plGamma self) -> plGamma
        __init__(plGamma self, plSymbol variable, plFloat alpha, plFloat theta, plFloat mu=0.0) -> plGamma
        __init__(plGamma self, plSymbol variable, plFloat alpha, plFloat theta) -> plGamma
        __init__(plGamma self, plDistribution arg2) -> plGamma
        """
        this = _pypl.new_plGamma(*args)
        try: self.this.append(this)
        except: self.this = this
    def is_base_class(self):
        """is_base_class(plGamma self) -> bool"""
        return _pypl.plGamma_is_base_class(self)

plGamma_swigregister = _pypl.plGamma_swigregister
plGamma_swigregister(plGamma)


def plLgamma(*args):
  """plLgamma(plFloat x) -> plFloat"""
  return _pypl.plLgamma(*args)

def plGammaFunc(*args):
  """plGammaFunc(plFloat x) -> plFloat"""
  return _pypl.plGammaFunc(*args)

def plIncompleteGammaFunc(*args):
  """plIncompleteGammaFunc(plFloat a, plFloat x) -> plFloat"""
  return _pypl.plIncompleteGammaFunc(*args)

def plIncompleteGammaCFunc(*args):
  """plIncompleteGammaCFunc(plFloat a, plFloat x) -> plFloat"""
  return _pypl.plIncompleteGammaCFunc(*args)
class plLogNormal(plDistribution):
    """Proxy of C++ plLogNormal class"""
    __swig_setmethods__ = {}
    for _s in [plDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLogNormal, name, value)
    __swig_getmethods__ = {}
    for _s in [plDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLogNormal, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plLogNormal
    __del__ = lambda self : None;
    def get_parameters(self, *args):
        """get_parameters(plLogNormal self, plFloat & sigma, plFloat & m, plFloat & theta)"""
        return _pypl.plLogNormal_get_parameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(plLogNormal self) -> plLogNormal
        __init__(plLogNormal self, plSymbol V, plFloat sigma, plFloat m=1.0, plFloat theta=0.0) -> plLogNormal
        __init__(plLogNormal self, plSymbol V, plFloat sigma, plFloat m=1.0) -> plLogNormal
        __init__(plLogNormal self, plSymbol V, plFloat sigma) -> plLogNormal
        __init__(plLogNormal self, plDistribution arg2) -> plLogNormal
        """
        this = _pypl.new_plLogNormal(*args)
        try: self.this.append(this)
        except: self.this = this
    def is_base_class(self):
        """is_base_class(plLogNormal self) -> bool"""
        return _pypl.plLogNormal_is_base_class(self)

plLogNormal_swigregister = _pypl.plLogNormal_swigregister
plLogNormal_swigregister(plLogNormal)

class plWeibull(plDistribution):
    """Proxy of C++ plWeibull class"""
    __swig_setmethods__ = {}
    for _s in [plDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plWeibull, name, value)
    __swig_getmethods__ = {}
    for _s in [plDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plWeibull, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plWeibull
    __del__ = lambda self : None;
    def get_parameters(self, *args):
        """get_parameters(plWeibull self, plFloat & gamma, plFloat & alpha, plFloat & mu)"""
        return _pypl.plWeibull_get_parameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(plWeibull self) -> plWeibull
        __init__(plWeibull self, plSymbol variable, plFloat gamma, plFloat alpha=1.0, plFloat mu=0.0) -> plWeibull
        __init__(plWeibull self, plSymbol variable, plFloat gamma, plFloat alpha=1.0) -> plWeibull
        __init__(plWeibull self, plSymbol variable, plFloat gamma) -> plWeibull
        __init__(plWeibull self, plDistribution arg2) -> plWeibull
        """
        this = _pypl.new_plWeibull(*args)
        try: self.this.append(this)
        except: self.this = this
    def is_base_class(self):
        """is_base_class(plWeibull self) -> bool"""
        return _pypl.plWeibull_is_base_class(self)

plWeibull_swigregister = _pypl.plWeibull_swigregister
plWeibull_swigregister(plWeibull)

class plNormal(plDistribution):
    """Proxy of C++ plNormal class"""
    __swig_setmethods__ = {}
    for _s in [plDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plNormal, name, value)
    __swig_getmethods__ = {}
    for _s in [plDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plNormal, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plNormal
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plNormal self) -> plNormal
        __init__(plNormal self, plVariablesConjunction V, plFloatVector mu, plFloatMatrix Sigma) -> plNormal
        __init__(plNormal self, plSymbol V, plFloat mu, plFloat sigma) -> plNormal
        __init__(plNormal self, plDistribution arg2) -> plNormal
        """
        this = _pypl.new_plNormal(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_parameters(self, *args):
        """
        get_parameters(plNormal self)
        get_parameters(plNormal self, plFloat & m, plFloat & sd)
        """
        return _pypl.plNormal_get_parameters(self, *args)

    def mean(self):
        """mean(plNormal self) -> plFloat"""
        return _pypl.plNormal_mean(self)

    def standard_deviation(self):
        """standard_deviation(plNormal self) -> plFloat"""
        return _pypl.plNormal_standard_deviation(self)

    def eigen_values(self):
        """eigen_values(plNormal self) -> plFloatVector"""
        return _pypl.plNormal_eigen_values(self)

    def eigen_matrix(self):
        """eigen_matrix(plNormal self) -> plFloatMatrix"""
        return _pypl.plNormal_eigen_matrix(self)

    def mahalanobis(self, *args):
        """mahalanobis(plNormal self, plFloatVector val) -> plFloat"""
        return _pypl.plNormal_mahalanobis(self, *args)

    def mahalanobis_values(self, *args):
        """mahalanobis_values(plNormal self, plValues val) -> plFloat"""
        return _pypl.plNormal_mahalanobis_values(self, *args)

plNormal_swigregister = _pypl.plNormal_swigregister
plNormal_swigregister(plNormal)

plBeta.__repr__ = plBeta.__str__
plDirichlet.__repr__ = plDirichlet.__str__
plExponential.__repr__ = plExponential.__str__
plGamma.__repr__ = plGamma.__str__
plLogNormal.__repr__ = plLogNormal.__str__
plWeibull.__repr__ = plWeibull.__str__
plNormal.__repr__ = plNormal.__str__


class plCndJtDistribution(_object):
    """Proxy of C++ plCndJtDistribution class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndJtDistribution, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plCndJtDistribution, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCndJtDistribution self) -> plCndJtDistribution
        __init__(plCndJtDistribution self, kplCndJtKernel const & vroot) -> plCndJtDistribution
        """
        this = _pypl.new_plCndJtDistribution(*args)
        try: self.this.append(this)
        except: self.this = this
    def specialise(self, *args):
        """specialise(plCndJtDistribution self, plVariablesConjunction added_known) -> plCndJtDistribution"""
        return _pypl.plCndJtDistribution_specialise(self, *args)

    def output_dot(self):
        """output_dot(plCndJtDistribution self)"""
        return _pypl.plCndJtDistribution_output_dot(self)

    __swig_destroy__ = _pypl.delete_plCndJtDistribution
    __del__ = lambda self : None;
plCndJtDistribution_swigregister = _pypl.plCndJtDistribution_swigregister
plCndJtDistribution_swigregister(plCndJtDistribution)

class plJtDistribution(plDistribution):
    """Proxy of C++ plJtDistribution class"""
    __swig_setmethods__ = {}
    for _s in [plDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plJtDistribution, name, value)
    __swig_getmethods__ = {}
    for _s in [plDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plJtDistribution, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plJtDistribution self) -> plJtDistribution
        __init__(plJtDistribution self, kplJtKernel const & vroot) -> plJtDistribution
        """
        this = _pypl.new_plJtDistribution(*args)
        try: self.this.append(this)
        except: self.this = this
    def specialise(self, *args):
        """specialise(plJtDistribution self, plVariablesConjunction added_known) -> plCndJtDistribution"""
        return _pypl.plJtDistribution_specialise(self, *args)

    def output_dot(self):
        """output_dot(plJtDistribution self)"""
        return _pypl.plJtDistribution_output_dot(self)

    __swig_destroy__ = _pypl.delete_plJtDistribution
    __del__ = lambda self : None;
plJtDistribution_swigregister = _pypl.plJtDistribution_swigregister
plJtDistribution_swigregister(plJtDistribution)

class plDeterministic(plDistribution):
    """Proxy of C++ plDeterministic class"""
    __swig_setmethods__ = {}
    for _s in [plDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plDeterministic, name, value)
    __swig_getmethods__ = {}
    for _s in [plDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plDeterministic, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plDeterministic
    __del__ = lambda self : None;
    def get_dirac_point(self):
        """get_dirac_point(plDeterministic self) -> plValues"""
        return _pypl.plDeterministic_get_dirac_point(self)

    def __init__(self, *args): 
        """
        __init__(plDeterministic self) -> plDeterministic
        __init__(plDeterministic self, plVariablesConjunction variables, plValues values) -> plDeterministic
        __init__(plDeterministic self, plDistribution arg2) -> plDeterministic
        """
        this = _pypl.new_plDeterministic(*args)
        try: self.this.append(this)
        except: self.this = this
    def is_base_class(self):
        """is_base_class(plDeterministic self) -> bool"""
        return _pypl.plDeterministic_is_base_class(self)

plDeterministic_swigregister = _pypl.plDeterministic_swigregister
plDeterministic_swigregister(plDeterministic)

class plBinomial(plDistribution):
    """Proxy of C++ plBinomial class"""
    __swig_setmethods__ = {}
    for _s in [plDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plBinomial, name, value)
    __swig_getmethods__ = {}
    for _s in [plDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plBinomial, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plBinomial
    __del__ = lambda self : None;
    def get_p(self):
        """get_p(plBinomial self) -> plProbValue"""
        return _pypl.plBinomial_get_p(self)

    def __init__(self, *args): 
        """
        __init__(plBinomial self) -> plBinomial
        __init__(plBinomial self, plSymbol variable, plProbValue p) -> plBinomial
        __init__(plBinomial self, plDistribution arg2) -> plBinomial
        """
        this = _pypl.new_plBinomial(*args)
        try: self.this.append(this)
        except: self.this = this
    def is_base_class(self):
        """is_base_class(plBinomial self) -> bool"""
        return _pypl.plBinomial_is_base_class(self)

plBinomial_swigregister = _pypl.plBinomial_swigregister
plBinomial_swigregister(plBinomial)

class plPoisson(plDistribution):
    """Proxy of C++ plPoisson class"""
    __swig_setmethods__ = {}
    for _s in [plDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plPoisson, name, value)
    __swig_getmethods__ = {}
    for _s in [plDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plPoisson, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plPoisson
    __del__ = lambda self : None;
    def get_parameters(self):
        """get_parameters(plPoisson self)"""
        return _pypl.plPoisson_get_parameters(self)

    def __init__(self, *args): 
        """
        __init__(plPoisson self) -> plPoisson
        __init__(plPoisson self, plSymbol v, plFloat mean) -> plPoisson
        __init__(plPoisson self, plDistribution arg2) -> plPoisson
        """
        this = _pypl.new_plPoisson(*args)
        try: self.this.append(this)
        except: self.this = this
    def is_base_class(self):
        """is_base_class(plPoisson self) -> bool"""
        return _pypl.plPoisson_is_base_class(self)

plPoisson_swigregister = _pypl.plPoisson_swigregister
plPoisson_swigregister(plPoisson)

class plUniform(plDistribution):
    """Proxy of C++ plUniform class"""
    __swig_setmethods__ = {}
    for _s in [plDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plUniform, name, value)
    __swig_getmethods__ = {}
    for _s in [plDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plUniform, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plUniform self) -> plUniform
        __init__(plUniform self, plSymbol variable) -> plUniform
        __init__(plUniform self, plVariablesConjunction variables) -> plUniform
        __init__(plUniform self, plDistribution arg2) -> plUniform
        """
        this = _pypl.new_plUniform(*args)
        try: self.this.append(this)
        except: self.this = this
    def is_base_class(self):
        """is_base_class(plUniform self) -> bool"""
        return _pypl.plUniform_is_base_class(self)

    __swig_destroy__ = _pypl.delete_plUniform
    __del__ = lambda self : None;
plUniform_swigregister = _pypl.plUniform_swigregister
plUniform_swigregister(plUniform)

plBinomial.__repr__ = plBinomial.__str__
plPoisson.__repr__ = plPoisson.__str__
plUniform.__repr__ = plUniform.__str__


class plProbTable(plDistribution):
    """Proxy of C++ plProbTable class"""
    __swig_setmethods__ = {}
    for _s in [plDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plProbTable, name, value)
    __swig_getmethods__ = {}
    for _s in [plDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plProbTable, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plProbTable
    __del__ = lambda self : None;
    def get_parameters(self, *args):
        """get_parameters(plProbTable self, DoubleVector values)"""
        return _pypl.plProbTable_get_parameters(self, *args)

    def __init__(self, *args): 
        """
        __init__(plProbTable self) -> plProbTable
        __init__(plProbTable self, plVariablesConjunction V, bool random_prob_values=False) -> plProbTable
        __init__(plProbTable self, plVariablesConjunction V) -> plProbTable
        __init__(plProbTable self, plVariablesConjunction V, double const * values, bool is_already_normalized=False) -> plProbTable
        __init__(plProbTable self, plVariablesConjunction V, double const * values) -> plProbTable
        __init__(plProbTable self, plVariablesConjunction V, float const * values, bool is_already_normalized=False) -> plProbTable
        __init__(plProbTable self, plVariablesConjunction V, float const * values) -> plProbTable
        __init__(plProbTable self, plVariablesConjunction V, DoubleVector values, bool is_already_normalized=False) -> plProbTable
        __init__(plProbTable self, plVariablesConjunction V, DoubleVector values) -> plProbTable
        __init__(plProbTable self, plVariablesConjunction V, FloatVector values, bool is_already_normalized=False) -> plProbTable
        __init__(plProbTable self, plVariablesConjunction V, FloatVector values) -> plProbTable
        __init__(plProbTable self, plDistribution arg2) -> plProbTable
        """
        this = _pypl.new_plProbTable(*args)
        try: self.this.append(this)
        except: self.this = this
    def table(self):
        """table(plProbTable self) -> DoubleVector"""
        return _pypl.plProbTable_table(self)

    def is_base_class(self):
        """is_base_class(plProbTable self) -> bool"""
        return _pypl.plProbTable_is_base_class(self)

plProbTable_swigregister = _pypl.plProbTable_swigregister
plProbTable_swigregister(plProbTable)

class plUnknown(plDistribution):
    """Proxy of C++ plUnknown class"""
    __swig_setmethods__ = {}
    for _s in [plDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plUnknown, name, value)
    __swig_getmethods__ = {}
    for _s in [plDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plUnknown, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plUnknown
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plUnknown self) -> plUnknown
        __init__(plUnknown self, plVariablesConjunction variable) -> plUnknown
        __init__(plUnknown self, plDistribution arg2) -> plUnknown
        """
        this = _pypl.new_plUnknown(*args)
        try: self.this.append(this)
        except: self.this = this
    def is_base_class(self):
        """is_base_class(plUnknown self) -> bool"""
        return _pypl.plUnknown_is_base_class(self)

plUnknown_swigregister = _pypl.plUnknown_swigregister
plUnknown_swigregister(plUnknown)

class plCndDistribution(plComputableObject):
    """Proxy of C++ plCndDistribution class"""
    __swig_setmethods__ = {}
    for _s in [plComputableObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndDistribution, name, value)
    __swig_getmethods__ = {}
    for _s in [plComputableObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndDistribution, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCndDistribution self) -> plCndDistribution
        __init__(plCndDistribution self, plVariablesConjunction left, plVariablesConjunction right, plComputableObjectType const & sig) -> plCndDistribution
        __init__(plCndDistribution self, plCndDistribution cnd_distribution) -> plCndDistribution
        __init__(plCndDistribution self, plComputableObject arg2) -> plCndDistribution
        __init__(plCndDistribution self, plComputableObjectList fun_list) -> plCndDistribution
        __init__(plCndDistribution self, plComputableObjectList func_lis, plVariablesConjunction left_variables, plVariablesConjunction right_variables) -> plCndDistribution
        __init__(plCndDistribution self, plVariablesConjunction left, plVariablesConjunction right, plProbValue const * table, 
            bool already_normalized=False) -> plCndDistribution
        __init__(plCndDistribution self, plVariablesConjunction left, plVariablesConjunction right, plProbValue const * table) -> plCndDistribution
        __init__(plCndDistribution self, plVariablesConjunction left, plVariablesConjunction right, DoubleVector table, bool already_normalized=False) -> plCndDistribution
        __init__(plCndDistribution self, plVariablesConjunction left, plVariablesConjunction right, DoubleVector table) -> plCndDistribution
        __init__(plCndDistribution self, plVariablesConjunction left, plVariablesConjunction right) -> plCndDistribution
        """
        this = _pypl.new_plCndDistribution(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plCndDistribution
    __del__ = lambda self : None;
    def partial_instantiate(self, *args):
        """
        partial_instantiate(plCndDistribution self, plCndDistribution distribution_to_instantiate, plVariablesConjunction variables_to_instantiate, 
            plValues values)
        partial_instantiate(plCndDistribution self, plVariablesConjunction variables_to_instantiate, plValues values) -> plCndDistribution
        """
        return _pypl.plCndDistribution_partial_instantiate(self, *args)

    def instantiate(self, *args):
        """
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, plValues values, bool ensure_normalization_on_compute=True)
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, plValues values)
        instantiate(plCndDistribution self, plValues values, bool ensure_normalization_on_compute=True) -> plDistribution
        instantiate(plCndDistribution self, plValues values) -> plDistribution
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, int const * parameter, bool ensure_normalization_on_compute=True)
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, int const * parameter)
        instantiate(plCndDistribution self, int const * parameter, bool ensure_normalization_on_compute=True) -> plDistribution
        instantiate(plCndDistribution self, int const * parameter) -> plDistribution
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, unsigned int const * parameter, bool ensure_normalization_on_compute=True)
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, unsigned int const * parameter)
        instantiate(plCndDistribution self, unsigned int const * parameter, bool ensure_normalization_on_compute=True) -> plDistribution
        instantiate(plCndDistribution self, unsigned int const * parameter) -> plDistribution
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, float const * parameter, bool ensure_normalization_on_compute=True)
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, float const * parameter)
        instantiate(plCndDistribution self, float const * parameter, bool ensure_normalization_on_compute=True) -> plDistribution
        instantiate(plCndDistribution self, float const * parameter) -> plDistribution
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, double const * parameter, bool ensure_normalization_on_compute=True)
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, double const * parameter)
        instantiate(plCndDistribution self, double const * parameter, bool ensure_normalization_on_compute=True) -> plDistribution
        instantiate(plCndDistribution self, double const * parameter) -> plDistribution
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, IntVector parameter, bool ensure_normalization_on_compute=True)
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, IntVector parameter)
        instantiate(plCndDistribution self, IntVector parameter, bool ensure_normalization_on_compute=True) -> plDistribution
        instantiate(plCndDistribution self, IntVector parameter) -> plDistribution
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, UnsignedIntVector parameter, bool ensure_normalization_on_compute=True)
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, UnsignedIntVector parameter)
        instantiate(plCndDistribution self, UnsignedIntVector parameter, bool ensure_normalization_on_compute=True) -> plDistribution
        instantiate(plCndDistribution self, UnsignedIntVector parameter) -> plDistribution
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, FloatVector parameter, bool ensure_normalization_on_compute=True)
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, FloatVector parameter)
        instantiate(plCndDistribution self, FloatVector parameter, bool ensure_normalization_on_compute=True) -> plDistribution
        instantiate(plCndDistribution self, FloatVector parameter) -> plDistribution
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, DoubleVector parameter, bool ensure_normalization_on_compute=True)
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, DoubleVector parameter)
        instantiate(plCndDistribution self, DoubleVector parameter, bool ensure_normalization_on_compute=True) -> plDistribution
        instantiate(plCndDistribution self, DoubleVector parameter) -> plDistribution
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, int parameter, bool ensure_normalization_on_compute=True)
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, int parameter)
        instantiate(plCndDistribution self, int parameter, bool ensure_normalization_on_compute=True) -> plDistribution
        instantiate(plCndDistribution self, int parameter) -> plDistribution
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, unsigned int parameter, bool ensure_normalization_on_compute=True)
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, unsigned int parameter)
        instantiate(plCndDistribution self, unsigned int parameter, bool ensure_normalization_on_compute=True) -> plDistribution
        instantiate(plCndDistribution self, unsigned int parameter) -> plDistribution
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, float parameter, bool ensure_normalization_on_compute=True)
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, float parameter)
        instantiate(plCndDistribution self, float parameter, bool ensure_normalization_on_compute=True) -> plDistribution
        instantiate(plCndDistribution self, float parameter) -> plDistribution
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, double parameter, bool ensure_normalization_on_compute=True)
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, double parameter)
        instantiate(plCndDistribution self, double parameter, bool ensure_normalization_on_compute=True) -> plDistribution
        instantiate(plCndDistribution self, double parameter) -> plDistribution
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, std::string const & parameter, bool ensure_normalization_on_compute=True)
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, std::string const & parameter)
        instantiate(plCndDistribution self, std::string const & parameter, bool ensure_normalization_on_compute=True) -> plDistribution
        instantiate(plCndDistribution self, std::string const & parameter) -> plDistribution
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, char const * parameter, bool ensure_normalization_on_compute=True)
        instantiate(plCndDistribution self, plDistribution distribution_to_instantiate, char const * parameter)
        instantiate(plCndDistribution self, char const * parameter, bool ensure_normalization_on_compute=True) -> plDistribution
        instantiate(plCndDistribution self, char const * parameter) -> plDistribution
        """
        return _pypl.plCndDistribution_instantiate(self, *args)

    def compile_low_memory_use(self, *args):
        """compile_low_memory_use(plCndDistribution self, plCndDistribution result)"""
        return _pypl.plCndDistribution_compile_low_memory_use(self, *args)

    def compile(self, *args):
        """
        compile(plCndDistribution self, plCndDistribution result)
        compile(plCndDistribution self) -> plCndDistribution
        compile(plCndDistribution self, plCndDistribution result, plCompiledDistributionType compiled_distrib_type)
        compile(plCndDistribution self, plCompiledDistributionType compiled_distrib_type) -> plCndDistribution
        """
        return _pypl.plCndDistribution_compile(self, *args)

    def n_compile(self, *args):
        """
        n_compile(plCndDistribution self, plCndDistribution result, unsigned int n_iterations, plGeneratorType generator_type=PL_CHOOSE_GENERATOR_FOR_ME, 
            plCompiledDistributionType compiled_distrib_type=PL_CHOOSE_COMP_TYPE_FOR_ME)
        n_compile(plCndDistribution self, plCndDistribution result, unsigned int n_iterations, plGeneratorType generator_type=PL_CHOOSE_GENERATOR_FOR_ME)
        n_compile(plCndDistribution self, plCndDistribution result, unsigned int n_iterations)
        """
        return _pypl.plCndDistribution_n_compile(self, *args)

    def time_compile(self, *args):
        """
        time_compile(plCndDistribution self, plCndDistribution result, double time_in_seconds, plGeneratorType generator_type=PL_CHOOSE_GENERATOR_FOR_ME, 
            plCompiledDistributionType compiled_distrib_type=PL_CHOOSE_COMP_TYPE_FOR_ME)
        time_compile(plCndDistribution self, plCndDistribution result, double time_in_seconds, plGeneratorType generator_type=PL_CHOOSE_GENERATOR_FOR_ME)
        time_compile(plCndDistribution self, plCndDistribution result, double time_in_seconds)
        time_compile(plCndDistribution self, double time_in_seconds, plGeneratorType generator_type=PL_CHOOSE_GENERATOR_FOR_ME, 
            plCompiledDistributionType distrib_type=PL_CHOOSE_COMP_TYPE_FOR_ME) -> plCndDistribution
        time_compile(plCndDistribution self, double time_in_seconds, plGeneratorType generator_type=PL_CHOOSE_GENERATOR_FOR_ME) -> plCndDistribution
        time_compile(plCndDistribution self, double time_in_seconds) -> plCndDistribution
        """
        return _pypl.plCndDistribution_time_compile(self, *args)

    def as_builtin(*args):
        """as_builtin(plCndDistribution ck) -> plCndDistribution"""
        return _pypl.plCndDistribution_as_builtin(*args)

    if _newclass:as_builtin = staticmethod(as_builtin)
    __swig_getmethods__["as_builtin"] = lambda x: as_builtin
    def compute(self, *args):
        """
        compute(plCndDistribution self, plValues values) -> plProbValue
        compute(plCndDistribution self, int const * values) -> plProbValue
        compute(plCndDistribution self, unsigned int const * values) -> plProbValue
        compute(plCndDistribution self, float const * values) -> plProbValue
        compute(plCndDistribution self, double const * values) -> plProbValue
        compute(plCndDistribution self, IntVector parameter) -> plProbValue
        compute(plCndDistribution self, UnsignedIntVector parameter) -> plProbValue
        compute(plCndDistribution self, FloatVector parameter) -> plProbValue
        compute(plCndDistribution self, DoubleVector parameter) -> plProbValue
        compute(plCndDistribution self, plValues left_params, plValues right_params) -> plProbValue
        compute(plCndDistribution self, int const * left_params, int const * right_params) -> plProbValue
        compute(plCndDistribution self, unsigned int const * left_params, unsigned int const * right_params) -> plProbValue
        compute(plCndDistribution self, float const * left_params, float const * right_params) -> plProbValue
        compute(plCndDistribution self, double const * left_params, double const * right_params) -> plProbValue
        compute(plCndDistribution self, int left_param, int right_param) -> plProbValue
        compute(plCndDistribution self, unsigned int left_param, unsigned int right_param) -> plProbValue
        compute(plCndDistribution self, float left_param, float right_param) -> plProbValue
        compute(plCndDistribution self, double left_param, double right_param) -> plProbValue
        compute(plCndDistribution self, IntVector left_params, IntVector right_params) -> plProbValue
        compute(plCndDistribution self, UnsignedIntVector left_params, UnsignedIntVector right_params) -> plProbValue
        compute(plCndDistribution self, FloatVector left_params, FloatVector right_params) -> plProbValue
        compute(plCndDistribution self, DoubleVector left_params, DoubleVector right_params) -> plProbValue
        compute(plCndDistribution self, std::string const & left_param, std::string const & right_param) -> plProbValue
        compute(plCndDistribution self, char const * left_param, char const * right_param) -> plProbValue
        """
        return _pypl.plCndDistribution_compute(self, *args)

    def compute_log(self, *args):
        """
        compute_log(plCndDistribution self, plValues values) -> plFloat
        compute_log(plCndDistribution self, int const * values) -> plFloat
        compute_log(plCndDistribution self, unsigned int const * values) -> plFloat
        compute_log(plCndDistribution self, float const * values) -> plFloat
        compute_log(plCndDistribution self, double const * values) -> plFloat
        compute_log(plCndDistribution self, IntVector parameter) -> plFloat
        compute_log(plCndDistribution self, UnsignedIntVector parameter) -> plFloat
        compute_log(plCndDistribution self, FloatVector parameter) -> plFloat
        compute_log(plCndDistribution self, DoubleVector parameter) -> plFloat
        compute_log(plCndDistribution self, plValues left_params, plValues right_params) -> plFloat
        compute_log(plCndDistribution self, int const * left_params, int const * right_params) -> plFloat
        compute_log(plCndDistribution self, unsigned int const * left_params, unsigned int const * right_params) -> plFloat
        compute_log(plCndDistribution self, float const * left_params, float const * right_params) -> plFloat
        compute_log(plCndDistribution self, double const * left_params, double const * right_params) -> plFloat
        compute_log(plCndDistribution self, int left_param, int right_param) -> plFloat
        compute_log(plCndDistribution self, unsigned int left_param, unsigned int right_param) -> plFloat
        compute_log(plCndDistribution self, float left_param, float right_param) -> plFloat
        compute_log(plCndDistribution self, double left_param, double right_param) -> plFloat
        compute_log(plCndDistribution self, IntVector left_params, IntVector right_params) -> plFloat
        compute_log(plCndDistribution self, UnsignedIntVector left_params, UnsignedIntVector right_params) -> plFloat
        compute_log(plCndDistribution self, FloatVector left_params, FloatVector right_params) -> plFloat
        compute_log(plCndDistribution self, DoubleVector left_params, DoubleVector right_params) -> plFloat
        compute_log(plCndDistribution self, std::string const & left_param, std::string const & right_param) -> plFloat
        compute_log(plCndDistribution self, char const * left_param, char const * right_param) -> plFloat
        """
        return _pypl.plCndDistribution_compute_log(self, *args)

plCndDistribution_swigregister = _pypl.plCndDistribution_swigregister
plCndDistribution_swigregister(plCndDistribution)

def plCndDistribution_as_builtin(*args):
  """plCndDistribution_as_builtin(plCndDistribution ck) -> plCndDistribution"""
  return _pypl.plCndDistribution_as_builtin(*args)

class plCndAnonymousDistribution(plCndDistribution):
    """Proxy of C++ plCndAnonymousDistribution class"""
    __swig_setmethods__ = {}
    for _s in [plCndDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndAnonymousDistribution, name, value)
    __swig_getmethods__ = {}
    for _s in [plCndDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndAnonymousDistribution, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plCndAnonymousDistribution
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plCndAnonymousDistribution self) -> plCndAnonymousDistribution
        __init__(plCndAnonymousDistribution self, plVariablesConjunction left_variables, plVariablesConjunction right_variables, plExternalProbFunction function) -> plCndAnonymousDistribution
        __init__(plCndAnonymousDistribution self, plCndDistribution arg2) -> plCndAnonymousDistribution
        """
        this = _pypl.new_plCndAnonymousDistribution(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_prob_function(self):
        """get_prob_function(plCndAnonymousDistribution self) -> plExternalProbFunction"""
        return _pypl.plCndAnonymousDistribution_get_prob_function(self)

    def is_base_class(self):
        """is_base_class(plCndAnonymousDistribution self) -> bool"""
        return _pypl.plCndAnonymousDistribution_is_base_class(self)

plCndAnonymousDistribution_swigregister = _pypl.plCndAnonymousDistribution_swigregister
plCndAnonymousDistribution_swigregister(plCndAnonymousDistribution)

class plCndLogNormal(plCndDistribution):
    """Proxy of C++ plCndLogNormal class"""
    __swig_setmethods__ = {}
    for _s in [plCndDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndLogNormal, name, value)
    __swig_getmethods__ = {}
    for _s in [plCndDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndLogNormal, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plCndLogNormal
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plCndLogNormal self) -> plCndLogNormal
        __init__(plCndLogNormal self, plSymbol left, plSymbol sigma, plFloat m) -> plCndLogNormal
        __init__(plCndLogNormal self, plSymbol left, plFloat sigma, plSymbol m) -> plCndLogNormal
        __init__(plCndLogNormal self, plSymbol left, plVariablesConjunction right, plExternalFunction fsigma, plFloat m) -> plCndLogNormal
        __init__(plCndLogNormal self, plSymbol left, plVariablesConjunction right, plFloat sigma, plExternalFunction fm) -> plCndLogNormal
        __init__(plCndLogNormal self, plSymbol left, plSymbol sigma, plSymbol m) -> plCndLogNormal
        __init__(plCndLogNormal self, plSymbol left, plVariablesConjunction right, plExternalFunction fsigma, plExternalFunction fm) -> plCndLogNormal
        __init__(plCndLogNormal self, plSymbol left, plVariablesConjunction right, plExternalFunction f_sigma_m) -> plCndLogNormal
        __init__(plCndLogNormal self, plCndDistribution arg2) -> plCndLogNormal
        """
        this = _pypl.new_plCndLogNormal(*args)
        try: self.this.append(this)
        except: self.this = this
    def sigma_is_constant(self):
        """sigma_is_constant(plCndLogNormal self) -> bool"""
        return _pypl.plCndLogNormal_sigma_is_constant(self)

    def get_sigma_constant(self):
        """get_sigma_constant(plCndLogNormal self) -> plFloat"""
        return _pypl.plCndLogNormal_get_sigma_constant(self)

    def sigma_is_variable(self):
        """sigma_is_variable(plCndLogNormal self) -> bool"""
        return _pypl.plCndLogNormal_sigma_is_variable(self)

    def get_sigma_variable(self):
        """get_sigma_variable(plCndLogNormal self) -> plSymbol"""
        return _pypl.plCndLogNormal_get_sigma_variable(self)

    def sigma_is_function(self):
        """sigma_is_function(plCndLogNormal self) -> bool"""
        return _pypl.plCndLogNormal_sigma_is_function(self)

    def get_sigma_function(self):
        """get_sigma_function(plCndLogNormal self) -> plExternalFunction"""
        return _pypl.plCndLogNormal_get_sigma_function(self)

    def m_is_constant(self):
        """m_is_constant(plCndLogNormal self) -> bool"""
        return _pypl.plCndLogNormal_m_is_constant(self)

    def get_m_constant(self):
        """get_m_constant(plCndLogNormal self) -> plFloat"""
        return _pypl.plCndLogNormal_get_m_constant(self)

    def m_is_variable(self):
        """m_is_variable(plCndLogNormal self) -> bool"""
        return _pypl.plCndLogNormal_m_is_variable(self)

    def get_m_variable(self):
        """get_m_variable(plCndLogNormal self) -> plSymbol"""
        return _pypl.plCndLogNormal_get_m_variable(self)

    def m_is_function(self):
        """m_is_function(plCndLogNormal self) -> bool"""
        return _pypl.plCndLogNormal_m_is_function(self)

    def get_m_function(self):
        """get_m_function(plCndLogNormal self) -> plExternalFunction"""
        return _pypl.plCndLogNormal_get_m_function(self)

    def sigma_and_m_are_one_function(self):
        """sigma_and_m_are_one_function(plCndLogNormal self) -> bool"""
        return _pypl.plCndLogNormal_sigma_and_m_are_one_function(self)

    def get_sigma_m_function(self):
        """get_sigma_m_function(plCndLogNormal self) -> plExternalFunction"""
        return _pypl.plCndLogNormal_get_sigma_m_function(self)

    def is_base_class(self):
        """is_base_class(plCndLogNormal self) -> bool"""
        return _pypl.plCndLogNormal_is_base_class(self)

plCndLogNormal_swigregister = _pypl.plCndLogNormal_swigregister
plCndLogNormal_swigregister(plCndLogNormal)

class plCndNormal(plCndDistribution):
    """Proxy of C++ plCndNormal class"""
    __swig_setmethods__ = {}
    for _s in [plCndDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndNormal, name, value)
    __swig_getmethods__ = {}
    for _s in [plCndDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndNormal, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plCndNormal
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plCndNormal self) -> plCndNormal
        __init__(plCndNormal self, plSymbol left, plSymbol mean, plFloat std_dev) -> plCndNormal
        __init__(plCndNormal self, plSymbol left, plFloat mean, plSymbol std_dev_var) -> plCndNormal
        __init__(plCndNormal self, plSymbol left, plVariablesConjunction right, plExternalFunction fmean, plFloat std_dev) -> plCndNormal
        __init__(plCndNormal self, plSymbol left, plVariablesConjunction right, plFloat mean, plExternalFunction fsd) -> plCndNormal
        __init__(plCndNormal self, plVariablesConjunction left, plVariablesConjunction mean, plFloatMatrix var_matrix) -> plCndNormal
        __init__(plCndNormal self, plVariablesConjunction left, plFloatVector mean, plVariablesConjunction variance_vars) -> plCndNormal
        __init__(plCndNormal self, plVariablesConjunction left, plVariablesConjunction right, plExternalFunction fm, 
            plFloatMatrix var_matrix) -> plCndNormal
        __init__(plCndNormal self, plVariablesConjunction left, plVariablesConjunction right, plFloatVector mean, plExternalFunction fvariance) -> plCndNormal
        __init__(plCndNormal self, plVariablesConjunction left, plVariablesConjunction mean, plVariablesConjunction variance_vars) -> plCndNormal
        __init__(plCndNormal self, plVariablesConjunction left, plVariablesConjunction right, plExternalFunction fmean, 
            plExternalFunction fvariance) -> plCndNormal
        __init__(plCndNormal self, plVariablesConjunction left, plVariablesConjunction right, plExternalFunction f_mean_variance) -> plCndNormal
        __init__(plCndNormal self, plCndDistribution arg2) -> plCndNormal
        """
        this = _pypl.new_plCndNormal(*args)
        try: self.this.append(this)
        except: self.this = this
    def mean_is_constant(self):
        """mean_is_constant(plCndNormal self) -> bool"""
        return _pypl.plCndNormal_mean_is_constant(self)

    def get_mean_constant(self):
        """get_mean_constant(plCndNormal self) -> plFloatVector"""
        return _pypl.plCndNormal_get_mean_constant(self)

    def mean_is_variable(self):
        """mean_is_variable(plCndNormal self) -> bool"""
        return _pypl.plCndNormal_mean_is_variable(self)

    def get_mean_variable(self):
        """get_mean_variable(plCndNormal self) -> plVariablesConjunction"""
        return _pypl.plCndNormal_get_mean_variable(self)

    def mean_is_function(self):
        """mean_is_function(plCndNormal self) -> bool"""
        return _pypl.plCndNormal_mean_is_function(self)

    def get_mean_function(self):
        """get_mean_function(plCndNormal self) -> plExternalFunction"""
        return _pypl.plCndNormal_get_mean_function(self)

    def variance_is_constant(self):
        """variance_is_constant(plCndNormal self) -> bool"""
        return _pypl.plCndNormal_variance_is_constant(self)

    def get_variance_constant(self):
        """get_variance_constant(plCndNormal self) -> plFloatMatrix"""
        return _pypl.plCndNormal_get_variance_constant(self)

    def variance_is_variable(self):
        """variance_is_variable(plCndNormal self) -> bool"""
        return _pypl.plCndNormal_variance_is_variable(self)

    def get_variance_variable(self):
        """get_variance_variable(plCndNormal self) -> plVariablesConjunction"""
        return _pypl.plCndNormal_get_variance_variable(self)

    def variance_is_function(self):
        """variance_is_function(plCndNormal self) -> bool"""
        return _pypl.plCndNormal_variance_is_function(self)

    def get_variance_function(self):
        """get_variance_function(plCndNormal self) -> plExternalFunction"""
        return _pypl.plCndNormal_get_variance_function(self)

    def mean_and_variance_are_one_function(self):
        """mean_and_variance_are_one_function(plCndNormal self) -> bool"""
        return _pypl.plCndNormal_mean_and_variance_are_one_function(self)

    def get_mean_variance_function(self):
        """get_mean_variance_function(plCndNormal self) -> plExternalFunction"""
        return _pypl.plCndNormal_get_mean_variance_function(self)

    def is_base_class(self):
        """is_base_class(plCndNormal self) -> bool"""
        return _pypl.plCndNormal_is_base_class(self)

plCndNormal_swigregister = _pypl.plCndNormal_swigregister
plCndNormal_swigregister(plCndNormal)

class plCndBinomial(plCndDistribution):
    """Proxy of C++ plCndBinomial class"""
    __swig_setmethods__ = {}
    for _s in [plCndDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndBinomial, name, value)
    __swig_getmethods__ = {}
    for _s in [plCndDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndBinomial, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plCndBinomial
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plCndBinomial self) -> plCndBinomial
        __init__(plCndBinomial self, plSymbol left, plSymbol p) -> plCndBinomial
        __init__(plCndBinomial self, plSymbol left, plVariablesConjunction right, plExternalFunction fp) -> plCndBinomial
        __init__(plCndBinomial self, plCndDistribution arg2) -> plCndBinomial
        """
        this = _pypl.new_plCndBinomial(*args)
        try: self.this.append(this)
        except: self.this = this
    def p_is_variable(self):
        """p_is_variable(plCndBinomial self) -> bool"""
        return _pypl.plCndBinomial_p_is_variable(self)

    def get_p_variable(self):
        """get_p_variable(plCndBinomial self) -> plVariablesConjunction"""
        return _pypl.plCndBinomial_get_p_variable(self)

    def p_is_function(self):
        """p_is_function(plCndBinomial self) -> bool"""
        return _pypl.plCndBinomial_p_is_function(self)

    def get_p_function(self):
        """get_p_function(plCndBinomial self) -> plExternalFunction"""
        return _pypl.plCndBinomial_get_p_function(self)

    def is_base_class(self):
        """is_base_class(plCndBinomial self) -> bool"""
        return _pypl.plCndBinomial_is_base_class(self)

plCndBinomial_swigregister = _pypl.plCndBinomial_swigregister
plCndBinomial_swigregister(plCndBinomial)

class plCndPoisson(plCndDistribution):
    """Proxy of C++ plCndPoisson class"""
    __swig_setmethods__ = {}
    for _s in [plCndDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndPoisson, name, value)
    __swig_getmethods__ = {}
    for _s in [plCndDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndPoisson, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plCndPoisson
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plCndPoisson self) -> plCndPoisson
        __init__(plCndPoisson self, plSymbol left, plSymbol mu) -> plCndPoisson
        __init__(plCndPoisson self, plSymbol left, plVariablesConjunction right, plExternalFunction fmu) -> plCndPoisson
        __init__(plCndPoisson self, plCndDistribution arg2) -> plCndPoisson
        """
        this = _pypl.new_plCndPoisson(*args)
        try: self.this.append(this)
        except: self.this = this
    def mu_is_variable(self):
        """mu_is_variable(plCndPoisson self) -> bool"""
        return _pypl.plCndPoisson_mu_is_variable(self)

    def get_mu_variable(self):
        """get_mu_variable(plCndPoisson self) -> plVariablesConjunction"""
        return _pypl.plCndPoisson_get_mu_variable(self)

    def mu_is_function(self):
        """mu_is_function(plCndPoisson self) -> bool"""
        return _pypl.plCndPoisson_mu_is_function(self)

    def get_mu_function(self):
        """get_mu_function(plCndPoisson self) -> plExternalFunction"""
        return _pypl.plCndPoisson_get_mu_function(self)

    def is_base_class(self):
        """is_base_class(plCndPoisson self) -> bool"""
        return _pypl.plCndPoisson_is_base_class(self)

plCndPoisson_swigregister = _pypl.plCndPoisson_swigregister
plCndPoisson_swigregister(plCndPoisson)

class plCndUniform(plCndDistribution):
    """Proxy of C++ plCndUniform class"""
    __swig_setmethods__ = {}
    for _s in [plCndDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndUniform, name, value)
    __swig_getmethods__ = {}
    for _s in [plCndDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndUniform, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plCndUniform
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plCndUniform self) -> plCndUniform
        __init__(plCndUniform self, plSymbol variable, plSymbol min, plFloat max) -> plCndUniform
        __init__(plCndUniform self, plSymbol variable, plFloat min, plSymbol max) -> plCndUniform
        __init__(plCndUniform self, plSymbol variable, plVariablesConjunction right, plExternalFunction fmin, plFloat max) -> plCndUniform
        __init__(plCndUniform self, plSymbol variable, plVariablesConjunction right, plFloat min, plExternalFunction fmax) -> plCndUniform
        __init__(plCndUniform self, plSymbol variable, plSymbol min, plSymbol max) -> plCndUniform
        __init__(plCndUniform self, plSymbol variable, plVariablesConjunction right, plExternalFunction fmin, plExternalFunction fmax) -> plCndUniform
        __init__(plCndUniform self, plSymbol variable, plVariablesConjunction right, plExternalFunction f_min_max) -> plCndUniform
        __init__(plCndUniform self, plCndDistribution arg2) -> plCndUniform
        """
        this = _pypl.new_plCndUniform(*args)
        try: self.this.append(this)
        except: self.this = this
    def min_is_constant(self):
        """min_is_constant(plCndUniform self) -> bool"""
        return _pypl.plCndUniform_min_is_constant(self)

    def get_min_constant(self):
        """get_min_constant(plCndUniform self) -> plFloat"""
        return _pypl.plCndUniform_get_min_constant(self)

    def min_is_variable(self):
        """min_is_variable(plCndUniform self) -> bool"""
        return _pypl.plCndUniform_min_is_variable(self)

    def get_min_variable(self):
        """get_min_variable(plCndUniform self) -> plSymbol"""
        return _pypl.plCndUniform_get_min_variable(self)

    def min_is_function(self):
        """min_is_function(plCndUniform self) -> bool"""
        return _pypl.plCndUniform_min_is_function(self)

    def get_min_function(self):
        """get_min_function(plCndUniform self) -> plExternalFunction"""
        return _pypl.plCndUniform_get_min_function(self)

    def max_is_constant(self):
        """max_is_constant(plCndUniform self) -> bool"""
        return _pypl.plCndUniform_max_is_constant(self)

    def get_max_constant(self):
        """get_max_constant(plCndUniform self) -> plFloat"""
        return _pypl.plCndUniform_get_max_constant(self)

    def max_is_variable(self):
        """max_is_variable(plCndUniform self) -> bool"""
        return _pypl.plCndUniform_max_is_variable(self)

    def get_max_variable(self):
        """get_max_variable(plCndUniform self) -> plSymbol"""
        return _pypl.plCndUniform_get_max_variable(self)

    def max_is_function(self):
        """max_is_function(plCndUniform self) -> bool"""
        return _pypl.plCndUniform_max_is_function(self)

    def get_max_function(self):
        """get_max_function(plCndUniform self) -> plExternalFunction"""
        return _pypl.plCndUniform_get_max_function(self)

    def min_and_max_are_one_function(self):
        """min_and_max_are_one_function(plCndUniform self) -> bool"""
        return _pypl.plCndUniform_min_and_max_are_one_function(self)

    def get_min_max_function(self):
        """get_min_max_function(plCndUniform self) -> plExternalFunction"""
        return _pypl.plCndUniform_get_min_max_function(self)

    def is_base_class(self):
        """is_base_class(plCndUniform self) -> bool"""
        return _pypl.plCndUniform_is_base_class(self)

plCndUniform_swigregister = _pypl.plCndUniform_swigregister
plCndUniform_swigregister(plCndUniform)

class plCndUnknown(plCndDistribution):
    """Proxy of C++ plCndUnknown class"""
    __swig_setmethods__ = {}
    for _s in [plCndDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndUnknown, name, value)
    __swig_getmethods__ = {}
    for _s in [plCndDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndUnknown, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plCndUnknown
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plCndUnknown self) -> plCndUnknown
        __init__(plCndUnknown self, plVariablesConjunction left, plVariablesConjunction right) -> plCndUnknown
        __init__(plCndUnknown self, plCndDistribution arg2) -> plCndUnknown
        """
        this = _pypl.new_plCndUnknown(*args)
        try: self.this.append(this)
        except: self.this = this
plCndUnknown_swigregister = _pypl.plCndUnknown_swigregister
plCndUnknown_swigregister(plCndUnknown)

class plCndDeterministic(plCndDistribution):
    """Proxy of C++ plCndDeterministic class"""
    __swig_setmethods__ = {}
    for _s in [plCndDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndDeterministic, name, value)
    __swig_getmethods__ = {}
    for _s in [plCndDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndDeterministic, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plCndDeterministic
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plCndDeterministic self, plVariablesConjunction left_variables, plVariablesConjunction right_variables, plExternalFunction func) -> plCndDeterministic
        __init__(plCndDeterministic self, plExternalFunction func) -> plCndDeterministic
        __init__(plCndDeterministic self) -> plCndDeterministic
        __init__(plCndDeterministic self, plCndDistribution arg2) -> plCndDeterministic
        """
        this = _pypl.new_plCndDeterministic(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_function(self):
        """get_function(plCndDeterministic self) -> plExternalFunction"""
        return _pypl.plCndDeterministic_get_function(self)

    def is_base_class(self):
        """is_base_class(plCndDeterministic self) -> bool"""
        return _pypl.plCndDeterministic_is_base_class(self)

plCndDeterministic_swigregister = _pypl.plCndDeterministic_swigregister
plCndDeterministic_swigregister(plCndDeterministic)

class plIneqConstraint(plCndDistribution):
    """Proxy of C++ plIneqConstraint class"""
    __swig_setmethods__ = {}
    for _s in [plCndDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plIneqConstraint, name, value)
    __swig_getmethods__ = {}
    for _s in [plCndDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plIneqConstraint, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plIneqConstraint
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plIneqConstraint self) -> plIneqConstraint
        __init__(plIneqConstraint self, plSymbol constraint_variable, plExternalFunction constraint_function, unsigned int constraint_size) -> plIneqConstraint
        __init__(plIneqConstraint self, plCndDistribution arg2) -> plIneqConstraint
        """
        this = _pypl.new_plIneqConstraint(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_function(self):
        """get_function(plIneqConstraint self) -> plExternalFunction"""
        return _pypl.plIneqConstraint_get_function(self)

    def get_constraint_size(self):
        """get_constraint_size(plIneqConstraint self) -> unsigned int"""
        return _pypl.plIneqConstraint_get_constraint_size(self)

    def is_base_class(self):
        """is_base_class(plIneqConstraint self) -> bool"""
        return _pypl.plIneqConstraint_is_base_class(self)

plIneqConstraint_swigregister = _pypl.plIneqConstraint_swigregister
plIneqConstraint_swigregister(plIneqConstraint)

class plLinearRegression(plCndDistribution):
    """Proxy of C++ plLinearRegression class"""
    __swig_setmethods__ = {}
    for _s in [plCndDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLinearRegression, name, value)
    __swig_getmethods__ = {}
    for _s in [plCndDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLinearRegression, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plLinearRegression
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plLinearRegression self) -> plLinearRegression
        __init__(plLinearRegression self, plSymbol left_var, plVariablesConjunction right_variables, DoubleVector beta, plFloat regression_std_deviation) -> plLinearRegression
        __init__(plLinearRegression self, plCndDistribution arg2) -> plLinearRegression
        """
        this = _pypl.new_plLinearRegression(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_beta(self):
        """get_beta(plLinearRegression self) -> DoubleVector"""
        return _pypl.plLinearRegression_get_beta(self)

    def get_regression_std_deviation(self):
        """get_regression_std_deviation(plLinearRegression self) -> plFloat"""
        return _pypl.plLinearRegression_get_regression_std_deviation(self)

    def is_base_class(self):
        """is_base_class(plLinearRegression self) -> bool"""
        return _pypl.plLinearRegression_is_base_class(self)

plLinearRegression_swigregister = _pypl.plLinearRegression_swigregister
plLinearRegression_swigregister(plLinearRegression)

class plNoisyOR(plCndDistribution):
    """Proxy of C++ plNoisyOR class"""
    __swig_setmethods__ = {}
    for _s in [plCndDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plNoisyOR, name, value)
    __swig_getmethods__ = {}
    for _s in [plCndDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plNoisyOR, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plNoisyOR
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plNoisyOR self) -> plNoisyOR
        __init__(plNoisyOR self, plSymbol left_binary_var, plVariablesConjunction right_variables, DoubleVectorVector table_B_0_probabilities) -> plNoisyOR
        __init__(plNoisyOR self, plCndDistribution arg2) -> plNoisyOR
        """
        this = _pypl.new_plNoisyOR(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_parameters(self):
        """get_parameters(plNoisyOR self) -> DoubleVectorVector"""
        return _pypl.plNoisyOR_get_parameters(self)

    def is_base_class(self):
        """is_base_class(plNoisyOR self) -> bool"""
        return _pypl.plNoisyOR_is_base_class(self)

plNoisyOR_swigregister = _pypl.plNoisyOR_swigregister
plNoisyOR_swigregister(plNoisyOR)

class plSoftmax(plCndDistribution):
    """Proxy of C++ plSoftmax class"""
    __swig_setmethods__ = {}
    for _s in [plCndDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plSoftmax, name, value)
    __swig_getmethods__ = {}
    for _s in [plCndDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plSoftmax, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plSoftmax
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plSoftmax self) -> plSoftmax
        __init__(plSoftmax self, plSymbol left_var, plVariablesConjunction right_variables, DoubleVectorVector beta) -> plSoftmax
        __init__(plSoftmax self, plCndDistribution arg2) -> plSoftmax
        """
        this = _pypl.new_plSoftmax(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_beta(self):
        """get_beta(plSoftmax self) -> DoubleVectorVector"""
        return _pypl.plSoftmax_get_beta(self)

    def is_base_class(self):
        """is_base_class(plSoftmax self) -> bool"""
        return _pypl.plSoftmax_is_base_class(self)

plSoftmax_swigregister = _pypl.plSoftmax_swigregister
plSoftmax_swigregister(plSoftmax)

class plDistributionTable(plCndDistribution):
    """Proxy of C++ plDistributionTable class"""
    __swig_setmethods__ = {}
    for _s in [plCndDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plDistributionTable, name, value)
    __swig_getmethods__ = {}
    for _s in [plCndDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plDistributionTable, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plDistributionTable
    __del__ = lambda self : None;
    def push(self, *args):
        """
        push(plDistributionTable self, plComputableObject compObj, plValues values)
        push(plDistributionTable self, plValues values, plComputableObject compObj)
        push(plDistributionTable self, plComputableObject compObj, int value)
        push(plDistributionTable self, int value, plComputableObject compObj)
        push(plDistributionTable self, plComputableObject compObj, plFloat value)
        push(plDistributionTable self, plFloat value, plComputableObject compObj)
        push(plDistributionTable self, plValues values, DoubleVector probVector)
        push(plDistributionTable self, DoubleVector probVector, plValues values)
        """
        return _pypl.plDistributionTable_push(self, *args)

    def push_default(self, *args):
        """push_default(plDistributionTable self, plComputableObject compObj)"""
        return _pypl.plDistributionTable_push_default(self, *args)

    def has_default(self):
        """has_default(plDistributionTable self) -> bool"""
        return _pypl.plDistributionTable_has_default(self)

    def get_default(self):
        """get_default(plDistributionTable self) -> plComputableObject"""
        return _pypl.plDistributionTable_get_default(self)

    def find(self, *args):
        """find(plDistributionTable self, plValues values) -> bool"""
        return _pypl.plDistributionTable_find(self, *args)

    def __init__(self, *args): 
        """
        __init__(plDistributionTable self) -> plDistributionTable
        __init__(plDistributionTable self, plVariablesConjunction left, plVariablesConjunction right, bool force_use_map=False) -> plDistributionTable
        __init__(plDistributionTable self, plVariablesConjunction left, plVariablesConjunction right) -> plDistributionTable
        __init__(plDistributionTable self, plVariablesConjunction left, plVariablesConjunction right, plVariablesConjunction right_index, 
            bool force_use_map=False) -> plDistributionTable
        __init__(plDistributionTable self, plVariablesConjunction left, plVariablesConjunction right, plVariablesConjunction right_index) -> plDistributionTable
        __init__(plDistributionTable self, plVariablesConjunction left, plVariablesConjunction right, plProbValue const * table, 
            bool already_normalized=False) -> plDistributionTable
        __init__(plDistributionTable self, plVariablesConjunction left, plVariablesConjunction right, plProbValue const * table) -> plDistributionTable
        __init__(plDistributionTable self, plVariablesConjunction left, plVariablesConjunction right, plProbValue (*)(plValues const &,plValues const &) f, 
            bool already_normalized=False) -> plDistributionTable
        __init__(plDistributionTable self, plVariablesConjunction left, plVariablesConjunction right, plProbValue (*)(plValues const &,plValues const &) f) -> plDistributionTable
        __init__(plDistributionTable self, plCndDistribution arg2) -> plDistributionTable
        """
        this = _pypl.new_plDistributionTable(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_pushed_distribution(self, *args):
        """get_pushed_distribution(plDistributionTable self, plValues values) -> plComputableObject"""
        return _pypl.plDistributionTable_get_pushed_distribution(self, *args)

    def get_index_variables(self):
        """get_index_variables(plDistributionTable self) -> plVariablesConjunction"""
        return _pypl.plDistributionTable_get_index_variables(self)

    def is_base_class(self):
        """is_base_class(plDistributionTable self) -> bool"""
        return _pypl.plDistributionTable_is_base_class(self)

    def get_pushed_values(self):
        """get_pushed_values(plDistributionTable self) -> plValuesVector"""
        return _pypl.plDistributionTable_get_pushed_values(self)

plDistributionTable_swigregister = _pypl.plDistributionTable_swigregister
plDistributionTable_swigregister(plDistributionTable)

class plDataValues(_object):
    """Proxy of C++ plDataValues class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plDataValues, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plDataValues, name)
    __repr__ = _swig_repr
    def size(self):
        """size(plDataValues self) -> size_t"""
        return _pypl.plDataValues_size(self)

    def __getitem__(self, *args):
        """__getitem__(plDataValues self, int index) -> plData"""
        return _pypl.plDataValues___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(plDataValues self, int index, plData value)
        __setitem__(plDataValues self, int index, int value)
        __setitem__(plDataValues self, int index, float value)
        """
        return _pypl.plDataValues___setitem__(self, *args)

    def __len__(self):
        """__len__(plDataValues self) -> int"""
        return _pypl.plDataValues___len__(self)

    def __init__(self): 
        """__init__(plDataValues self) -> plDataValues"""
        this = _pypl.new_plDataValues()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plDataValues
    __del__ = lambda self : None;
plDataValues_swigregister = _pypl.plDataValues_swigregister
plDataValues_swigregister(plDataValues)

class plExternalFunction(plUserFunction):
    """Proxy of C++ plExternalFunction class"""
    __swig_setmethods__ = {}
    for _s in [plUserFunction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plExternalFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [plUserFunction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plExternalFunction, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plExternalFunction
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plExternalFunction self) -> plExternalFunction
        __init__(plExternalFunction self, plExternalFunction f) -> plExternalFunction
        __init__(plExternalFunction self, plVariablesConjunction input_params, plExternalFunction::callback_t call_function, 
            std::string func_name="") -> plExternalFunction
        __init__(plExternalFunction self, plVariablesConjunction input_params, plExternalFunction::callback_t call_function) -> plExternalFunction
        __init__(plExternalFunction self, plVariablesConjunction output_params, plVariablesConjunction input_params, plExternalFunction::callback_t call_function, 
            std::string func_name="") -> plExternalFunction
        __init__(plExternalFunction self, plVariablesConjunction output_params, plVariablesConjunction input_params, plExternalFunction::callback_t call_function) -> plExternalFunction
        """
        this = _pypl.new_plExternalFunction(*args)
        try: self.this.append(this)
        except: self.this = this
    def assign_from(self, *args):
        """assign_from(plExternalFunction self, plExternalFunction other) -> plExternalFunction"""
        return _pypl.plExternalFunction_assign_from(self, *args)

    def __call__(self, *args):
        """__call__(plExternalFunction self, plValues values) -> plDataValues"""
        return _pypl.plExternalFunction___call__(self, *args)

    def get_variables(self):
        """get_variables(plExternalFunction self) -> plVariablesConjunction"""
        return _pypl.plExternalFunction_get_variables(self)

    def get_left_variables(self):
        """get_left_variables(plExternalFunction self) -> plVariablesConjunction"""
        return _pypl.plExternalFunction_get_left_variables(self)

    def get_right_variables(self):
        """get_right_variables(plExternalFunction self) -> plVariablesConjunction"""
        return _pypl.plExternalFunction_get_right_variables(self)

    def set_has_side_effect(self, *args):
        """set_has_side_effect(plExternalFunction self, bool hse)"""
        return _pypl.plExternalFunction_set_has_side_effect(self, *args)

    def has_side_effect(self):
        """has_side_effect(plExternalFunction self) -> bool"""
        return _pypl.plExternalFunction_has_side_effect(self)

    def get_name(self):
        """get_name(plExternalFunction self) -> std::string const &"""
        return _pypl.plExternalFunction_get_name(self)

    def sum(*args):
        """sum(plValues the_sum, plValues vals)"""
        return _pypl.plExternalFunction_sum(*args)

    if _newclass:sum = staticmethod(sum)
    __swig_getmethods__["sum"] = lambda x: sum
    def product(*args):
        """product(plValues the_product, plValues vals)"""
        return _pypl.plExternalFunction_product(*args)

    if _newclass:product = staticmethod(product)
    __swig_getmethods__["product"] = lambda x: product
    def average(*args):
        """average(plValues the_average, plValues vals)"""
        return _pypl.plExternalFunction_average(*args)

    if _newclass:average = staticmethod(average)
    __swig_getmethods__["average"] = lambda x: average
    def identity(*args):
        """identity(plValues the_id, plValues vals)"""
        return _pypl.plExternalFunction_identity(*args)

    if _newclass:identity = staticmethod(identity)
    __swig_getmethods__["identity"] = lambda x: identity
    def min(*args):
        """min(plValues the_min, plValues vals)"""
        return _pypl.plExternalFunction_min(*args)

    if _newclass:min = staticmethod(min)
    __swig_getmethods__["min"] = lambda x: min
    def max(*args):
        """max(plValues the_max, plValues vals)"""
        return _pypl.plExternalFunction_max(*args)

    if _newclass:max = staticmethod(max)
    __swig_getmethods__["max"] = lambda x: max
    def OR(*args):
        """OR(plValues or_result, plValues vals)"""
        return _pypl.plExternalFunction_OR(*args)

    if _newclass:OR = staticmethod(OR)
    __swig_getmethods__["OR"] = lambda x: OR
    def AND(*args):
        """AND(plValues and_result, plValues vals)"""
        return _pypl.plExternalFunction_AND(*args)

    if _newclass:AND = staticmethod(AND)
    __swig_getmethods__["AND"] = lambda x: AND
plExternalFunction_swigregister = _pypl.plExternalFunction_swigregister
plExternalFunction_swigregister(plExternalFunction)

def plExternalFunction_sum(*args):
  """plExternalFunction_sum(plValues the_sum, plValues vals)"""
  return _pypl.plExternalFunction_sum(*args)

def plExternalFunction_product(*args):
  """plExternalFunction_product(plValues the_product, plValues vals)"""
  return _pypl.plExternalFunction_product(*args)

def plExternalFunction_average(*args):
  """plExternalFunction_average(plValues the_average, plValues vals)"""
  return _pypl.plExternalFunction_average(*args)

def plExternalFunction_identity(*args):
  """plExternalFunction_identity(plValues the_id, plValues vals)"""
  return _pypl.plExternalFunction_identity(*args)

def plExternalFunction_min(*args):
  """plExternalFunction_min(plValues the_min, plValues vals)"""
  return _pypl.plExternalFunction_min(*args)

def plExternalFunction_max(*args):
  """plExternalFunction_max(plValues the_max, plValues vals)"""
  return _pypl.plExternalFunction_max(*args)

def plExternalFunction_OR(*args):
  """plExternalFunction_OR(plValues or_result, plValues vals)"""
  return _pypl.plExternalFunction_OR(*args)

def plExternalFunction_AND(*args):
  """plExternalFunction_AND(plValues and_result, plValues vals)"""
  return _pypl.plExternalFunction_AND(*args)

class plExternalObjectInterface(_object):
    """Proxy of C++ plExternalObjectInterface class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plExternalObjectInterface, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plExternalObjectInterface, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plExternalObjectInterface
    __del__ = lambda self : None;
    def f(self, *args):
        """f(plExternalObjectInterface self, plValues output, plValues input)"""
        return _pypl.plExternalObjectInterface_f(self, *args)

plExternalObjectInterface_swigregister = _pypl.plExternalObjectInterface_swigregister
plExternalObjectInterface_swigregister(plExternalObjectInterface)


def plCreateExternalFunction(*args):
  """
    plCreateExternalFunction(plVariablesConjunction input_variables, plExternalObjectInterface object, std::string const & func_name="") -> plExternalFunction
    plCreateExternalFunction(plVariablesConjunction input_variables, plExternalObjectInterface object) -> plExternalFunction
    """
  return _pypl.plCreateExternalFunction(*args)
class plExternalFunctionFromSource(plExternalFunction):
    """Proxy of C++ plExternalFunctionFromSource class"""
    __swig_setmethods__ = {}
    for _s in [plExternalFunction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plExternalFunctionFromSource, name, value)
    __swig_getmethods__ = {}
    for _s in [plExternalFunction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plExternalFunctionFromSource, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plExternalFunctionFromSource self) -> plExternalFunctionFromSource
        __init__(plExternalFunctionFromSource self, plExternalFunction other) -> plExternalFunctionFromSource
        """
        this = _pypl.new_plExternalFunctionFromSource(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_code(self):
        """get_code(plExternalFunctionFromSource self) -> std::string const &"""
        return _pypl.plExternalFunctionFromSource_get_code(self)

    __swig_destroy__ = _pypl.delete_plExternalFunctionFromSource
    __del__ = lambda self : None;
plExternalFunctionFromSource_swigregister = _pypl.plExternalFunctionFromSource_swigregister
plExternalFunctionFromSource_swigregister(plExternalFunctionFromSource)

class plExternalFunctionFromC(plExternalFunctionFromSource):
    """Proxy of C++ plExternalFunctionFromC class"""
    __swig_setmethods__ = {}
    for _s in [plExternalFunctionFromSource]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plExternalFunctionFromC, name, value)
    __swig_getmethods__ = {}
    for _s in [plExternalFunctionFromSource]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plExternalFunctionFromC, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plExternalFunctionFromC self) -> plExternalFunctionFromC
        __init__(plExternalFunctionFromC self, plExternalFunction other) -> plExternalFunctionFromC
        __init__(plExternalFunctionFromC self, plVariablesConjunction input_params, std::string func_code, std::string func_name) -> plExternalFunctionFromC
        __init__(plExternalFunctionFromC self, plVariablesConjunction output_params, plVariablesConjunction input_params, std::string func_code, 
            std::string func_name) -> plExternalFunctionFromC
        """
        this = _pypl.new_plExternalFunctionFromC(*args)
        try: self.this.append(this)
        except: self.this = this
    def add_symbol(self, *args):
        """add_symbol(plExternalFunctionFromC self, std::string name, void * addr)"""
        return _pypl.plExternalFunctionFromC_add_symbol(self, *args)

    __swig_destroy__ = _pypl.delete_plExternalFunctionFromC
    __del__ = lambda self : None;
plExternalFunctionFromC_swigregister = _pypl.plExternalFunctionFromC_swigregister
plExternalFunctionFromC_swigregister(plExternalFunctionFromC)


def createExternalFunctionFromC(*args):
  """
    createExternalFunctionFromC(plVariablesConjunction output, plVariablesConjunction input, std::string code, std::string name) -> plExternalFunctionFromC
    createExternalFunctionFromC(plVariablesConjunction input, std::string code, std::string name) -> plExternalFunctionFromC
    """
  return _pypl.createExternalFunctionFromC(*args)

def createExternalFunctionFromCExpression(*args):
  """createExternalFunctionFromCExpression(plVariablesConjunction input, std::string code, std::string name) -> plExternalFunctionFromC"""
  return _pypl.createExternalFunctionFromCExpression(*args)
class plPythonExternalFunction(plExternalFunction):
    """Proxy of C++ plPythonExternalFunction class"""
    __swig_setmethods__ = {}
    for _s in [plExternalFunction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plPythonExternalFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [plExternalFunction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plPythonExternalFunction, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plPythonExternalFunction self, plVariablesConjunction known_params, PyObject * python_function, std::string function_name="") -> plPythonExternalFunction
        __init__(plPythonExternalFunction self, plVariablesConjunction known_params, PyObject * python_function) -> plPythonExternalFunction
        __init__(plPythonExternalFunction self, plVariablesConjunction search_params, plVariablesConjunction known_params, PyObject * python_function, 
            std::string function_name="") -> plPythonExternalFunction
        __init__(plPythonExternalFunction self, plVariablesConjunction search_params, plVariablesConjunction known_params, PyObject * python_function) -> plPythonExternalFunction
        __init__(plPythonExternalFunction self, plVariablesConjunction known_params, PyObject * python_instance, PyObject * python_method, 
            std::string function_name="") -> plPythonExternalFunction
        __init__(plPythonExternalFunction self, plVariablesConjunction known_params, PyObject * python_instance, PyObject * python_method) -> plPythonExternalFunction
        __init__(plPythonExternalFunction self, plVariablesConjunction search_params, plVariablesConjunction known_params, PyObject * python_instance, 
            PyObject * python_method, std::string function_name="") -> plPythonExternalFunction
        __init__(plPythonExternalFunction self, plVariablesConjunction search_params, plVariablesConjunction known_params, PyObject * python_instance, 
            PyObject * python_method) -> plPythonExternalFunction
        """
        this = _pypl.new_plPythonExternalFunction(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plPythonExternalFunction
    __del__ = lambda self : None;
plPythonExternalFunction_swigregister = _pypl.plPythonExternalFunction_swigregister
plPythonExternalFunction_swigregister(plPythonExternalFunction)

class plExternalProbFunction(plUserFunction):
    """Proxy of C++ plExternalProbFunction class"""
    __swig_setmethods__ = {}
    for _s in [plUserFunction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plExternalProbFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [plUserFunction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plExternalProbFunction, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plExternalProbFunction
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plExternalProbFunction self) -> plExternalProbFunction
        __init__(plExternalProbFunction self, plExternalProbFunction f) -> plExternalProbFunction
        __init__(plExternalProbFunction self, plVariablesConjunction variables, plExternalProbFunction::callback_t function, std::string func_name="") -> plExternalProbFunction
        __init__(plExternalProbFunction self, plVariablesConjunction variables, plExternalProbFunction::callback_t function) -> plExternalProbFunction
        """
        this = _pypl.new_plExternalProbFunction(*args)
        try: self.this.append(this)
        except: self.this = this
    def assign_from(self, *args):
        """assign_from(plExternalProbFunction self, plExternalProbFunction other) -> plExternalProbFunction"""
        return _pypl.plExternalProbFunction_assign_from(self, *args)

    def __call__(self, *args):
        """__call__(plExternalProbFunction self, plValues values) -> plProbValue"""
        return _pypl.plExternalProbFunction___call__(self, *args)

    def get_variables(self):
        """get_variables(plExternalProbFunction self) -> plVariablesConjunction"""
        return _pypl.plExternalProbFunction_get_variables(self)

    def set_has_side_effect(self, *args):
        """set_has_side_effect(plExternalProbFunction self, bool hse)"""
        return _pypl.plExternalProbFunction_set_has_side_effect(self, *args)

    def has_side_effect(self):
        """has_side_effect(plExternalProbFunction self) -> bool"""
        return _pypl.plExternalProbFunction_has_side_effect(self)

    def get_name(self):
        """get_name(plExternalProbFunction self) -> std::string const &"""
        return _pypl.plExternalProbFunction_get_name(self)

plExternalProbFunction_swigregister = _pypl.plExternalProbFunction_swigregister
plExternalProbFunction_swigregister(plExternalProbFunction)

class plExternalProbObjectInterface(_object):
    """Proxy of C++ plExternalProbObjectInterface class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plExternalProbObjectInterface, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plExternalProbObjectInterface, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plExternalProbObjectInterface
    __del__ = lambda self : None;
    def f(self, *args):
        """f(plExternalProbObjectInterface self, plValues input_values) -> plProbValue"""
        return _pypl.plExternalProbObjectInterface_f(self, *args)

plExternalProbObjectInterface_swigregister = _pypl.plExternalProbObjectInterface_swigregister
plExternalProbObjectInterface_swigregister(plExternalProbObjectInterface)


def plCreateExternalProbFunction(*args):
  """
    plCreateExternalProbFunction(plVariablesConjunction input_variables, plExternalProbObjectInterface object, std::string const & func_name="") -> plExternalProbFunction
    plCreateExternalProbFunction(plVariablesConjunction input_variables, plExternalProbObjectInterface object) -> plExternalProbFunction
    """
  return _pypl.plCreateExternalProbFunction(*args)
class plExternalProbFunctionFromSource(plExternalProbFunction):
    """Proxy of C++ plExternalProbFunctionFromSource class"""
    __swig_setmethods__ = {}
    for _s in [plExternalProbFunction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plExternalProbFunctionFromSource, name, value)
    __swig_getmethods__ = {}
    for _s in [plExternalProbFunction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plExternalProbFunctionFromSource, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plExternalProbFunctionFromSource self) -> plExternalProbFunctionFromSource
        __init__(plExternalProbFunctionFromSource self, plExternalProbFunction other) -> plExternalProbFunctionFromSource
        """
        this = _pypl.new_plExternalProbFunctionFromSource(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_code(self):
        """get_code(plExternalProbFunctionFromSource self) -> std::string const &"""
        return _pypl.plExternalProbFunctionFromSource_get_code(self)

    __swig_destroy__ = _pypl.delete_plExternalProbFunctionFromSource
    __del__ = lambda self : None;
plExternalProbFunctionFromSource_swigregister = _pypl.plExternalProbFunctionFromSource_swigregister
plExternalProbFunctionFromSource_swigregister(plExternalProbFunctionFromSource)

class plExternalProbFunctionFromC(plExternalProbFunctionFromSource):
    """Proxy of C++ plExternalProbFunctionFromC class"""
    __swig_setmethods__ = {}
    for _s in [plExternalProbFunctionFromSource]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plExternalProbFunctionFromC, name, value)
    __swig_getmethods__ = {}
    for _s in [plExternalProbFunctionFromSource]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plExternalProbFunctionFromC, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plExternalProbFunctionFromC self) -> plExternalProbFunctionFromC
        __init__(plExternalProbFunctionFromC self, plExternalProbFunction other) -> plExternalProbFunctionFromC
        __init__(plExternalProbFunctionFromC self, plVariablesConjunction variables, std::string func_code, std::string func_name) -> plExternalProbFunctionFromC
        """
        this = _pypl.new_plExternalProbFunctionFromC(*args)
        try: self.this.append(this)
        except: self.this = this
    def add_symbol(self, *args):
        """add_symbol(plExternalProbFunctionFromC self, std::string name, void * addr)"""
        return _pypl.plExternalProbFunctionFromC_add_symbol(self, *args)

    __swig_destroy__ = _pypl.delete_plExternalProbFunctionFromC
    __del__ = lambda self : None;
plExternalProbFunctionFromC_swigregister = _pypl.plExternalProbFunctionFromC_swigregister
plExternalProbFunctionFromC_swigregister(plExternalProbFunctionFromC)


def createExternalProbFunctionFromC(*args):
  """createExternalProbFunctionFromC(plVariablesConjunction input, std::string code, std::string name) -> plExternalProbFunctionFromC"""
  return _pypl.createExternalProbFunctionFromC(*args)
class plPythonExternalProbFunction(plExternalProbFunction):
    """Proxy of C++ plPythonExternalProbFunction class"""
    __swig_setmethods__ = {}
    for _s in [plExternalProbFunction]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plPythonExternalProbFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [plExternalProbFunction]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plPythonExternalProbFunction, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plPythonExternalProbFunction self, plVariablesConjunction variables, PyObject * python_function, std::string function_name="") -> plPythonExternalProbFunction
        __init__(plPythonExternalProbFunction self, plVariablesConjunction variables, PyObject * python_function) -> plPythonExternalProbFunction
        __init__(plPythonExternalProbFunction self, plVariablesConjunction variables, PyObject * python_instance, PyObject * python_method, 
            std::string function_name="") -> plPythonExternalProbFunction
        __init__(plPythonExternalProbFunction self, plVariablesConjunction variables, PyObject * python_instance, PyObject * python_method) -> plPythonExternalProbFunction
        """
        this = _pypl.new_plPythonExternalProbFunction(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plPythonExternalProbFunction
    __del__ = lambda self : None;
plPythonExternalProbFunction_swigregister = _pypl.plPythonExternalProbFunction_swigregister
plPythonExternalProbFunction_swigregister(plPythonExternalProbFunction)

class plJointDistribution(plDistribution):
    """Proxy of C++ plJointDistribution class"""
    __swig_setmethods__ = {}
    for _s in [plDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plJointDistribution, name, value)
    __swig_getmethods__ = {}
    for _s in [plDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plJointDistribution, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plJointDistribution self) -> plJointDistribution
        __init__(plJointDistribution self, plVariablesConjunction all_params, plDistribution f) -> plJointDistribution
        __init__(plJointDistribution self, plDistribution f) -> plJointDistribution
        __init__(plJointDistribution self, plVariablesConjunction all_params, plComputableObjectList decomposition) -> plJointDistribution
        __init__(plJointDistribution self, plComputableObjectList decomposition) -> plJointDistribution
        __init__(plJointDistribution self, plJointDistribution other) -> plJointDistribution
        """
        this = _pypl.new_plJointDistribution(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plJointDistribution
    __del__ = lambda self : None;
    def draw_graph(self, *args):
        """
        draw_graph(plJointDistribution self, plDrawingLanguage drawing_language=PL_XFIG_GRAPH)
        draw_graph(plJointDistribution self, std::string const & file_name, plDrawingLanguage drawing_language=PL_XFIG_GRAPH)
        draw_graph(plJointDistribution self, std::string const & file_name)
        draw_graph(plJointDistribution self, char const * file_name, plDrawingLanguage drawing_language=PL_XFIG_GRAPH)
        draw_graph(plJointDistribution self, char const * file_name)
        draw_graph(plJointDistribution self, plGraph & graph)
        """
        return _pypl.plJointDistribution_draw_graph(self, *args)

    def draw_graph_dot(self, *args):
        """
        draw_graph_dot(plJointDistribution self, std::string const & dot_node_shape="", std::string const & dot_node_color="", std::string const & dot_node_fill_color="", 
            std::string const & dot_background_color="", 
            std::string const & dot_rankdir="")
        draw_graph_dot(plJointDistribution self, std::string const & dot_node_shape="", std::string const & dot_node_color="", std::string const & dot_node_fill_color="", 
            std::string const & dot_background_color="")
        draw_graph_dot(plJointDistribution self, std::string const & dot_node_shape="", std::string const & dot_node_color="", std::string const & dot_node_fill_color="")
        draw_graph_dot(plJointDistribution self, std::string const & dot_node_shape="", std::string const & dot_node_color="")
        draw_graph_dot(plJointDistribution self, std::string const & dot_node_shape="")
        draw_graph_dot(plJointDistribution self)
        draw_graph_dot(plJointDistribution self, std::string const & file_name, std::string const & dot_node_shape="", std::string const & dot_node_color="", 
            std::string const & dot_node_fill_color="", std::string const & dot_background_color="", 
            std::string const & dot_rankdir="")
        draw_graph_dot(plJointDistribution self, std::string const & file_name, std::string const & dot_node_shape="", std::string const & dot_node_color="", 
            std::string const & dot_node_fill_color="", std::string const & dot_background_color="")
        draw_graph_dot(plJointDistribution self, std::string const & file_name, std::string const & dot_node_shape="", std::string const & dot_node_color="", 
            std::string const & dot_node_fill_color="")
        draw_graph_dot(plJointDistribution self, std::string const & file_name, std::string const & dot_node_shape="", std::string const & dot_node_color="")
        draw_graph_dot(plJointDistribution self, std::string const & file_name, std::string const & dot_node_shape="")
        draw_graph_dot(plJointDistribution self, std::string const & file_name)
        """
        return _pypl.plJointDistribution_draw_graph_dot(self, *args)

    def ask(self, *args):
        """
        ask(plJointDistribution self, plCndDistribution CndExpr, plVariablesConjunction searched_variables, plVariablesConjunction known_variables, 
            plOptimizationCriterion optimization=PL_NO_OPTIMIZATION, 
            bool do_not_build_normalization_expression=False)
        ask(plJointDistribution self, plCndDistribution CndExpr, plVariablesConjunction searched_variables, plVariablesConjunction known_variables, 
            plOptimizationCriterion optimization=PL_NO_OPTIMIZATION)
        ask(plJointDistribution self, plCndDistribution CndExpr, plVariablesConjunction searched_variables, plVariablesConjunction known_variables)
        ask(plJointDistribution self, plVariablesConjunction searched_variables, plVariablesConjunction known_variables, 
            plOptimizationCriterion optimization=PL_NO_OPTIMIZATION, bool do_not_build_normalization_expression=False) -> plCndDistribution
        ask(plJointDistribution self, plVariablesConjunction searched_variables, plVariablesConjunction known_variables, 
            plOptimizationCriterion optimization=PL_NO_OPTIMIZATION) -> plCndDistribution
        ask(plJointDistribution self, plVariablesConjunction searched_variables, plVariablesConjunction known_variables) -> plCndDistribution
        ask(plJointDistribution self, plDistribution Expr, plVariablesConjunction searched_variables, plOptimizationCriterion optimization=PL_NO_OPTIMIZATION)
        ask(plJointDistribution self, plDistribution Expr, plVariablesConjunction searched_variables)
        ask(plJointDistribution self, plVariablesConjunction searched_variables, plOptimizationCriterion optimization=PL_NO_OPTIMIZATION) -> plDistribution
        ask(plJointDistribution self, plVariablesConjunction searched_variables) -> plDistribution
        """
        return _pypl.plJointDistribution_ask(self, *args)

    def ask_mc_nsamples(self, *args):
        """
        ask_mc_nsamples(plJointDistribution self, plCndDistribution CndExpr, plVariablesConjunction searched_variables, plVariablesConjunction known_variables, 
            int mc_nsamples, bool do_not_build_normalization_expression=False)
        ask_mc_nsamples(plJointDistribution self, plCndDistribution CndExpr, plVariablesConjunction searched_variables, plVariablesConjunction known_variables, 
            int mc_nsamples)
        ask_mc_nsamples(plJointDistribution self, plVariablesConjunction searched_variables, plVariablesConjunction known_variables, 
            int mc_nsamples, bool do_not_build_normalization_expression=False) -> plCndDistribution
        ask_mc_nsamples(plJointDistribution self, plVariablesConjunction searched_variables, plVariablesConjunction known_variables, 
            int mc_nsamples) -> plCndDistribution
        ask_mc_nsamples(plJointDistribution self, plCndDistribution CndExpr, plVariablesConjunction searched_variables, plVariablesConjunction known_variables, 
            unsigned int mc_nsamples, bool do_not_build_normalization_expression=False)
        ask_mc_nsamples(plJointDistribution self, plCndDistribution CndExpr, plVariablesConjunction searched_variables, plVariablesConjunction known_variables, 
            unsigned int mc_nsamples)
        ask_mc_nsamples(plJointDistribution self, plVariablesConjunction searched_variables, plVariablesConjunction known_variables, 
            unsigned int mc_nsamples, bool do_not_build_normalization_expression=False) -> plCndDistribution
        ask_mc_nsamples(plJointDistribution self, plVariablesConjunction searched_variables, plVariablesConjunction known_variables, 
            unsigned int mc_nsamples) -> plCndDistribution
        ask_mc_nsamples(plJointDistribution self, plDistribution Expr, plVariablesConjunction searched_variables, int mc_nsamples)
        ask_mc_nsamples(plJointDistribution self, plVariablesConjunction searched_variables, int mc_nsamples) -> plDistribution
        ask_mc_nsamples(plJointDistribution self, plDistribution Expr, plVariablesConjunction searched_variables, unsigned int mc_nsamples)
        ask_mc_nsamples(plJointDistribution self, plVariablesConjunction searched_variables, unsigned int mc_nsamples) -> plDistribution
        """
        return _pypl.plJointDistribution_ask_mc_nsamples(self, *args)

    def ask_mc_convergence(self, *args):
        """
        ask_mc_convergence(plJointDistribution self, plCndDistribution CndExpr, plVariablesConjunction searched_variables, plVariablesConjunction known_variables, 
            float conv_threshold, bool do_not_build_normalization_expression=False)
        ask_mc_convergence(plJointDistribution self, plCndDistribution CndExpr, plVariablesConjunction searched_variables, plVariablesConjunction known_variables, 
            float conv_threshold)
        ask_mc_convergence(plJointDistribution self, plVariablesConjunction searched_variables, plVariablesConjunction known_variables, 
            float conv_threshold, bool do_not_build_normalization_expression=False) -> plCndDistribution
        ask_mc_convergence(plJointDistribution self, plVariablesConjunction searched_variables, plVariablesConjunction known_variables, 
            float conv_threshold) -> plCndDistribution
        ask_mc_convergence(plJointDistribution self, plCndDistribution CndExpr, plVariablesConjunction searched_variables, plVariablesConjunction known_variables, 
            double conv_threshold, bool do_not_build_normalization_expression=False)
        ask_mc_convergence(plJointDistribution self, plCndDistribution CndExpr, plVariablesConjunction searched_variables, plVariablesConjunction known_variables, 
            double conv_threshold)
        ask_mc_convergence(plJointDistribution self, plVariablesConjunction searched_variables, plVariablesConjunction known_variables, 
            double conv_threshold, bool do_not_build_normalization_expression=False) -> plCndDistribution
        ask_mc_convergence(plJointDistribution self, plVariablesConjunction searched_variables, plVariablesConjunction known_variables, 
            double conv_threshold) -> plCndDistribution
        ask_mc_convergence(plJointDistribution self, plDistribution Expr, plVariablesConjunction searched_variables, float conv_threshold)
        ask_mc_convergence(plJointDistribution self, plVariablesConjunction searched_variables, float conv_threshold) -> plDistribution
        ask_mc_convergence(plJointDistribution self, plDistribution Expr, plVariablesConjunction searched_variables, double conv_threshold)
        ask_mc_convergence(plJointDistribution self, plVariablesConjunction searched_variables, double conv_threshold) -> plDistribution
        """
        return _pypl.plJointDistribution_ask_mc_convergence(self, *args)

    def get_computable_object_list(self):
        """get_computable_object_list(plJointDistribution self) -> plComputableObjectList"""
        return _pypl.plJointDistribution_get_computable_object_list(self)

    def get_markov_blanket(self, *args):
        """get_markov_blanket(plJointDistribution self, plSymbol s) -> plVariablesConjunction"""
        return _pypl.plJointDistribution_get_markov_blanket(self, *args)

    def set_soft_evidence_variables(self, *args):
        """set_soft_evidence_variables(plJointDistribution self, plVariablesConjunction variables)"""
        return _pypl.plJointDistribution_set_soft_evidence_variables(self, *args)

    def clear_soft_evidence_variables(self):
        """clear_soft_evidence_variables(plJointDistribution self)"""
        return _pypl.plJointDistribution_clear_soft_evidence_variables(self)

    def is_base_class(self):
        """is_base_class(plJointDistribution self) -> bool"""
        return _pypl.plJointDistribution_is_base_class(self)

    def save_as_genie(self, *args):
        """save_as_genie(plJointDistribution self, std::string const & file_name)"""
        return _pypl.plJointDistribution_save_as_genie(self, *args)

    def load_from_genie(self, *args):
        """load_from_genie(plJointDistribution self, std::string const & file_name)"""
        return _pypl.plJointDistribution_load_from_genie(self, *args)

    def save_as_netica(self, *args):
        """save_as_netica(plJointDistribution self, std::string const & file_name)"""
        return _pypl.plJointDistribution_save_as_netica(self, *args)

    def load_from_netica(self, *args):
        """load_from_netica(plJointDistribution self, std::string const & file_name)"""
        return _pypl.plJointDistribution_load_from_netica(self, *args)

    def save_as_hugin(self, *args):
        """save_as_hugin(plJointDistribution self, std::string const & file_name)"""
        return _pypl.plJointDistribution_save_as_hugin(self, *args)

    def load_from_hugin(self, *args):
        """load_from_hugin(plJointDistribution self, std::string const & file_name)"""
        return _pypl.plJointDistribution_load_from_hugin(self, *args)

plJointDistribution_swigregister = _pypl.plJointDistribution_swigregister
plJointDistribution_swigregister(plJointDistribution)

class plJunctionTree(_object):
    """Proxy of C++ plJunctionTree class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plJunctionTree, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plJunctionTree, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plJunctionTree
    __del__ = lambda self : None;
    def __init__(self, *args): 
        """
        __init__(plJunctionTree self) -> plJunctionTree
        __init__(plJunctionTree self, plComputableObjectList decomposition) -> plJunctionTree
        __init__(plJunctionTree self, plJointDistribution joint) -> plJunctionTree
        """
        this = _pypl.new_plJunctionTree(*args)
        try: self.this.append(this)
        except: self.this = this
    def set_decomposition(self, *args):
        """set_decomposition(plJunctionTree self, plComputableObjectList decomposition)"""
        return _pypl.plJunctionTree_set_decomposition(self, *args)

    def ask(self, *args):
        """
        ask(plJunctionTree self, plVariablesConjunction variables) -> plJtDistribution
        ask(plJunctionTree self, plVariablesConjunction left, plVariablesConjunction right, bool do_not_build_normalization_expression=False) -> plCndJtDistribution
        ask(plJunctionTree self, plVariablesConjunction left, plVariablesConjunction right) -> plCndJtDistribution
        """
        return _pypl.plJunctionTree_ask(self, *args)

    def output_debug(self):
        """output_debug(plJunctionTree self)"""
        return _pypl.plJunctionTree_output_debug(self)

    def output_dot(self):
        """output_dot(plJunctionTree self)"""
        return _pypl.plJunctionTree_output_dot(self)

plJunctionTree_swigregister = _pypl.plJunctionTree_swigregister
plJunctionTree_swigregister(plJunctionTree)

class plMutableDistribution(plDistribution):
    """Proxy of C++ plMutable<(plDistribution)> class"""
    __swig_setmethods__ = {}
    for _s in [plDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plMutableDistribution, name, value)
    __swig_getmethods__ = {}
    for _s in [plDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plMutableDistribution, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plMutable<(plDistribution)> self) -> plMutableDistribution
        __init__(plMutable<(plDistribution)> self, plDistribution init_object) -> plMutableDistribution
        __init__(plMutable<(plDistribution)> self, plMutableDistribution other) -> plMutableDistribution
        """
        this = _pypl.new_plMutableDistribution(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plMutableDistribution
    __del__ = lambda self : None;
    def mutate(self, *args):
        """mutate(plMutableDistribution self, plDistribution new_object)"""
        return _pypl.plMutableDistribution_mutate(self, *args)

plMutableDistribution_swigregister = _pypl.plMutableDistribution_swigregister
plMutableDistribution_swigregister(plMutableDistribution)

class plMutableCndDistribution(plCndDistribution):
    """Proxy of C++ plMutable<(plCndDistribution)> class"""
    __swig_setmethods__ = {}
    for _s in [plCndDistribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plMutableCndDistribution, name, value)
    __swig_getmethods__ = {}
    for _s in [plCndDistribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plMutableCndDistribution, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plMutable<(plCndDistribution)> self) -> plMutableCndDistribution
        __init__(plMutable<(plCndDistribution)> self, plCndDistribution init_object) -> plMutableCndDistribution
        __init__(plMutable<(plCndDistribution)> self, plMutableCndDistribution other) -> plMutableCndDistribution
        """
        this = _pypl.new_plMutableCndDistribution(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plMutableCndDistribution
    __del__ = lambda self : None;
    def mutate(self, *args):
        """mutate(plMutableCndDistribution self, plCndDistribution new_object)"""
        return _pypl.plMutableCndDistribution_mutate(self, *args)

plMutableCndDistribution_swigregister = _pypl.plMutableCndDistribution_swigregister
plMutableCndDistribution_swigregister(plMutableCndDistribution)

class plMutableComputableObject(plComputableObject):
    """Proxy of C++ plMutable<(plComputableObject)> class"""
    __swig_setmethods__ = {}
    for _s in [plComputableObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plMutableComputableObject, name, value)
    __swig_getmethods__ = {}
    for _s in [plComputableObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plMutableComputableObject, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plMutable<(plComputableObject)> self) -> plMutableComputableObject
        __init__(plMutable<(plComputableObject)> self, plComputableObject init_object) -> plMutableComputableObject
        __init__(plMutable<(plComputableObject)> self, plMutableComputableObject other) -> plMutableComputableObject
        """
        this = _pypl.new_plMutableComputableObject(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plMutableComputableObject
    __del__ = lambda self : None;
    def mutate(self, *args):
        """mutate(plMutableComputableObject self, plComputableObject new_object)"""
        return _pypl.plMutableComputableObject_mutate(self, *args)

plMutableComputableObject_swigregister = _pypl.plMutableComputableObject_swigregister
plMutableComputableObject_swigregister(plMutableComputableObject)

class plVariableIndexer(plSampleSpaceObject):
    """Proxy of C++ plVariableIndexer class"""
    __swig_setmethods__ = {}
    for _s in [plSampleSpaceObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plVariableIndexer, name, value)
    __swig_getmethods__ = {}
    for _s in [plSampleSpaceObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plVariableIndexer, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plVariableIndexer self) -> plVariableIndexer
        __init__(plVariableIndexer self, plVariablesConjunction vars) -> plVariableIndexer
        __init__(plVariableIndexer self, plVariableIndexer other) -> plVariableIndexer
        """
        this = _pypl.new_plVariableIndexer(*args)
        try: self.this.append(this)
        except: self.this = this
    def assign_from(self, *args):
        """assign_from(plVariableIndexer self, plVariableIndexer other) -> plVariableIndexer"""
        return _pypl.plVariableIndexer_assign_from(self, *args)

    __swig_destroy__ = _pypl.delete_plVariableIndexer
    __del__ = lambda self : None;
    def get_symbol_cardinality(self, *args):
        """get_symbol_cardinality(plVariableIndexer self, unsigned int n) -> unsigned int"""
        return _pypl.plVariableIndexer_get_symbol_cardinality(self, *args)

    def get_index_from_value(self, *args):
        """
        get_index_from_value(plVariableIndexer self, plValues value, unsigned int & index) -> bool
        get_index_from_value(plVariableIndexer self, plDataValues value, unsigned int & index) -> bool
        """
        return _pypl.plVariableIndexer_get_index_from_value(self, *args)

    def get_value_from_index(self, *args):
        """
        get_value_from_index(plVariableIndexer self, unsigned int index, plValues value) -> bool
        get_value_from_index(plVariableIndexer self, unsigned int index, plDataValues value) -> bool
        """
        return _pypl.plVariableIndexer_get_value_from_index(self, *args)

plVariableIndexer_swigregister = _pypl.plVariableIndexer_swigregister
plVariableIndexer_swigregister(plVariableIndexer)

PL_CHOOSE_GENERATOR_FOR_ME = _pypl.PL_CHOOSE_GENERATOR_FOR_ME
PL_EXHAUSTIVE_GENERATOR = _pypl.PL_EXHAUSTIVE_GENERATOR
PL_GA_GENERATOR = _pypl.PL_GA_GENERATOR
PL_RANDOM_GENERATOR = _pypl.PL_RANDOM_GENERATOR
PL_MC_GENERATOR = _pypl.PL_MC_GENERATOR
PL_CHOOSE_COMP_TYPE_FOR_ME = _pypl.PL_CHOOSE_COMP_TYPE_FOR_ME
PL_MRBT = _pypl.PL_MRBT
PL_TABLE = _pypl.PL_TABLE
PL_MAP = _pypl.PL_MAP
PL_OPTIMIZE_COMPILATION_TIME = _pypl.PL_OPTIMIZE_COMPILATION_TIME
PL_OPTIMIZE_UPDATE_TIME = _pypl.PL_OPTIMIZE_UPDATE_TIME
PL_OPTIMIZE_MEMORY_USE = _pypl.PL_OPTIMIZE_MEMORY_USE
PL_NO_OPTIMIZATION = _pypl.PL_NO_OPTIMIZATION
PL_DEFAULT_PLOT = _pypl.PL_DEFAULT_PLOT
PL_EPS_COLOR_PLOT = _pypl.PL_EPS_COLOR_PLOT
PL_EPS_PLOT = _pypl.PL_EPS_PLOT
PL_FIG_PLOT = _pypl.PL_FIG_PLOT
PL_JPEG_PLOT = _pypl.PL_JPEG_PLOT
PL_LATEX_PLOT = _pypl.PL_LATEX_PLOT
PL_PDF_COLOR_PLOT = _pypl.PL_PDF_COLOR_PLOT
PL_PDF_PLOT = _pypl.PL_PDF_PLOT
PL_PNG_PLOT = _pypl.PL_PNG_PLOT
PL_POSTSCRIPT_COLOR_PLOT = _pypl.PL_POSTSCRIPT_COLOR_PLOT
PL_POSTSCRIPT_PLOT = _pypl.PL_POSTSCRIPT_PLOT
class plKalmanFilter(plBuiltinModel):
    """Proxy of C++ plKalmanFilter class"""
    __swig_setmethods__ = {}
    for _s in [plBuiltinModel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plKalmanFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [plBuiltinModel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plKalmanFilter, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plKalmanFilter self) -> plKalmanFilter
        __init__(plKalmanFilter self, unsigned int state_dim, unsigned int obs_dim, unsigned int command_dim=0) -> plKalmanFilter
        __init__(plKalmanFilter self, unsigned int state_dim, unsigned int obs_dim) -> plKalmanFilter
        __init__(plKalmanFilter self, plFloatVector init_estimation_mean, plFloatMatrix init_estimation_cov_matrix, plFloatMatrix prediction_matrix, 
            plFloatMatrix prediction_noise_cov_matrix, plFloatMatrix observation_matrix, 
            plFloatMatrix observation_noise_cov_matrix, 
            plFloatMatrix control_matrix=plFloatMatrix()) -> plKalmanFilter
        __init__(plKalmanFilter self, plFloatVector init_estimation_mean, plFloatMatrix init_estimation_cov_matrix, plFloatMatrix prediction_matrix, 
            plFloatMatrix prediction_noise_cov_matrix, plFloatMatrix observation_matrix, 
            plFloatMatrix observation_noise_cov_matrix) -> plKalmanFilter
        """
        this = _pypl.new_plKalmanFilter(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_state_dim(self):
        """get_state_dim(plKalmanFilter self) -> unsigned int"""
        return _pypl.plKalmanFilter_get_state_dim(self)

    def get_observation_dim(self):
        """get_observation_dim(plKalmanFilter self) -> unsigned int"""
        return _pypl.plKalmanFilter_get_observation_dim(self)

    def get_command_dim(self):
        """get_command_dim(plKalmanFilter self) -> unsigned int"""
        return _pypl.plKalmanFilter_get_command_dim(self)

    __swig_destroy__ = _pypl.delete_plKalmanFilter
    __del__ = lambda self : None;
    def set_prediction_matrix(self, *args):
        """set_prediction_matrix(plKalmanFilter self, plFloatMatrix Ain)"""
        return _pypl.plKalmanFilter_set_prediction_matrix(self, *args)

    def set_prediction_noise_cov_matrix(self, *args):
        """set_prediction_noise_cov_matrix(plKalmanFilter self, plFloatMatrix QS)"""
        return _pypl.plKalmanFilter_set_prediction_noise_cov_matrix(self, *args)

    def set_observation_matrix(self, *args):
        """set_observation_matrix(plKalmanFilter self, plFloatMatrix Hin)"""
        return _pypl.plKalmanFilter_set_observation_matrix(self, *args)

    def set_observation_noise_cov_matrix(self, *args):
        """set_observation_noise_cov_matrix(plKalmanFilter self, plFloatMatrix Ro)"""
        return _pypl.plKalmanFilter_set_observation_noise_cov_matrix(self, *args)

    def set_control_matrix(self, *args):
        """set_control_matrix(plKalmanFilter self, plFloatMatrix Bin)"""
        return _pypl.plKalmanFilter_set_control_matrix(self, *args)

    def set_control(self, *args):
        """set_control(plKalmanFilter self, plFloatVector Uin)"""
        return _pypl.plKalmanFilter_set_control(self, *args)

    def set_initial_estimation(self, *args):
        """set_initial_estimation(plKalmanFilter self, plFloatVector Xo, plFloatMatrix Po)"""
        return _pypl.plKalmanFilter_set_initial_estimation(self, *args)

    def set_observation(self, *args):
        """
        set_observation(plKalmanFilter self, plFloatVector Zin, plFloat observation_weight_in=1.0)
        set_observation(plKalmanFilter self, plFloatVector Zin)
        """
        return _pypl.plKalmanFilter_set_observation(self, *args)

    def prediction(self):
        """prediction(plKalmanFilter self)"""
        return _pypl.plKalmanFilter_prediction(self)

    def update(self):
        """update(plKalmanFilter self)"""
        return _pypl.plKalmanFilter_update(self)

    def observation(self, *args):
        """
        observation(plKalmanFilter self, plFloatVector zo, plFloat observation_weight=1.0)
        observation(plKalmanFilter self, plFloatVector zo)
        observation(plKalmanFilter self, plFloatVector zo, plFloatMatrix Ro, plFloat observation_weight=1.0)
        observation(plKalmanFilter self, plFloatVector zo, plFloatMatrix Ro)
        """
        return _pypl.plKalmanFilter_observation(self, *args)

    def prediction_observation(self, *args):
        """
        prediction_observation(plKalmanFilter self, plFloatVector zo, plFloat observation_weight=1.0)
        prediction_observation(plKalmanFilter self, plFloatVector zo)
        prediction_observation(plKalmanFilter self, plFloatVector zo, plFloatMatrix Ro, plFloat observation_weight=1.0)
        prediction_observation(plKalmanFilter self, plFloatVector zo, plFloatMatrix Ro)
        """
        return _pypl.plKalmanFilter_prediction_observation(self, *args)

    def get_estimation_mean(self):
        """get_estimation_mean(plKalmanFilter self) -> plFloatVector"""
        return _pypl.plKalmanFilter_get_estimation_mean(self)

    def get_estimation_covariance(self):
        """get_estimation_covariance(plKalmanFilter self) -> plFloatMatrix"""
        return _pypl.plKalmanFilter_get_estimation_covariance(self)

    def get_observation_mahalanobis_distance(self, *args):
        """
        get_observation_mahalanobis_distance(plKalmanFilter self, plFloatVector zo) -> plFloat
        get_observation_mahalanobis_distance(plKalmanFilter self, plFloatVector zo, plFloat & det) -> plFloat
        get_observation_mahalanobis_distance(plKalmanFilter self, plFloatVector zo, plFloatMatrix Ro) -> plFloat
        get_observation_mahalanobis_distance(plKalmanFilter self, plFloatVector zo, plFloatMatrix Ro, plFloat & det) -> plFloat
        """
        return _pypl.plKalmanFilter_get_observation_mahalanobis_distance(self, *args)

    def get_pdf_value(self, *args):
        """
        get_pdf_value(plKalmanFilter self, plFloatVector zo) -> plProbValue
        get_pdf_value(plKalmanFilter self, plFloatVector zo, plFloatMatrix Ro) -> plProbValue
        """
        return _pypl.plKalmanFilter_get_pdf_value(self, *args)

    def use_eigen_decomposition_matrix_inversion(self, *args):
        """use_eigen_decomposition_matrix_inversion(plKalmanFilter self, bool eigen_decomposition_inversion)"""
        return _pypl.plKalmanFilter_use_eigen_decomposition_matrix_inversion(self, *args)

    def set_greville_inversion_threshold(self, *args):
        """set_greville_inversion_threshold(plKalmanFilter self, plFloat threshold)"""
        return _pypl.plKalmanFilter_set_greville_inversion_threshold(self, *args)

    __swig_setmethods__["A"] = _pypl.plKalmanFilter_A_set
    __swig_getmethods__["A"] = _pypl.plKalmanFilter_A_get
    if _newclass:A = _swig_property(_pypl.plKalmanFilter_A_get, _pypl.plKalmanFilter_A_set)
    __swig_setmethods__["H"] = _pypl.plKalmanFilter_H_set
    __swig_getmethods__["H"] = _pypl.plKalmanFilter_H_get
    if _newclass:H = _swig_property(_pypl.plKalmanFilter_H_get, _pypl.plKalmanFilter_H_set)
    __swig_setmethods__["B"] = _pypl.plKalmanFilter_B_set
    __swig_getmethods__["B"] = _pypl.plKalmanFilter_B_get
    if _newclass:B = _swig_property(_pypl.plKalmanFilter_B_get, _pypl.plKalmanFilter_B_set)
    __swig_setmethods__["z"] = _pypl.plKalmanFilter_z_set
    __swig_getmethods__["z"] = _pypl.plKalmanFilter_z_get
    if _newclass:z = _swig_property(_pypl.plKalmanFilter_z_get, _pypl.plKalmanFilter_z_set)
    __swig_setmethods__["u"] = _pypl.plKalmanFilter_u_set
    __swig_getmethods__["u"] = _pypl.plKalmanFilter_u_get
    if _newclass:u = _swig_property(_pypl.plKalmanFilter_u_get, _pypl.plKalmanFilter_u_set)
    __swig_setmethods__["Q"] = _pypl.plKalmanFilter_Q_set
    __swig_getmethods__["Q"] = _pypl.plKalmanFilter_Q_get
    if _newclass:Q = _swig_property(_pypl.plKalmanFilter_Q_get, _pypl.plKalmanFilter_Q_set)
    __swig_setmethods__["R"] = _pypl.plKalmanFilter_R_set
    __swig_getmethods__["R"] = _pypl.plKalmanFilter_R_get
    if _newclass:R = _swig_property(_pypl.plKalmanFilter_R_get, _pypl.plKalmanFilter_R_set)
    __swig_setmethods__["x_current_estimation"] = _pypl.plKalmanFilter_x_current_estimation_set
    __swig_getmethods__["x_current_estimation"] = _pypl.plKalmanFilter_x_current_estimation_get
    if _newclass:x_current_estimation = _swig_property(_pypl.plKalmanFilter_x_current_estimation_get, _pypl.plKalmanFilter_x_current_estimation_set)
    __swig_setmethods__["P_current_estimation"] = _pypl.plKalmanFilter_P_current_estimation_set
    __swig_getmethods__["P_current_estimation"] = _pypl.plKalmanFilter_P_current_estimation_get
    if _newclass:P_current_estimation = _swig_property(_pypl.plKalmanFilter_P_current_estimation_get, _pypl.plKalmanFilter_P_current_estimation_set)
plKalmanFilter_swigregister = _pypl.plKalmanFilter_swigregister
plKalmanFilter_swigregister(plKalmanFilter)

class plEKF(plKalmanFilter):
    """Proxy of C++ plEKF class"""
    __swig_setmethods__ = {}
    for _s in [plKalmanFilter]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plEKF, name, value)
    __swig_getmethods__ = {}
    for _s in [plKalmanFilter]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plEKF, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plEKF
    __del__ = lambda self : None;
    def prediction(self):
        """prediction(plEKF self)"""
        return _pypl.plEKF_prediction(self)

    def observation(self, *args):
        """
        observation(plEKF self, plFloatVector zo, plFloat observation_weight=1.0)
        observation(plEKF self, plFloatVector zo)
        observation(plEKF self, plFloatVector zo, plFloatMatrix Ro, plFloat observation_weight=1.0)
        observation(plEKF self, plFloatVector zo, plFloatMatrix Ro)
        """
        return _pypl.plEKF_observation(self, *args)

    def get_observation_mahalanobis_distance(self, *args):
        """
        get_observation_mahalanobis_distance(plEKF self, plFloatVector zo) -> plFloat
        get_observation_mahalanobis_distance(plEKF self, plFloatVector zo, plFloat & det) -> plFloat
        get_observation_mahalanobis_distance(plEKF self, plFloatVector zo, plFloatMatrix Ro) -> plFloat
        get_observation_mahalanobis_distance(plEKF self, plFloatVector zo, plFloatMatrix Ro, plFloat & det) -> plFloat
        """
        return _pypl.plEKF_get_observation_mahalanobis_distance(self, *args)

    def get_pdf_value(self, *args):
        """
        get_pdf_value(plEKF self, plFloatVector zo) -> plProbValue
        get_pdf_value(plEKF self, plFloatVector zo, plFloatMatrix Ro) -> plProbValue
        """
        return _pypl.plEKF_get_pdf_value(self, *args)

plEKF_swigregister = _pypl.plEKF_swigregister
plEKF_swigregister(plEKF)

class plHMM(plBuiltinModel):
    """Proxy of C++ plHMM class"""
    __swig_setmethods__ = {}
    for _s in [plBuiltinModel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plHMM, name, value)
    __swig_getmethods__ = {}
    for _s in [plBuiltinModel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plHMM, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plHMM self) -> plHMM
        __init__(plHMM self, DoubleVector init_state_distribution, DoubleVectorVector transition_distribution, 
            DoubleVectorVector emission_distribution) -> plHMM
        __init__(plHMM self, plDistribution init_state_distribution, plCndDistribution transition_distribution, 
            plCndDistribution emission_distribution, bool tabulate_emission_distribution=False, 
            bool tabulate_transition_distribution=True) -> plHMM
        __init__(plHMM self, plDistribution init_state_distribution, plCndDistribution transition_distribution, 
            plCndDistribution emission_distribution, bool tabulate_emission_distribution=False) -> plHMM
        __init__(plHMM self, plDistribution init_state_distribution, plCndDistribution transition_distribution, 
            plCndDistribution emission_distribution) -> plHMM
        """
        this = _pypl.new_plHMM(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plHMM
    __del__ = lambda self : None;
    def is_empty(self):
        """is_empty(plHMM self) -> bool"""
        return _pypl.plHMM_is_empty(self)

    def set_name(self, *args):
        """set_name(plHMM self, std::string const & name)"""
        return _pypl.plHMM_set_name(self, *args)

    def get_name(self):
        """get_name(plHMM self) -> std::string const &"""
        return _pypl.plHMM_get_name(self)

    def train_supervised(self, *args):
        """
        train_supervised(plHMM self, DoubleVectorVectorVector observation_sequences, std::vector< plHMM::StateSequence_t,std::allocator< plHMM::StateSequence_t > > const & state_sequences, 
            plLearnObject emission_distribution_learner, 
            plLearnObject init_state_distribution_learner=None, 
            plLearnObject transition_distribution_learner=None, bool tabulate_emission_distribution=False, 
            bool tabulate_transition_distribution=True)
        train_supervised(plHMM self, DoubleVectorVectorVector observation_sequences, std::vector< plHMM::StateSequence_t,std::allocator< plHMM::StateSequence_t > > const & state_sequences, 
            plLearnObject emission_distribution_learner, 
            plLearnObject init_state_distribution_learner=None, 
            plLearnObject transition_distribution_learner=None, bool tabulate_emission_distribution=False)
        train_supervised(plHMM self, DoubleVectorVectorVector observation_sequences, std::vector< plHMM::StateSequence_t,std::allocator< plHMM::StateSequence_t > > const & state_sequences, 
            plLearnObject emission_distribution_learner, 
            plLearnObject init_state_distribution_learner=None, 
            plLearnObject transition_distribution_learner=None)
        train_supervised(plHMM self, DoubleVectorVectorVector observation_sequences, std::vector< plHMM::StateSequence_t,std::allocator< plHMM::StateSequence_t > > const & state_sequences, 
            plLearnObject emission_distribution_learner, 
            plLearnObject init_state_distribution_learner=None)
        train_supervised(plHMM self, DoubleVectorVectorVector observation_sequences, std::vector< plHMM::StateSequence_t,std::allocator< plHMM::StateSequence_t > > const & state_sequences, 
            plLearnObject emission_distribution_learner)
        train_supervised(plHMM self, unsigned int nstates, DoubleVectorVectorVector observation_sequences, std::vector< plHMM::StateSequence_t,std::allocator< plHMM::StateSequence_t > > const & state_sequences, 
            int obs_min_value, 
            int obs_max_value, bool tabulate_emission_distribution=False, 
            bool tabulate_transition_distribution=True)
        train_supervised(plHMM self, unsigned int nstates, DoubleVectorVectorVector observation_sequences, std::vector< plHMM::StateSequence_t,std::allocator< plHMM::StateSequence_t > > const & state_sequences, 
            int obs_min_value, 
            int obs_max_value, bool tabulate_emission_distribution=False)
        train_supervised(plHMM self, unsigned int nstates, DoubleVectorVectorVector observation_sequences, std::vector< plHMM::StateSequence_t,std::allocator< plHMM::StateSequence_t > > const & state_sequences, 
            int obs_min_value, 
            int obs_max_value)
        """
        return _pypl.plHMM_train_supervised(self, *args)

    def train_unsupervised_viterbi(self, *args):
        """
        train_unsupervised_viterbi(plHMM self, DoubleVectorVectorVector observation_sequences, plLearnObject emission_distribution_learner, 
            plLearnObject init_state_distribution_learner=None, plLearnObject transition_distribution_learner=None, 
            bool tabulate_emission_distribution=False, 
            bool tabulate_transition_distribution=True, bool left_to_right_init=False) -> plFloat
        train_unsupervised_viterbi(plHMM self, DoubleVectorVectorVector observation_sequences, plLearnObject emission_distribution_learner, 
            plLearnObject init_state_distribution_learner=None, plLearnObject transition_distribution_learner=None, 
            bool tabulate_emission_distribution=False, 
            bool tabulate_transition_distribution=True) -> plFloat
        train_unsupervised_viterbi(plHMM self, DoubleVectorVectorVector observation_sequences, plLearnObject emission_distribution_learner, 
            plLearnObject init_state_distribution_learner=None, plLearnObject transition_distribution_learner=None, 
            bool tabulate_emission_distribution=False) -> plFloat
        train_unsupervised_viterbi(plHMM self, DoubleVectorVectorVector observation_sequences, plLearnObject emission_distribution_learner, 
            plLearnObject init_state_distribution_learner=None, plLearnObject transition_distribution_learner=None) -> plFloat
        train_unsupervised_viterbi(plHMM self, DoubleVectorVectorVector observation_sequences, plLearnObject emission_distribution_learner, 
            plLearnObject init_state_distribution_learner=None) -> plFloat
        train_unsupervised_viterbi(plHMM self, DoubleVectorVectorVector observation_sequences, plLearnObject emission_distribution_learner) -> plFloat
        train_unsupervised_viterbi(plHMM self, unsigned int nstates, DoubleVectorVectorVector observation_sequences, int obs_min_value, 
            int obs_max_value, bool tabulate_emission_distribution=False, bool tabulate_transition_distribution=True, 
            bool left_to_right_init=False) -> plFloat
        train_unsupervised_viterbi(plHMM self, unsigned int nstates, DoubleVectorVectorVector observation_sequences, int obs_min_value, 
            int obs_max_value, bool tabulate_emission_distribution=False, bool tabulate_transition_distribution=True) -> plFloat
        train_unsupervised_viterbi(plHMM self, unsigned int nstates, DoubleVectorVectorVector observation_sequences, int obs_min_value, 
            int obs_max_value, bool tabulate_emission_distribution=False) -> plFloat
        train_unsupervised_viterbi(plHMM self, unsigned int nstates, DoubleVectorVectorVector observation_sequences, int obs_min_value, 
            int obs_max_value) -> plFloat
        """
        return _pypl.plHMM_train_unsupervised_viterbi(self, *args)

    def get_nstates(self):
        """get_nstates(plHMM self) -> unsigned int"""
        return _pypl.plHMM_get_nstates(self)

    def get_init_state_distribution(self):
        """get_init_state_distribution(plHMM self) -> plDistribution"""
        return _pypl.plHMM_get_init_state_distribution(self)

    def get_transition_distribution(self):
        """get_transition_distribution(plHMM self) -> plCndDistribution"""
        return _pypl.plHMM_get_transition_distribution(self)

    def get_emission_distribution(self):
        """get_emission_distribution(plHMM self) -> plCndDistribution"""
        return _pypl.plHMM_get_emission_distribution(self)

    def update_states_probabilities(self, *args):
        """update_states_probabilities(plHMM self, DoubleVector observation) -> plFloat"""
        return _pypl.plHMM_update_states_probabilities(self, *args)

    def compute_states_probabilities_log(self, *args):
        """compute_states_probabilities_log(plHMM self, DoubleVector observation, DoubleVector states_probabilities_log) -> plFloat"""
        return _pypl.plHMM_compute_states_probabilities_log(self, *args)

    def get_state_distribution(self, *args):
        """get_state_distribution(plHMM self, DoubleVector state_probabilities)"""
        return _pypl.plHMM_get_state_distribution(self, *args)

    def get_state_distribution_log(self):
        """get_state_distribution_log(plHMM self) -> DoubleVector"""
        return _pypl.plHMM_get_state_distribution_log(self)

    def get_most_probable_state_sequence(self, *args):
        """get_most_probable_state_sequence(plHMM self, UnsignedIntVector state_sequence, DoubleVectorVector observation_sequence)"""
        return _pypl.plHMM_get_most_probable_state_sequence(self, *args)

    def get_observation_sequence_log_likelihood(self, *args):
        """get_observation_sequence_log_likelihood(plHMM self, DoubleVectorVector observation_sequence) -> plFloat"""
        return _pypl.plHMM_get_observation_sequence_log_likelihood(self, *args)

    def get_observation_sequences_log_likelihood(self, *args):
        """get_observation_sequences_log_likelihood(plHMM self, DoubleVectorVectorVector observation_sequences) -> plFloat"""
        return _pypl.plHMM_get_observation_sequences_log_likelihood(self, *args)

    def generate_sequence(self, *args):
        """
        generate_sequence(plHMM self, unsigned int seq_length, std::string const & csv_file_name, bool save_state=False, 
            char separator=';') -> bool
        generate_sequence(plHMM self, unsigned int seq_length, std::string const & csv_file_name, bool save_state=False) -> bool
        generate_sequence(plHMM self, unsigned int seq_length, std::string const & csv_file_name) -> bool
        generate_sequence(plHMM self, unsigned int seq_length, DoubleVectorVector observation_sequence, UnsignedIntVector state_sequence)
        generate_sequence(plHMM self, unsigned int seq_length, DoubleVectorVector observation_sequence)
        """
        return _pypl.plHMM_generate_sequence(self, *args)

    def set_final_states(self, *args):
        """set_final_states(plHMM self, UnsignedIntVector final_states)"""
        return _pypl.plHMM_set_final_states(self, *args)

    def get_final_states(self):
        """get_final_states(plHMM self) -> UnsignedIntVector"""
        return _pypl.plHMM_get_final_states(self)

    def is_final_state(self, *args):
        """is_final_state(plHMM self, plHMM::State_t s) -> bool"""
        return _pypl.plHMM_is_final_state(self, *args)

    def is_in_final_state(self, *args):
        """is_in_final_state(plHMM self, plProbValue prob) -> bool"""
        return _pypl.plHMM_is_in_final_state(self, *args)

    def set_state_distribution_log(self, *args):
        """set_state_distribution_log(plHMM self, DoubleVector state_probabilities_log)"""
        return _pypl.plHMM_set_state_distribution_log(self, *args)

    def set_state_distribution(self, *args):
        """
        set_state_distribution(plHMM self, DoubleVector state_probabilities)
        set_state_distribution(plHMM self, plDistribution state_distribution)
        """
        return _pypl.plHMM_set_state_distribution(self, *args)

    def reset_state_distribution(self):
        """reset_state_distribution(plHMM self)"""
        return _pypl.plHMM_reset_state_distribution(self)

    def set_nstates(self, *args):
        """set_nstates(plHMM self, unsigned int n)"""
        return _pypl.plHMM_set_nstates(self, *args)

    def predict_states_probabilities(self):
        """predict_states_probabilities(plHMM self)"""
        return _pypl.plHMM_predict_states_probabilities(self)

    def set_init_state_table(self, *args):
        """
        set_init_state_table(plHMM self, DoubleVector init_state_distribution, bool is_already_normalized=False)
        set_init_state_table(plHMM self, DoubleVector init_state_distribution)
        """
        return _pypl.plHMM_set_init_state_table(self, *args)

    def set_init_state_distribution(self, *args):
        """set_init_state_distribution(plHMM self, plDistribution init_state_distribution)"""
        return _pypl.plHMM_set_init_state_distribution(self, *args)

    def set_transition_table(self, *args):
        """
        set_transition_table(plHMM self, DoubleVectorVector transition_distribution, bool is_already_normalized=False)
        set_transition_table(plHMM self, DoubleVectorVector transition_distribution)
        """
        return _pypl.plHMM_set_transition_table(self, *args)

    def set_transition_distribution(self, *args):
        """set_transition_distribution(plHMM self, plCndDistribution transition_distribution, bool tabulate_transition_distribution)"""
        return _pypl.plHMM_set_transition_distribution(self, *args)

    def set_emission_table(self, *args):
        """set_emission_table(plHMM self, DoubleVectorVector emission_distribution)"""
        return _pypl.plHMM_set_emission_table(self, *args)

    def set_emission_distribution(self, *args):
        """set_emission_distribution(plHMM self, plCndDistribution emission_distribution, bool tabulate_emission_distribution)"""
        return _pypl.plHMM_set_emission_distribution(self, *args)

    def compute_dissimilarity_to(self, *args):
        """compute_dissimilarity_to(plHMM self, plHMM other, DoubleVectorVectorVector this_obs_sequences) -> plFloat"""
        return _pypl.plHMM_compute_dissimilarity_to(self, *args)

    def compute_symmetric_dissimilarity(self, *args):
        """compute_symmetric_dissimilarity(plHMM self, plHMM other, DoubleVectorVectorVector this_obs_sequences, DoubleVectorVectorVector other_obs_sequences) -> plFloat"""
        return _pypl.plHMM_compute_symmetric_dissimilarity(self, *args)

    def did_tabulate_transition_distribution(self):
        """did_tabulate_transition_distribution(plHMM self) -> bool"""
        return _pypl.plHMM_did_tabulate_transition_distribution(self)

    def did_tabulate_emission_distribution(self):
        """did_tabulate_emission_distribution(plHMM self) -> bool"""
        return _pypl.plHMM_did_tabulate_emission_distribution(self)

plHMM_swigregister = _pypl.plHMM_swigregister
plHMM_swigregister(plHMM)

class plConcurrentHmmSet(plBuiltinModel):
    """Proxy of C++ plConcurrentHmmSet class"""
    __swig_setmethods__ = {}
    for _s in [plBuiltinModel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plConcurrentHmmSet, name, value)
    __swig_getmethods__ = {}
    for _s in [plBuiltinModel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plConcurrentHmmSet, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(plConcurrentHmmSet self) -> plConcurrentHmmSet"""
        this = _pypl.new_plConcurrentHmmSet()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plConcurrentHmmSet
    __del__ = lambda self : None;
    def add_model(self, *args):
        """add_model(plConcurrentHmmSet self, plHMM model)"""
        return _pypl.plConcurrentHmmSet_add_model(self, *args)

    def remove_model(self, *args):
        """
        remove_model(plConcurrentHmmSet self, unsigned int index)
        remove_model(plConcurrentHmmSet self, std::string const & name)
        """
        return _pypl.plConcurrentHmmSet_remove_model(self, *args)

    def clear_models(self):
        """clear_models(plConcurrentHmmSet self)"""
        return _pypl.plConcurrentHmmSet_clear_models(self)

    def set_transition_matrices(self, *args):
        """
        set_transition_matrices(plConcurrentHmmSet self, DoubleVectorVector transition_matrix_final_states, DoubleVectorVector transition_matrix_non_final_states)
        set_transition_matrices(plConcurrentHmmSet self, unsigned int mp, unsigned int m, plProbValue final, plProbValue non_final)
        """
        return _pypl.plConcurrentHmmSet_set_transition_matrices(self, *args)

    def get_nmodels(self):
        """get_nmodels(plConcurrentHmmSet self) -> unsigned int"""
        return _pypl.plConcurrentHmmSet_get_nmodels(self)

    def get_best_model_most_probable_state_sequence(self, *args):
        """
        get_best_model_most_probable_state_sequence(plConcurrentHmmSet self, UnsignedIntVector state_sequence, DoubleVectorVector obs_seq, bool only_final_states=False) -> unsigned int
        get_best_model_most_probable_state_sequence(plConcurrentHmmSet self, UnsignedIntVector state_sequence, DoubleVectorVector obs_seq) -> unsigned int
        """
        return _pypl.plConcurrentHmmSet_get_best_model_most_probable_state_sequence(self, *args)

    def get_best_model_most_probable_state_sequence_by_name(self, *args):
        """
        get_best_model_most_probable_state_sequence_by_name(plConcurrentHmmSet self, UnsignedIntVector state_sequence, DoubleVectorVector obs_seq, bool only_final_states=False) -> std::string const
        get_best_model_most_probable_state_sequence_by_name(plConcurrentHmmSet self, UnsignedIntVector state_sequence, DoubleVectorVector obs_seq) -> std::string const &
        """
        return _pypl.plConcurrentHmmSet_get_best_model_most_probable_state_sequence_by_name(self, *args)

    def get_best_model(self, *args):
        """get_best_model(plConcurrentHmmSet self, DoubleVectorVector obs_seq) -> unsigned int"""
        return _pypl.plConcurrentHmmSet_get_best_model(self, *args)

    def get_best_model_name(self, *args):
        """get_best_model_name(plConcurrentHmmSet self, DoubleVectorVector obs_seq) -> std::string const &"""
        return _pypl.plConcurrentHmmSet_get_best_model_name(self, *args)

    def get_all_models_log_probabilities(self, *args):
        """get_all_models_log_probabilities(plConcurrentHmmSet self, DoubleVector models_log_probabilities, DoubleVectorVector observation_sequence) -> unsigned int"""
        return _pypl.plConcurrentHmmSet_get_all_models_log_probabilities(self, *args)

    def get_all_models_log_probabilities_name(self, *args):
        """get_all_models_log_probabilities_name(plConcurrentHmmSet self, DoubleVector models_log_probabilities, DoubleVectorVector observation_sequence) -> std::string const &"""
        return _pypl.plConcurrentHmmSet_get_all_models_log_probabilities_name(self, *args)

    def get_all_models_most_probable_state_sequences(self, *args):
        """
        get_all_models_most_probable_state_sequences(plConcurrentHmmSet self, DoubleVector observation_log_likelihoods, std::vector< plHMM::StateSequence_t,std::allocator< plHMM::StateSequence_t > > & state_sequences, 
            DoubleVectorVector observation_sequence)
        """
        return _pypl.plConcurrentHmmSet_get_all_models_most_probable_state_sequences(self, *args)

    def update_models_states_probabilities(self, *args):
        """update_models_states_probabilities(plConcurrentHmmSet self, DoubleVector observation) -> plFloat"""
        return _pypl.plConcurrentHmmSet_update_models_states_probabilities(self, *args)

    def get_model_probability(self, *args):
        """
        get_model_probability(plConcurrentHmmSet self, unsigned int n) -> plProbValue
        get_model_probability(plConcurrentHmmSet self, std::string const & name) -> plProbValue
        """
        return _pypl.plConcurrentHmmSet_get_model_probability(self, *args)

    def reset_models_state_distributions(self):
        """reset_models_state_distributions(plConcurrentHmmSet self)"""
        return _pypl.plConcurrentHmmSet_reset_models_state_distributions(self)

    def reset(self):
        """reset(plConcurrentHmmSet self)"""
        return _pypl.plConcurrentHmmSet_reset(self)

    def get_models_probabilities_log(self):
        """get_models_probabilities_log(plConcurrentHmmSet self) -> DoubleVector"""
        return _pypl.plConcurrentHmmSet_get_models_probabilities_log(self)

    def get_models_probabilities(self, *args):
        """get_models_probabilities(plConcurrentHmmSet self, DoubleVector models_probabilities)"""
        return _pypl.plConcurrentHmmSet_get_models_probabilities(self, *args)

    def set_models_probabilities(self, *args):
        """set_models_probabilities(plConcurrentHmmSet self, DoubleVector models_probabilities)"""
        return _pypl.plConcurrentHmmSet_set_models_probabilities(self, *args)

    def set_init_models_probabilities(self, *args):
        """set_init_models_probabilities(plConcurrentHmmSet self, DoubleVector init_models_probabilities)"""
        return _pypl.plConcurrentHmmSet_set_init_models_probabilities(self, *args)

    def set_models_prior(self, *args):
        """set_models_prior(plConcurrentHmmSet self, DoubleVector models_probabilities)"""
        return _pypl.plConcurrentHmmSet_set_models_prior(self, *args)

    def get_transition_matrices(self, *args):
        """get_transition_matrices(plConcurrentHmmSet self, DoubleVectorVector transition_matrix_final_states, DoubleVectorVector transition_matrix_non_final_states)"""
        return _pypl.plConcurrentHmmSet_get_transition_matrices(self, *args)

    def get_model(self, *args):
        """
        get_model(plConcurrentHmmSet self, unsigned int n) -> plHMM
        get_model(plConcurrentHmmSet self, std::string const & name) -> plHMM
        get_model(plConcurrentHmmSet self, unsigned int n) -> plHMM
        get_model(plConcurrentHmmSet self, std::string const & name) -> plHMM
        """
        return _pypl.plConcurrentHmmSet_get_model(self, *args)

    def predict_models_states_probabilities(self):
        """predict_models_states_probabilities(plConcurrentHmmSet self)"""
        return _pypl.plConcurrentHmmSet_predict_models_states_probabilities(self)

    def compute_dissimilarity_matrix(self, *args):
        """compute_dissimilarity_matrix(plConcurrentHmmSet self, DoubleVectorVector dissimilarity_matrix, std::vector< std::vector< plHMM::ObservationSequence_t,std::allocator< plHMM::ObservationSequence_t > >,std::allocator< std::vector< plHMM::ObservationSequence_t,std::allocator< plHMM::ObservationSequence_t > > > > const & obs_sequences)"""
        return _pypl.plConcurrentHmmSet_compute_dissimilarity_matrix(self, *args)

    def compute_symmetric_dissimilarity_matrix(self, *args):
        """compute_symmetric_dissimilarity_matrix(plConcurrentHmmSet self, DoubleVectorVector symmetric_dissimilarity_matrix, std::vector< std::vector< plHMM::ObservationSequence_t,std::allocator< plHMM::ObservationSequence_t > >,std::allocator< std::vector< plHMM::ObservationSequence_t,std::allocator< plHMM::ObservationSequence_t > > > > const & obs_sequences)"""
        return _pypl.plConcurrentHmmSet_compute_symmetric_dissimilarity_matrix(self, *args)

    def is_in_final_state(self, *args):
        """is_in_final_state(plConcurrentHmmSet self, unsigned int n, plProbValue prob) -> bool"""
        return _pypl.plConcurrentHmmSet_is_in_final_state(self, *args)

    def get_init_models_probabilities(self):
        """get_init_models_probabilities(plConcurrentHmmSet self) -> DoubleVector"""
        return _pypl.plConcurrentHmmSet_get_init_models_probabilities(self)

plConcurrentHmmSet_swigregister = _pypl.plConcurrentHmmSet_swigregister
plConcurrentHmmSet_swigregister(plConcurrentHmmSet)

class plDataDescriptor(plObject):
    """Proxy of C++ plDataDescriptor class"""
    __swig_setmethods__ = {}
    for _s in [plObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plDataDescriptor, name, value)
    __swig_getmethods__ = {}
    for _s in [plObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plDataDescriptor, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def is_ok(self):
        """is_ok(plDataDescriptor self) -> bool"""
        return _pypl.plDataDescriptor_is_ok(self)

    __swig_destroy__ = _pypl.delete_plDataDescriptor
    __del__ = lambda self : None;
    def get_num_fields(self):
        """get_num_fields(plDataDescriptor self) -> unsigned int"""
        return _pypl.plDataDescriptor_get_num_fields(self)

    def rewind(self):
        """rewind(plDataDescriptor self)"""
        return _pypl.plDataDescriptor_rewind(self)

    def get_data_record(self, *args):
        """get_data_record(plDataDescriptor self, plValues const *& data_values, std::vector< bool,std::allocator< bool > > const *& data_definition) -> bool"""
        return _pypl.plDataDescriptor_get_data_record(self, *args)

    def get_data_record_value(self, *args):
        """get_data_record_value(plDataDescriptor self, plValues data_values, BoolVector data_definition) -> bool"""
        return _pypl.plDataDescriptor_get_data_record_value(self, *args)

    def get_next_defined_values(self, *args):
        """get_next_defined_values(plDataDescriptor self, plValues data_values) -> bool"""
        return _pypl.plDataDescriptor_get_next_defined_values(self, *args)

    def get_data_range(self, *args):
        """get_data_range(plDataDescriptor self, DoubleVector min_vals, DoubleVector max_vals)"""
        return _pypl.plDataDescriptor_get_data_range(self, *args)

    def get_simple_stats(self, *args):
        """
        get_simple_stats(plDataDescriptor self, DoubleVector min_vals, DoubleVector max_vals, DoubleVector mean_vals, DoubleVector stdev_vals, 
            UnsignedIntVector n, unsigned int & ncomplete_rows) -> unsigned int
        """
        return _pypl.plDataDescriptor_get_simple_stats(self, *args)

    def validate(self, *args):
        """validate(plDataDescriptor self, UnsignedIntVector erroneous_lines) -> bool"""
        return _pypl.plDataDescriptor_validate(self, *args)

    def get_n_records(self):
        """get_n_records(plDataDescriptor self) -> unsigned int"""
        return _pypl.plDataDescriptor_get_n_records(self)

    def observed_variables(self):
        """observed_variables(plDataDescriptor self) -> plVariablesConjunction"""
        return _pypl.plDataDescriptor_observed_variables(self)

    def print_head(self, *args):
        """
        print_head(plDataDescriptor self, unsigned int n=20, char sep='\t') -> std::ostream
        print_head(plDataDescriptor self, unsigned int n=20) -> std::ostream
        print_head(plDataDescriptor self, unsigned int n=20) -> std::ostream
        print_head(plDataDescriptor self) -> std::ostream
        print_head(plDataDescriptor self, std::string const & file, unsigned int n=20, char sep='\t')
        print_head(plDataDescriptor self, std::string const & file, unsigned int n=20)
        print_head(plDataDescriptor self, std::string const & file)
        """
        return _pypl.plDataDescriptor_print_head(self, *args)

    def print_simple_stats(self, *args):
        """
        print_simple_stats(plDataDescriptor self, char sep='\t') -> std::ostream
        print_simple_stats(plDataDescriptor self) -> std::ostream
        print_simple_stats(plDataDescriptor self) -> std::ostream
        print_simple_stats(plDataDescriptor self, std::string const & file, char sep='\t')
        print_simple_stats(plDataDescriptor self, std::string const & file)
        """
        return _pypl.plDataDescriptor_print_simple_stats(self, *args)

    def use_for_discretization(self, *args):
        """
        use_for_discretization(plDataDescriptor self, std::vector< plVariableDiscretizer *,std::allocator< plVariableDiscretizer * > > const & discretizers, 
            std::vector< size_t,std::allocator< size_t > > const & variable_columns) -> DoubleVectorVector
        use_for_discretization(plDataDescriptor self, plVariableDiscretizer * discretizer, size_t variable_column) -> DoubleVector
        """
        return _pypl.plDataDescriptor_use_for_discretization(self, *args)

plDataDescriptor_swigregister = _pypl.plDataDescriptor_swigregister
plDataDescriptor_swigregister(plDataDescriptor)

class plStringDataDescriptor(_object):
    """Proxy of C++ plStringDataDescriptor class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plStringDataDescriptor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plStringDataDescriptor, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plStringDataDescriptor
    __del__ = lambda self : None;
    def get_data_record(self, *args):
        """get_data_record(plStringDataDescriptor self, StringVector data_values) -> bool"""
        return _pypl.plStringDataDescriptor_get_data_record(self, *args)

    def guess_variables(self, *args):
        """
        guess_variables(plStringDataDescriptor self, bool header, int real_discretization=-1) -> plVariablesConjunction
        guess_variables(plStringDataDescriptor self, bool header) -> plVariablesConjunction
        """
        return _pypl.plStringDataDescriptor_guess_variables(self, *args)

plStringDataDescriptor_swigregister = _pypl.plStringDataDescriptor_swigregister
plStringDataDescriptor_swigregister(plStringDataDescriptor)

class plCSVDataDescriptor(plDataDescriptor,plStringDataDescriptor):
    """Proxy of C++ plCSVDataDescriptor class"""
    __swig_setmethods__ = {}
    for _s in [plDataDescriptor,plStringDataDescriptor]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCSVDataDescriptor, name, value)
    __swig_getmethods__ = {}
    for _s in [plDataDescriptor,plStringDataDescriptor]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCSVDataDescriptor, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCSVDataDescriptor self, std::string const & file, plVariablesConjunction variables=plVariablesConjunction(), 
            bool cache_data=True, bool header_specifies_variables=True) -> plCSVDataDescriptor
        __init__(plCSVDataDescriptor self, std::string const & file, plVariablesConjunction variables=plVariablesConjunction(), 
            bool cache_data=True) -> plCSVDataDescriptor
        __init__(plCSVDataDescriptor self, std::string const & file, plVariablesConjunction variables=plVariablesConjunction()) -> plCSVDataDescriptor
        __init__(plCSVDataDescriptor self, std::string const & file) -> plCSVDataDescriptor
        """
        this = _pypl.new_plCSVDataDescriptor(*args)
        try: self.this.append(this)
        except: self.this = this
    def set_field_separators(self, *args):
        """set_field_separators(plCSVDataDescriptor self, std::string const & field_separators)"""
        return _pypl.plCSVDataDescriptor_set_field_separators(self, *args)

    def set_quotes(self, *args):
        """set_quotes(plCSVDataDescriptor self, std::string const & quotes)"""
        return _pypl.plCSVDataDescriptor_set_quotes(self, *args)

    def set_undefined_field(self, *args):
        """set_undefined_field(plCSVDataDescriptor self, std::string const & undefined_field)"""
        return _pypl.plCSVDataDescriptor_set_undefined_field(self, *args)

    def ignore_unknown_variables(self, ignore=True):
        """
        ignore_unknown_variables(plCSVDataDescriptor self, bool ignore=True)
        ignore_unknown_variables(plCSVDataDescriptor self)
        """
        return _pypl.plCSVDataDescriptor_ignore_unknown_variables(self, ignore)

    __swig_destroy__ = _pypl.delete_plCSVDataDescriptor
    __del__ = lambda self : None;
    def get_num_fields(self):
        """get_num_fields(plCSVDataDescriptor self) -> unsigned int"""
        return _pypl.plCSVDataDescriptor_get_num_fields(self)

    def observed_variables(self):
        """observed_variables(plCSVDataDescriptor self) -> plVariablesConjunction"""
        return _pypl.plCSVDataDescriptor_observed_variables(self)

    def get_data_record(self, *args):
        """
        get_data_record(plCSVDataDescriptor self, plValues const *& data_values, std::vector< bool,std::allocator< bool > > const *& data_definition) -> bool
        get_data_record(plCSVDataDescriptor self, StringVector data_values) -> bool
        """
        return _pypl.plCSVDataDescriptor_get_data_record(self, *args)

    def rewind(self):
        """rewind(plCSVDataDescriptor self)"""
        return _pypl.plCSVDataDescriptor_rewind(self)

    def guess_variables(*args):
        """
        guess_variables(bool header, int real_discretization=-1) -> plVariablesConjunction
        guess_variables(bool header) -> plVariablesConjunction
        guess_variables(std::string const & csv_file, bool header=True, int real_discretization=-1) -> plVariablesConjunction
        guess_variables(std::string const & csv_file, bool header=True) -> plVariablesConjunction
        guess_variables(std::string const & csv_file) -> plVariablesConjunction
        """
        return _pypl.plCSVDataDescriptor_guess_variables(*args)

    if _newclass:guess_variables = staticmethod(guess_variables)
    __swig_getmethods__["guess_variables"] = lambda x: guess_variables
plCSVDataDescriptor_swigregister = _pypl.plCSVDataDescriptor_swigregister
plCSVDataDescriptor_swigregister(plCSVDataDescriptor)

def plCSVDataDescriptor_stream(*args):
    """
    plCSVDataDescriptor_stream(std::istream & input_stream, plVariablesConjunction variables, bool cache_data=True, 
        bool header_specifies_variables=True) -> plCSVDataDescriptor
    plCSVDataDescriptor_stream(std::istream & input_stream, plVariablesConjunction variables, bool cache_data=True) -> plCSVDataDescriptor
    plCSVDataDescriptor_stream(std::istream & input_stream, plVariablesConjunction variables) -> plCSVDataDescriptor
    """
    val = _pypl.new_plCSVDataDescriptor_stream(*args)
    return val

def plCSVDataDescriptor_guess_variables(*args):
  """
    guess_variables(bool header, int real_discretization=-1) -> plVariablesConjunction
    guess_variables(bool header) -> plVariablesConjunction
    guess_variables(std::string const & csv_file, bool header=True, int real_discretization=-1) -> plVariablesConjunction
    guess_variables(std::string const & csv_file, bool header=True) -> plVariablesConjunction
    plCSVDataDescriptor_guess_variables(std::string const & csv_file) -> plVariablesConjunction
    """
  return _pypl.plCSVDataDescriptor_guess_variables(*args)

class plCSVFileDataDescriptor(plDataDescriptor):
    """Proxy of C++ plCSVFileDataDescriptor class"""
    __swig_setmethods__ = {}
    for _s in [plDataDescriptor]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCSVFileDataDescriptor, name, value)
    __swig_getmethods__ = {}
    for _s in [plDataDescriptor]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCSVFileDataDescriptor, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCSVFileDataDescriptor self, std::string const & file_name, plVariablesConjunction variables, bool cache_data=True, 
            char field_delimiter=';', char line_delimiter='\n', std::string const & undefined_field="", 
            char quote='\"') -> plCSVFileDataDescriptor
        __init__(plCSVFileDataDescriptor self, std::string const & file_name, plVariablesConjunction variables, bool cache_data=True, 
            char field_delimiter=';', char line_delimiter='\n', std::string const & undefined_field="") -> plCSVFileDataDescriptor
        __init__(plCSVFileDataDescriptor self, std::string const & file_name, plVariablesConjunction variables, bool cache_data=True, 
            char field_delimiter=';', char line_delimiter='\n') -> plCSVFileDataDescriptor
        __init__(plCSVFileDataDescriptor self, std::string const & file_name, plVariablesConjunction variables, bool cache_data=True, 
            char field_delimiter=';') -> plCSVFileDataDescriptor
        __init__(plCSVFileDataDescriptor self, std::string const & file_name, plVariablesConjunction variables, bool cache_data=True) -> plCSVFileDataDescriptor
        __init__(plCSVFileDataDescriptor self, std::string const & file_name, plVariablesConjunction variables) -> plCSVFileDataDescriptor
        __init__(plCSVFileDataDescriptor self, std::string const & file_name, unsigned int num_fields=0, bool cache_data=True, unsigned int ignore_lines=0, 
            char field_delimiter=';', char line_delimiter='\n', 
            std::string const & undefined_field="", UnsignedIntVector columns_to_ignore=std::vector< unsigned int >(), 
            char quote='\"') -> plCSVFileDataDescriptor
        __init__(plCSVFileDataDescriptor self, std::string const & file_name, unsigned int num_fields=0, bool cache_data=True, unsigned int ignore_lines=0, 
            char field_delimiter=';', char line_delimiter='\n', 
            std::string const & undefined_field="", UnsignedIntVector columns_to_ignore=std::vector< unsigned int >()) -> plCSVFileDataDescriptor
        __init__(plCSVFileDataDescriptor self, std::string const & file_name, unsigned int num_fields=0, bool cache_data=True, unsigned int ignore_lines=0, 
            char field_delimiter=';', char line_delimiter='\n', 
            std::string const & undefined_field="") -> plCSVFileDataDescriptor
        __init__(plCSVFileDataDescriptor self, std::string const & file_name, unsigned int num_fields=0, bool cache_data=True, unsigned int ignore_lines=0, 
            char field_delimiter=';', char line_delimiter='\n') -> plCSVFileDataDescriptor
        __init__(plCSVFileDataDescriptor self, std::string const & file_name, unsigned int num_fields=0, bool cache_data=True, unsigned int ignore_lines=0, 
            char field_delimiter=';') -> plCSVFileDataDescriptor
        __init__(plCSVFileDataDescriptor self, std::string const & file_name, unsigned int num_fields=0, bool cache_data=True, unsigned int ignore_lines=0) -> plCSVFileDataDescriptor
        __init__(plCSVFileDataDescriptor self, std::string const & file_name, unsigned int num_fields=0, bool cache_data=True) -> plCSVFileDataDescriptor
        __init__(plCSVFileDataDescriptor self, std::string const & file_name, unsigned int num_fields=0) -> plCSVFileDataDescriptor
        __init__(plCSVFileDataDescriptor self, std::string const & file_name) -> plCSVFileDataDescriptor
        __init__(plCSVFileDataDescriptor self, std::string const & file_name, unsigned int num_fields, bool cache_data, unsigned int ignore_lines, 
            char field_delimiter, char line_delimiter, unsigned int max_line_length, 
            std::string const & undefined_field="", UnsignedIntVector columns_to_ignore=std::vector< unsigned int >()) -> plCSVFileDataDescriptor
        __init__(plCSVFileDataDescriptor self, std::string const & file_name, unsigned int num_fields, bool cache_data, unsigned int ignore_lines, 
            char field_delimiter, char line_delimiter, unsigned int max_line_length, 
            std::string const & undefined_field="") -> plCSVFileDataDescriptor
        __init__(plCSVFileDataDescriptor self, std::string const & file_name, unsigned int num_fields, bool cache_data, unsigned int ignore_lines, 
            char field_delimiter, char line_delimiter, unsigned int max_line_length) -> plCSVFileDataDescriptor
        """
        this = _pypl.new_plCSVFileDataDescriptor(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plCSVFileDataDescriptor
    __del__ = lambda self : None;
    def rewind(self):
        """rewind(plCSVFileDataDescriptor self)"""
        return _pypl.plCSVFileDataDescriptor_rewind(self)

    def get_data_record(self, *args):
        """
        get_data_record(plCSVFileDataDescriptor self, StringVector records) -> bool
        get_data_record(plCSVFileDataDescriptor self, plValues const *& data_values, std::vector< bool,std::allocator< bool > > const *& data_definition) -> bool
        """
        return _pypl.plCSVFileDataDescriptor_get_data_record(self, *args)

    def get_num_fields(self):
        """get_num_fields(plCSVFileDataDescriptor self) -> unsigned int"""
        return _pypl.plCSVFileDataDescriptor_get_num_fields(self)

    def get_n_records(self):
        """get_n_records(plCSVFileDataDescriptor self) -> unsigned int"""
        return _pypl.plCSVFileDataDescriptor_get_n_records(self)

    def set_variables(self, *args):
        """set_variables(plCSVFileDataDescriptor self, plVariablesConjunction variables)"""
        return _pypl.plCSVFileDataDescriptor_set_variables(self, *args)

    def observed_variables(self):
        """observed_variables(plCSVFileDataDescriptor self) -> plVariablesConjunction"""
        return _pypl.plCSVFileDataDescriptor_observed_variables(self)

    def set_field_delimiter(self, *args):
        """set_field_delimiter(plCSVFileDataDescriptor self, char field_delimiter)"""
        return _pypl.plCSVFileDataDescriptor_set_field_delimiter(self, *args)

    def set_line_delimiter(self, *args):
        """set_line_delimiter(plCSVFileDataDescriptor self, char line_delimiter)"""
        return _pypl.plCSVFileDataDescriptor_set_line_delimiter(self, *args)

    def set_undefined_field(self, *args):
        """set_undefined_field(plCSVFileDataDescriptor self, std::string const & undefined_field)"""
        return _pypl.plCSVFileDataDescriptor_set_undefined_field(self, *args)

    def set_quote(self, *args):
        """set_quote(plCSVFileDataDescriptor self, char quote)"""
        return _pypl.plCSVFileDataDescriptor_set_quote(self, *args)

    def set_columns_to_ignore(self, *args):
        """set_columns_to_ignore(plCSVFileDataDescriptor self, UnsignedIntVector columns_to_ignore)"""
        return _pypl.plCSVFileDataDescriptor_set_columns_to_ignore(self, *args)

    def set_ignore_lines(self, *args):
        """set_ignore_lines(plCSVFileDataDescriptor self, unsigned int n)"""
        return _pypl.plCSVFileDataDescriptor_set_ignore_lines(self, *args)

    def set_cache_data(self, *args):
        """set_cache_data(plCSVFileDataDescriptor self, bool cache_it)"""
        return _pypl.plCSVFileDataDescriptor_set_cache_data(self, *args)

    def set_num_fields(self, *args):
        """set_num_fields(plCSVFileDataDescriptor self, unsigned int num_fields)"""
        return _pypl.plCSVFileDataDescriptor_set_num_fields(self, *args)

    def generate_gnuplot(self, *args):
        """
        generate_gnuplot(plCSVFileDataDescriptor self, std::string const & gnuplot_file, std::string const & title, unsigned int time_stamp_column=0, 
            std::string const time_stamp_format="%m/%d/%Y:%H:%M:%S", plPlotType plottype=PL_DEFAULT_PLOT, 
            bool plot_points=False)
        generate_gnuplot(plCSVFileDataDescriptor self, std::string const & gnuplot_file, std::string const & title, unsigned int time_stamp_column=0, 
            std::string const time_stamp_format="%m/%d/%Y:%H:%M:%S", plPlotType plottype=PL_DEFAULT_PLOT)
        generate_gnuplot(plCSVFileDataDescriptor self, std::string const & gnuplot_file, std::string const & title, unsigned int time_stamp_column=0, 
            std::string const time_stamp_format="%m/%d/%Y:%H:%M:%S")
        generate_gnuplot(plCSVFileDataDescriptor self, std::string const & gnuplot_file, std::string const & title, unsigned int time_stamp_column=0)
        generate_gnuplot(plCSVFileDataDescriptor self, std::string const & gnuplot_file, std::string const & title)
        """
        return _pypl.plCSVFileDataDescriptor_generate_gnuplot(self, *args)

plCSVFileDataDescriptor_swigregister = _pypl.plCSVFileDataDescriptor_swigregister
plCSVFileDataDescriptor_swigregister(plCSVFileDataDescriptor)

class plNumPyDataDescriptor(plDataDescriptor):
    """Proxy of C++ plNumPyDataDescriptor class"""
    __swig_setmethods__ = {}
    for _s in [plDataDescriptor]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plNumPyDataDescriptor, name, value)
    __swig_getmethods__ = {}
    for _s in [plDataDescriptor]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plNumPyDataDescriptor, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plNumPyDataDescriptor self, PyObject * array, plVariablesConjunction variables, bool use_data_cache=False) -> plNumPyDataDescriptor
        __init__(plNumPyDataDescriptor self, PyObject * array, plVariablesConjunction variables) -> plNumPyDataDescriptor
        """
        this = _pypl.new_plNumPyDataDescriptor(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plNumPyDataDescriptor
    __del__ = lambda self : None;
    def get_num_fields(self):
        """get_num_fields(plNumPyDataDescriptor self) -> unsigned int"""
        return _pypl.plNumPyDataDescriptor_get_num_fields(self)

    def observed_variables(self):
        """observed_variables(plNumPyDataDescriptor self) -> plVariablesConjunction"""
        return _pypl.plNumPyDataDescriptor_observed_variables(self)

    def get_data_record(self, *args):
        """get_data_record(plNumPyDataDescriptor self, plValues const *& data_values, std::vector< bool,std::allocator< bool > > const *& data_definition) -> bool"""
        return _pypl.plNumPyDataDescriptor_get_data_record(self, *args)

    def rewind(self):
        """rewind(plNumPyDataDescriptor self)"""
        return _pypl.plNumPyDataDescriptor_rewind(self)

plNumPyDataDescriptor_swigregister = _pypl.plNumPyDataDescriptor_swigregister
plNumPyDataDescriptor_swigregister(plNumPyDataDescriptor)

class plLearner(plObject):
    """Proxy of C++ plLearner class"""
    __swig_setmethods__ = {}
    for _s in [plObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearner, name, value)
    __swig_getmethods__ = {}
    for _s in [plObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLearner, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def learn_model_parameters(*args):
        """
        learn_model_parameters(plLearnObjectVector learn_objects, plDataDescriptor data_descriptor) -> plJointDistribution
        learn_model_parameters(plLearnObjectVector learn_objects, plComputableObjectList init_distribs, plDataDescriptor data_descriptor) -> plJointDistribution
        """
        return _pypl.plLearner_learn_model_parameters(*args)

    if _newclass:learn_model_parameters = staticmethod(learn_model_parameters)
    __swig_getmethods__["learn_model_parameters"] = lambda x: learn_model_parameters
    __swig_destroy__ = _pypl.delete_plLearner
    __del__ = lambda self : None;
plLearner_swigregister = _pypl.plLearner_swigregister
plLearner_swigregister(plLearner)

def plLearner_learn_model_parameters(*args):
  """
    learn_model_parameters(plLearnObjectVector learn_objects, plDataDescriptor data_descriptor) -> plJointDistribution
    plLearner_learn_model_parameters(plLearnObjectVector learn_objects, plComputableObjectList init_distribs, plDataDescriptor data_descriptor) -> plJointDistribution
    """
  return _pypl.plLearner_learn_model_parameters(*args)

class plLearnObject(plLearner):
    """Proxy of C++ plLearnObject class"""
    __swig_setmethods__ = {}
    for _s in [plLearner]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearnObject, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearner]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLearnObject, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plLearnObject
    __del__ = lambda self : None;
    def get_nsamples(self, *args):
        """
        get_nsamples(plLearnObject self) -> unsigned int
        get_nsamples(plLearnObject self, UnsignedIntVector n)
        """
        return _pypl.plLearnObject_get_nsamples(self, *args)

    def get_total_weight(self, *args):
        """
        get_total_weight(plLearnObject self) -> plFloat
        get_total_weight(plLearnObject self, DoubleVector w)
        """
        return _pypl.plLearnObject_get_total_weight(self, *args)

    def reset(self):
        """reset(plLearnObject self)"""
        return _pypl.plLearnObject_reset(self)

    def get_computable_object(self):
        """get_computable_object(plLearnObject self) -> plComputableObject"""
        return _pypl.plLearnObject_get_computable_object(self)

    def add_point(self, *args):
        """
        add_point(plLearnObject self, plValues point, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, plValues point) -> bool
        add_point(plLearnObject self, int const * point, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, int const * point) -> bool
        add_point(plLearnObject self, unsigned int const * point, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, unsigned int const * point) -> bool
        add_point(plLearnObject self, float const * point, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, float const * point) -> bool
        add_point(plLearnObject self, double const * point, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, double const * point) -> bool
        add_point(plLearnObject self, long double const * point, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, long double const * point) -> bool
        add_point(plLearnObject self, IntVector point, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, IntVector point) -> bool
        add_point(plLearnObject self, UnsignedIntVector point, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, UnsignedIntVector point) -> bool
        add_point(plLearnObject self, DoubleVector point, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, DoubleVector point) -> bool
        add_point(plLearnObject self, FloatVector point, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, FloatVector point) -> bool
        add_point(plLearnObject self, LongDoubleVector point, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, LongDoubleVector point) -> bool
        add_point(plLearnObject self, int point, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, int point) -> bool
        add_point(plLearnObject self, unsigned int point, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, unsigned int point) -> bool
        add_point(plLearnObject self, double point, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, double point) -> bool
        add_point(plLearnObject self, float point, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, float point) -> bool
        add_point(plLearnObject self, long double point, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, long double point) -> bool
        add_point(plLearnObject self, plValues point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, plValues point, BoolVector is_defined) -> bool
        add_point(plLearnObject self, int const * point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, int const * point, BoolVector is_defined) -> bool
        add_point(plLearnObject self, unsigned int const * point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, unsigned int const * point, BoolVector is_defined) -> bool
        add_point(plLearnObject self, double const * point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, double const * point, BoolVector is_defined) -> bool
        add_point(plLearnObject self, float const * point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, float const * point, BoolVector is_defined) -> bool
        add_point(plLearnObject self, long double const * point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, long double const * point, BoolVector is_defined) -> bool
        add_point(plLearnObject self, IntVector point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, IntVector point, BoolVector is_defined) -> bool
        add_point(plLearnObject self, UnsignedIntVector point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, UnsignedIntVector point, BoolVector is_defined) -> bool
        add_point(plLearnObject self, DoubleVector point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, DoubleVector point, BoolVector is_defined) -> bool
        add_point(plLearnObject self, FloatVector point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, FloatVector point, BoolVector is_defined) -> bool
        add_point(plLearnObject self, LongDoubleVector point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnObject self, LongDoubleVector point, BoolVector is_defined) -> bool
        """
        return _pypl.plLearnObject_add_point(self, *args)

    def learn_dynamic(self, *args):
        """
        learn_dynamic(plLearnObject self, plDataDescriptor data_descriptor, std::vector< std::pair< plSymbol,plSymbol >,std::allocator< std::pair< plSymbol,plSymbol > > > const & ts_edges, 
            unsigned int n=std::numeric_limits< unsigned int >::max()) -> int
        learn_dynamic(plLearnObject self, plDataDescriptor data_descriptor, std::vector< std::pair< plSymbol,plSymbol >,std::allocator< std::pair< plSymbol,plSymbol > > > const & ts_edges) -> int
        """
        return _pypl.plLearnObject_learn_dynamic(self, *args)

    def learn(self, *args):
        """
        learn(plLearnObject self, plDataDescriptor data_descriptor, unsigned int n=std::numeric_limits< unsigned int >::max()) -> int
        learn(plLearnObject self, plDataDescriptor data_descriptor) -> int
        learn(plLearnObject self, plDataDescriptor data_descriptor, plVariablesConjunction variables, bool rewind_before_use=True) -> int
        learn(plLearnObject self, plDataDescriptor data_descriptor, plVariablesConjunction variables) -> int
        learn(plLearnObject self, IntVector vals)
        learn(plLearnObject self, UnsignedIntVector vals)
        learn(plLearnObject self, DoubleVector vals)
        learn(plLearnObject self, FloatVector vals)
        learn(plLearnObject self, LongDoubleVector vals)
        learn(plLearnObject self, IntVector vals, BoolVector _def)
        learn(plLearnObject self, UnsignedIntVector vals, BoolVector _def)
        learn(plLearnObject self, DoubleVector vals, BoolVector _def)
        learn(plLearnObject self, FloatVector vals, BoolVector _def)
        learn(plLearnObject self, LongDoubleVector vals, BoolVector _def)
        """
        return _pypl.plLearnObject_learn(self, *args)

    def get_left_variables(self):
        """get_left_variables(plLearnObject self) -> plVariablesConjunction"""
        return _pypl.plLearnObject_get_left_variables(self)

    def get_right_variables(self):
        """get_right_variables(plLearnObject self) -> plVariablesConjunction"""
        return _pypl.plLearnObject_get_right_variables(self)

    def get_variables(self):
        """get_variables(plLearnObject self) -> plVariablesConjunction"""
        return _pypl.plLearnObject_get_variables(self)

    def get_n_parameters(self):
        """get_n_parameters(plLearnObject self) -> unsigned int"""
        return _pypl.plLearnObject_get_n_parameters(self)

    def clone(self):
        """clone(plLearnObject self) -> plLearnObject"""
        return _pypl.plLearnObject_clone(self)

plLearnObject_swigregister = _pypl.plLearnObject_swigregister
plLearnObject_swigregister(plLearnObject)

class plLearnFrozenDistribution(plLearnObject):
    """Proxy of C++ plLearnFrozenDistribution class"""
    __swig_setmethods__ = {}
    for _s in [plLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearnFrozenDistribution, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLearnFrozenDistribution, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plLearnFrozenDistribution self) -> plLearnFrozenDistribution
        __init__(plLearnFrozenDistribution self, plComputableObject frozen_computable_object) -> plLearnFrozenDistribution
        """
        this = _pypl.new_plLearnFrozenDistribution(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_left_variables(self):
        """get_left_variables(plLearnFrozenDistribution self) -> plVariablesConjunction"""
        return _pypl.plLearnFrozenDistribution_get_left_variables(self)

    def get_right_variables(self):
        """get_right_variables(plLearnFrozenDistribution self) -> plVariablesConjunction"""
        return _pypl.plLearnFrozenDistribution_get_right_variables(self)

    def get_computable_object(self):
        """get_computable_object(plLearnFrozenDistribution self) -> plComputableObject"""
        return _pypl.plLearnFrozenDistribution_get_computable_object(self)

    def get_n_parameters(self):
        """get_n_parameters(plLearnFrozenDistribution self) -> unsigned int"""
        return _pypl.plLearnFrozenDistribution_get_n_parameters(self)

    def clone(self):
        """clone(plLearnFrozenDistribution self) -> plLearnObject"""
        return _pypl.plLearnFrozenDistribution_clone(self)

    __swig_destroy__ = _pypl.delete_plLearnFrozenDistribution
    __del__ = lambda self : None;
plLearnFrozenDistribution_swigregister = _pypl.plLearnFrozenDistribution_swigregister
plLearnFrozenDistribution_swigregister(plLearnFrozenDistribution)

class plLearnObjectVector(_object):
    """Proxy of C++ std::vector<(p.plLearnObject)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearnObjectVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plLearnObjectVector, name)
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(plLearnObjectVector self) -> SwigPyIterator"""
        return _pypl.plLearnObjectVector_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(plLearnObjectVector self) -> bool"""
        return _pypl.plLearnObjectVector___nonzero__(self)

    def __bool__(self):
        """__bool__(plLearnObjectVector self) -> bool"""
        return _pypl.plLearnObjectVector___bool__(self)

    def __len__(self):
        """__len__(plLearnObjectVector self) -> std::vector< plLearnObject * >::size_type"""
        return _pypl.plLearnObjectVector___len__(self)

    def pop(self):
        """pop(plLearnObjectVector self) -> plLearnObject"""
        return _pypl.plLearnObjectVector_pop(self)

    def __getslice__(self, *args):
        """__getslice__(plLearnObjectVector self, std::vector< plLearnObject * >::difference_type i, std::vector< plLearnObject * >::difference_type j) -> plLearnObjectVector"""
        return _pypl.plLearnObjectVector___getslice__(self, *args)

    def __setslice__(self, *args):
        """
        __setslice__(plLearnObjectVector self, std::vector< plLearnObject * >::difference_type i, std::vector< plLearnObject * >::difference_type j, 
            plLearnObjectVector v=std::vector< plLearnObject *,std::allocator< plLearnObject * > >())
        __setslice__(plLearnObjectVector self, std::vector< plLearnObject * >::difference_type i, std::vector< plLearnObject * >::difference_type j)
        """
        return _pypl.plLearnObjectVector___setslice__(self, *args)

    def __delslice__(self, *args):
        """__delslice__(plLearnObjectVector self, std::vector< plLearnObject * >::difference_type i, std::vector< plLearnObject * >::difference_type j)"""
        return _pypl.plLearnObjectVector___delslice__(self, *args)

    def __delitem__(self, *args):
        """
        __delitem__(plLearnObjectVector self, std::vector< plLearnObject * >::difference_type i)
        __delitem__(plLearnObjectVector self, PySliceObject * slice)
        """
        return _pypl.plLearnObjectVector___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(plLearnObjectVector self, PySliceObject * slice) -> plLearnObjectVector
        __getitem__(plLearnObjectVector self, std::vector< plLearnObject * >::difference_type i) -> plLearnObject
        """
        return _pypl.plLearnObjectVector___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(plLearnObjectVector self, PySliceObject * slice, plLearnObjectVector v)
        __setitem__(plLearnObjectVector self, PySliceObject * slice)
        __setitem__(plLearnObjectVector self, std::vector< plLearnObject * >::difference_type i, plLearnObject x)
        """
        return _pypl.plLearnObjectVector___setitem__(self, *args)

    def append(self, *args):
        """append(plLearnObjectVector self, plLearnObject x)"""
        return _pypl.plLearnObjectVector_append(self, *args)

    def empty(self):
        """empty(plLearnObjectVector self) -> bool"""
        return _pypl.plLearnObjectVector_empty(self)

    def size(self):
        """size(plLearnObjectVector self) -> std::vector< plLearnObject * >::size_type"""
        return _pypl.plLearnObjectVector_size(self)

    def clear(self):
        """clear(plLearnObjectVector self)"""
        return _pypl.plLearnObjectVector_clear(self)

    def swap(self, *args):
        """swap(plLearnObjectVector self, plLearnObjectVector v)"""
        return _pypl.plLearnObjectVector_swap(self, *args)

    def get_allocator(self):
        """get_allocator(plLearnObjectVector self) -> std::vector< plLearnObject * >::allocator_type"""
        return _pypl.plLearnObjectVector_get_allocator(self)

    def begin(self):
        """begin(plLearnObjectVector self) -> std::vector< plLearnObject * >::iterator"""
        return _pypl.plLearnObjectVector_begin(self)

    def end(self):
        """end(plLearnObjectVector self) -> std::vector< plLearnObject * >::iterator"""
        return _pypl.plLearnObjectVector_end(self)

    def rbegin(self):
        """rbegin(plLearnObjectVector self) -> std::vector< plLearnObject * >::reverse_iterator"""
        return _pypl.plLearnObjectVector_rbegin(self)

    def rend(self):
        """rend(plLearnObjectVector self) -> std::vector< plLearnObject * >::reverse_iterator"""
        return _pypl.plLearnObjectVector_rend(self)

    def pop_back(self):
        """pop_back(plLearnObjectVector self)"""
        return _pypl.plLearnObjectVector_pop_back(self)

    def erase(self, *args):
        """
        erase(plLearnObjectVector self, std::vector< plLearnObject * >::iterator pos) -> std::vector< plLearnObject * >::iterator
        erase(plLearnObjectVector self, std::vector< plLearnObject * >::iterator first, std::vector< plLearnObject * >::iterator last) -> std::vector< plLearnObject * >::iterator
        """
        return _pypl.plLearnObjectVector_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.plLearnObject)> self) -> plLearnObjectVector
        __init__(std::vector<(p.plLearnObject)> self, plLearnObjectVector arg2) -> plLearnObjectVector
        __init__(std::vector<(p.plLearnObject)> self, std::vector< plLearnObject * >::size_type size) -> plLearnObjectVector
        __init__(std::vector<(p.plLearnObject)> self, std::vector< plLearnObject * >::size_type size, plLearnObject value) -> plLearnObjectVector
        """
        this = _pypl.new_plLearnObjectVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args):
        """push_back(plLearnObjectVector self, plLearnObject x)"""
        return _pypl.plLearnObjectVector_push_back(self, *args)

    def front(self):
        """front(plLearnObjectVector self) -> plLearnObject"""
        return _pypl.plLearnObjectVector_front(self)

    def back(self):
        """back(plLearnObjectVector self) -> plLearnObject"""
        return _pypl.plLearnObjectVector_back(self)

    def assign(self, *args):
        """assign(plLearnObjectVector self, std::vector< plLearnObject * >::size_type n, plLearnObject x)"""
        return _pypl.plLearnObjectVector_assign(self, *args)

    def resize(self, *args):
        """
        resize(plLearnObjectVector self, std::vector< plLearnObject * >::size_type new_size)
        resize(plLearnObjectVector self, std::vector< plLearnObject * >::size_type new_size, plLearnObject x)
        """
        return _pypl.plLearnObjectVector_resize(self, *args)

    def insert(self, *args):
        """
        insert(plLearnObjectVector self, std::vector< plLearnObject * >::iterator pos, plLearnObject x) -> std::vector< plLearnObject * >::iterator
        insert(plLearnObjectVector self, std::vector< plLearnObject * >::iterator pos, std::vector< plLearnObject * >::size_type n, 
            plLearnObject x)
        """
        return _pypl.plLearnObjectVector_insert(self, *args)

    def reserve(self, *args):
        """reserve(plLearnObjectVector self, std::vector< plLearnObject * >::size_type n)"""
        return _pypl.plLearnObjectVector_reserve(self, *args)

    def capacity(self):
        """capacity(plLearnObjectVector self) -> std::vector< plLearnObject * >::size_type"""
        return _pypl.plLearnObjectVector_capacity(self)

    __swig_destroy__ = _pypl.delete_plLearnObjectVector
    __del__ = lambda self : None;
plLearnObjectVector_swigregister = _pypl.plLearnObjectVector_swigregister
plLearnObjectVector_swigregister(plLearnObjectVector)

class plLearnCndObject(plLearnObject):
    """Proxy of C++ plLearnCndObject class"""
    __swig_setmethods__ = {}
    for _s in [plLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearnCndObject, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLearnCndObject, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def get_left_variables(self):
        """get_left_variables(plLearnCndObject self) -> plVariablesConjunction"""
        return _pypl.plLearnCndObject_get_left_variables(self)

    def get_right_variables(self):
        """get_right_variables(plLearnCndObject self) -> plVariablesConjunction"""
        return _pypl.plLearnCndObject_get_right_variables(self)

    def get_cnd_distribution(self):
        """get_cnd_distribution(plLearnCndObject self) -> plCndDistribution"""
        return _pypl.plLearnCndObject_get_cnd_distribution(self)

    def get_computable_object(self):
        """get_computable_object(plLearnCndObject self) -> plComputableObject"""
        return _pypl.plLearnCndObject_get_computable_object(self)

    __swig_destroy__ = _pypl.delete_plLearnCndObject
    __del__ = lambda self : None;
plLearnCndObject_swigregister = _pypl.plLearnCndObject_swigregister
plLearnCndObject_swigregister(plLearnCndObject)

class plLearnDistribVector(plLearnObject):
    """Proxy of C++ plLearnDistribVector class"""
    __swig_setmethods__ = {}
    for _s in [plLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearnDistribVector, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLearnDistribVector, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plLearnDistribVector self) -> plLearnDistribVector
        __init__(plLearnDistribVector self, plLearnObjectVector learn_objects, plVariablesConjunction vars) -> plLearnDistribVector
        __init__(plLearnDistribVector self, plLearnObjectVector learn_objects, bool do_not_clone_learners=False) -> plLearnDistribVector
        __init__(plLearnDistribVector self, plLearnObjectVector learn_objects) -> plLearnDistribVector
        __init__(plLearnDistribVector self, plLearnDistribVector other) -> plLearnDistribVector
        """
        this = _pypl.new_plLearnDistribVector(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plLearnDistribVector
    __del__ = lambda self : None;
    def reset(self):
        """reset(plLearnDistribVector self)"""
        return _pypl.plLearnDistribVector_reset(self)

    def get_computable_object(self):
        """get_computable_object(plLearnDistribVector self) -> plComputableObject"""
        return _pypl.plLearnDistribVector_get_computable_object(self)

    def get_computable_object_list(self):
        """get_computable_object_list(plLearnDistribVector self) -> plComputableObjectList"""
        return _pypl.plLearnDistribVector_get_computable_object_list(self)

    def get_left_variables(self):
        """get_left_variables(plLearnDistribVector self) -> plVariablesConjunction"""
        return _pypl.plLearnDistribVector_get_left_variables(self)

    def get_right_variables(self):
        """get_right_variables(plLearnDistribVector self) -> plVariablesConjunction"""
        return _pypl.plLearnDistribVector_get_right_variables(self)

    def get_n_parameters(self):
        """get_n_parameters(plLearnDistribVector self) -> unsigned int"""
        return _pypl.plLearnDistribVector_get_n_parameters(self)

    def get_nsamples(self, *args):
        """get_nsamples(plLearnDistribVector self, UnsignedIntVector n)"""
        return _pypl.plLearnDistribVector_get_nsamples(self, *args)

    def get_total_weight(self, *args):
        """get_total_weight(plLearnDistribVector self, DoubleVector w)"""
        return _pypl.plLearnDistribVector_get_total_weight(self, *args)

    def clone(self):
        """clone(plLearnDistribVector self) -> plLearnObject"""
        return _pypl.plLearnDistribVector_clone(self)

    def get_learn_objects(self):
        """get_learn_objects(plLearnDistribVector self) -> plLearnObjectVector"""
        return _pypl.plLearnDistribVector_get_learn_objects(self)

plLearnDistribVector_swigregister = _pypl.plLearnDistribVector_swigregister
plLearnDistribVector_swigregister(plLearnDistribVector)

class plNonCndLearnObject(plLearnObject):
    """Proxy of C++ plNonCndLearnObject class"""
    __swig_setmethods__ = {}
    for _s in [plLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plNonCndLearnObject, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plNonCndLearnObject, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plNonCndLearnObject
    __del__ = lambda self : None;
    def get_distribution(self):
        """get_distribution(plNonCndLearnObject self) -> plDistribution"""
        return _pypl.plNonCndLearnObject_get_distribution(self)

    def get_computable_object(self):
        """get_computable_object(plNonCndLearnObject self) -> plComputableObject"""
        return _pypl.plNonCndLearnObject_get_computable_object(self)

    def get_left_variables(self):
        """get_left_variables(plNonCndLearnObject self) -> plVariablesConjunction"""
        return _pypl.plNonCndLearnObject_get_left_variables(self)

    def get_right_variables(self):
        """get_right_variables(plNonCndLearnObject self) -> plVariablesConjunction"""
        return _pypl.plNonCndLearnObject_get_right_variables(self)

    def get_parameters(self, *args):
        """get_parameters(plNonCndLearnObject self, plValues params)"""
        return _pypl.plNonCndLearnObject_get_parameters(self, *args)

plNonCndLearnObject_swigregister = _pypl.plNonCndLearnObject_swigregister
plNonCndLearnObject_swigregister(plNonCndLearnObject)

class plBayesLearnObject(plNonCndLearnObject):
    """Proxy of C++ plBayesLearnObject class"""
    __swig_setmethods__ = {}
    for _s in [plNonCndLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plBayesLearnObject, name, value)
    __swig_getmethods__ = {}
    for _s in [plNonCndLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plBayesLearnObject, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def get_aposteriori_distribution(self, *args):
        """get_aposteriori_distribution(plBayesLearnObject self, plVariablesConjunction param_variables) -> plDistribution"""
        return _pypl.plBayesLearnObject_get_aposteriori_distribution(self, *args)

    __swig_destroy__ = _pypl.delete_plBayesLearnObject
    __del__ = lambda self : None;
plBayesLearnObject_swigregister = _pypl.plBayesLearnObject_swigregister
plBayesLearnObject_swigregister(plBayesLearnObject)

class plMLLearnObject(plNonCndLearnObject):
    """Proxy of C++ plMLLearnObject class"""
    __swig_setmethods__ = {}
    for _s in [plNonCndLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plMLLearnObject, name, value)
    __swig_getmethods__ = {}
    for _s in [plNonCndLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plMLLearnObject, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plMLLearnObject
    __del__ = lambda self : None;
plMLLearnObject_swigregister = _pypl.plMLLearnObject_swigregister
plMLLearnObject_swigregister(plMLLearnObject)

class plBayesLearn1dNormalWithKnownMean(plBayesLearnObject):
    """Proxy of C++ plBayesLearn1dNormalWithKnownMean class"""
    __swig_setmethods__ = {}
    for _s in [plBayesLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plBayesLearn1dNormalWithKnownMean, name, value)
    __swig_getmethods__ = {}
    for _s in [plBayesLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plBayesLearn1dNormalWithKnownMean, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plBayesLearn1dNormalWithKnownMean self) -> plBayesLearn1dNormalWithKnownMean
        __init__(plBayesLearn1dNormalWithKnownMean self, plSymbol variable, plFloat init_alpha, plFloat init_theta, plFloat mu=0.0) -> plBayesLearn1dNormalWithKnownMean
        __init__(plBayesLearn1dNormalWithKnownMean self, plSymbol variable, plFloat init_alpha, plFloat init_theta) -> plBayesLearn1dNormalWithKnownMean
        """
        this = _pypl.new_plBayesLearn1dNormalWithKnownMean(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plBayesLearn1dNormalWithKnownMean
    __del__ = lambda self : None;
    def reset(self):
        """reset(plBayesLearn1dNormalWithKnownMean self)"""
        return _pypl.plBayesLearn1dNormalWithKnownMean_reset(self)

    def get_alpha(self):
        """get_alpha(plBayesLearn1dNormalWithKnownMean self) -> plFloat"""
        return _pypl.plBayesLearn1dNormalWithKnownMean_get_alpha(self)

    def get_theta(self):
        """get_theta(plBayesLearn1dNormalWithKnownMean self) -> plFloat"""
        return _pypl.plBayesLearn1dNormalWithKnownMean_get_theta(self)

    def get_aposteriori_distribution(self, *args):
        """get_aposteriori_distribution(plBayesLearn1dNormalWithKnownMean self, plVariablesConjunction tau) -> plDistribution"""
        return _pypl.plBayesLearn1dNormalWithKnownMean_get_aposteriori_distribution(self, *args)

    def get_distribution(self):
        """get_distribution(plBayesLearn1dNormalWithKnownMean self) -> plDistribution"""
        return _pypl.plBayesLearn1dNormalWithKnownMean_get_distribution(self)

    def get_a_posteriori_expectation(self):
        """get_a_posteriori_expectation(plBayesLearn1dNormalWithKnownMean self) -> plFloat"""
        return _pypl.plBayesLearn1dNormalWithKnownMean_get_a_posteriori_expectation(self)

    def get_parameters(self, *args):
        """get_parameters(plBayesLearn1dNormalWithKnownMean self, plValues params)"""
        return _pypl.plBayesLearn1dNormalWithKnownMean_get_parameters(self, *args)

    def get_n_parameters(self):
        """get_n_parameters(plBayesLearn1dNormalWithKnownMean self) -> unsigned int"""
        return _pypl.plBayesLearn1dNormalWithKnownMean_get_n_parameters(self)

    def clone(self):
        """clone(plBayesLearn1dNormalWithKnownMean self) -> plLearnObject"""
        return _pypl.plBayesLearn1dNormalWithKnownMean_clone(self)

plBayesLearn1dNormalWithKnownMean_swigregister = _pypl.plBayesLearn1dNormalWithKnownMean_swigregister
plBayesLearn1dNormalWithKnownMean_swigregister(plBayesLearn1dNormalWithKnownMean)

class plBayesLearn1dNormalWithKnownStandardDeviation(plBayesLearnObject):
    """Proxy of C++ plBayesLearn1dNormalWithKnownStandardDeviation class"""
    __swig_setmethods__ = {}
    for _s in [plBayesLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plBayesLearn1dNormalWithKnownStandardDeviation, name, value)
    __swig_getmethods__ = {}
    for _s in [plBayesLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plBayesLearn1dNormalWithKnownStandardDeviation, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plBayesLearn1dNormalWithKnownStandardDeviation self) -> plBayesLearn1dNormalWithKnownStandardDeviation
        __init__(plBayesLearn1dNormalWithKnownStandardDeviation self, plSymbol variable, plFloat init_mu, plFloat init_sigma, plFloat sigma0) -> plBayesLearn1dNormalWithKnownStandardDeviation
        """
        this = _pypl.new_plBayesLearn1dNormalWithKnownStandardDeviation(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plBayesLearn1dNormalWithKnownStandardDeviation
    __del__ = lambda self : None;
    def reset(self):
        """reset(plBayesLearn1dNormalWithKnownStandardDeviation self)"""
        return _pypl.plBayesLearn1dNormalWithKnownStandardDeviation_reset(self)

    def get_mu(self):
        """get_mu(plBayesLearn1dNormalWithKnownStandardDeviation self) -> plFloat"""
        return _pypl.plBayesLearn1dNormalWithKnownStandardDeviation_get_mu(self)

    def get_sigma(self):
        """get_sigma(plBayesLearn1dNormalWithKnownStandardDeviation self) -> plFloat"""
        return _pypl.plBayesLearn1dNormalWithKnownStandardDeviation_get_sigma(self)

    def get_sigma0(self):
        """get_sigma0(plBayesLearn1dNormalWithKnownStandardDeviation self) -> plFloat"""
        return _pypl.plBayesLearn1dNormalWithKnownStandardDeviation_get_sigma0(self)

    def get_aposteriori_distribution(self, *args):
        """get_aposteriori_distribution(plBayesLearn1dNormalWithKnownStandardDeviation self, plVariablesConjunction mu) -> plDistribution"""
        return _pypl.plBayesLearn1dNormalWithKnownStandardDeviation_get_aposteriori_distribution(self, *args)

    def get_distribution(self):
        """get_distribution(plBayesLearn1dNormalWithKnownStandardDeviation self) -> plDistribution"""
        return _pypl.plBayesLearn1dNormalWithKnownStandardDeviation_get_distribution(self)

    def get_a_posteriori_expectation(self):
        """get_a_posteriori_expectation(plBayesLearn1dNormalWithKnownStandardDeviation self) -> plFloat"""
        return _pypl.plBayesLearn1dNormalWithKnownStandardDeviation_get_a_posteriori_expectation(self)

    def get_parameters(self, *args):
        """get_parameters(plBayesLearn1dNormalWithKnownStandardDeviation self, plValues params)"""
        return _pypl.plBayesLearn1dNormalWithKnownStandardDeviation_get_parameters(self, *args)

    def get_n_parameters(self):
        """get_n_parameters(plBayesLearn1dNormalWithKnownStandardDeviation self) -> unsigned int"""
        return _pypl.plBayesLearn1dNormalWithKnownStandardDeviation_get_n_parameters(self)

    def clone(self):
        """clone(plBayesLearn1dNormalWithKnownStandardDeviation self) -> plLearnObject"""
        return _pypl.plBayesLearn1dNormalWithKnownStandardDeviation_clone(self)

plBayesLearn1dNormalWithKnownStandardDeviation_swigregister = _pypl.plBayesLearn1dNormalWithKnownStandardDeviation_swigregister
plBayesLearn1dNormalWithKnownStandardDeviation_swigregister(plBayesLearn1dNormalWithKnownStandardDeviation)

class plBayesLearnBinomial(plBayesLearnObject):
    """Proxy of C++ plBayesLearnBinomial class"""
    __swig_setmethods__ = {}
    for _s in [plBayesLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plBayesLearnBinomial, name, value)
    __swig_getmethods__ = {}
    for _s in [plBayesLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plBayesLearnBinomial, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plBayesLearnBinomial self, plSymbol variable, plFloat initp, plFloat initq) -> plBayesLearnBinomial
        __init__(plBayesLearnBinomial self) -> plBayesLearnBinomial
        """
        this = _pypl.new_plBayesLearnBinomial(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plBayesLearnBinomial
    __del__ = lambda self : None;
    def reset(self):
        """reset(plBayesLearnBinomial self)"""
        return _pypl.plBayesLearnBinomial_reset(self)

    def get_p(self):
        """get_p(plBayesLearnBinomial self) -> plFloat"""
        return _pypl.plBayesLearnBinomial_get_p(self)

    def get_q(self):
        """get_q(plBayesLearnBinomial self) -> plFloat"""
        return _pypl.plBayesLearnBinomial_get_q(self)

    def get_n(self):
        """get_n(plBayesLearnBinomial self) -> plFloat"""
        return _pypl.plBayesLearnBinomial_get_n(self)

    def get_aposteriori_distribution(self, *args):
        """get_aposteriori_distribution(plBayesLearnBinomial self, plVariablesConjunction theta) -> plDistribution"""
        return _pypl.plBayesLearnBinomial_get_aposteriori_distribution(self, *args)

    def get_distribution(self):
        """get_distribution(plBayesLearnBinomial self) -> plDistribution"""
        return _pypl.plBayesLearnBinomial_get_distribution(self)

    def get_aposteriori_expectation(self):
        """get_aposteriori_expectation(plBayesLearnBinomial self) -> plFloat"""
        return _pypl.plBayesLearnBinomial_get_aposteriori_expectation(self)

    def get_parameters(self, *args):
        """get_parameters(plBayesLearnBinomial self, plValues params)"""
        return _pypl.plBayesLearnBinomial_get_parameters(self, *args)

    def get_n_parameters(self):
        """get_n_parameters(plBayesLearnBinomial self) -> unsigned int"""
        return _pypl.plBayesLearnBinomial_get_n_parameters(self)

    def clone(self):
        """clone(plBayesLearnBinomial self) -> plLearnObject"""
        return _pypl.plBayesLearnBinomial_clone(self)

plBayesLearnBinomial_swigregister = _pypl.plBayesLearnBinomial_swigregister
plBayesLearnBinomial_swigregister(plBayesLearnBinomial)

class plBayesLearnExponential(plBayesLearnObject):
    """Proxy of C++ plBayesLearnExponential class"""
    __swig_setmethods__ = {}
    for _s in [plBayesLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plBayesLearnExponential, name, value)
    __swig_getmethods__ = {}
    for _s in [plBayesLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plBayesLearnExponential, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plBayesLearnExponential self) -> plBayesLearnExponential
        __init__(plBayesLearnExponential self, plSymbol variable, plFloat init_alpha, plFloat init_theta, plFloat mu=0.0) -> plBayesLearnExponential
        __init__(plBayesLearnExponential self, plSymbol variable, plFloat init_alpha, plFloat init_theta) -> plBayesLearnExponential
        """
        this = _pypl.new_plBayesLearnExponential(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plBayesLearnExponential
    __del__ = lambda self : None;
    def reset(self):
        """reset(plBayesLearnExponential self)"""
        return _pypl.plBayesLearnExponential_reset(self)

    def get_alpha(self):
        """get_alpha(plBayesLearnExponential self) -> plFloat"""
        return _pypl.plBayesLearnExponential_get_alpha(self)

    def get_theta(self):
        """get_theta(plBayesLearnExponential self) -> plFloat"""
        return _pypl.plBayesLearnExponential_get_theta(self)

    def get_aposteriori_distribution(self, *args):
        """get_aposteriori_distribution(plBayesLearnExponential self, plVariablesConjunction beta) -> plDistribution"""
        return _pypl.plBayesLearnExponential_get_aposteriori_distribution(self, *args)

    def get_distribution(self):
        """get_distribution(plBayesLearnExponential self) -> plDistribution"""
        return _pypl.plBayesLearnExponential_get_distribution(self)

    def get_a_posteriori_expectation(self):
        """get_a_posteriori_expectation(plBayesLearnExponential self) -> plFloat"""
        return _pypl.plBayesLearnExponential_get_a_posteriori_expectation(self)

    def get_parameters(self, *args):
        """get_parameters(plBayesLearnExponential self, plValues params)"""
        return _pypl.plBayesLearnExponential_get_parameters(self, *args)

    def get_n_parameters(self):
        """get_n_parameters(plBayesLearnExponential self) -> unsigned int"""
        return _pypl.plBayesLearnExponential_get_n_parameters(self)

    def clone(self):
        """clone(plBayesLearnExponential self) -> plLearnObject"""
        return _pypl.plBayesLearnExponential_clone(self)

    def get_init_alpha(self):
        """get_init_alpha(plBayesLearnExponential self) -> plFloat"""
        return _pypl.plBayesLearnExponential_get_init_alpha(self)

    def get_init_theta(self):
        """get_init_theta(plBayesLearnExponential self) -> plFloat"""
        return _pypl.plBayesLearnExponential_get_init_theta(self)

    def get_sum_samples(self):
        """get_sum_samples(plBayesLearnExponential self) -> plFloat"""
        return _pypl.plBayesLearnExponential_get_sum_samples(self)

    def get_mu(self):
        """get_mu(plBayesLearnExponential self) -> plFloat"""
        return _pypl.plBayesLearnExponential_get_mu(self)

plBayesLearnExponential_swigregister = _pypl.plBayesLearnExponential_swigregister
plBayesLearnExponential_swigregister(plBayesLearnExponential)

class plBayesLearnGamma(plBayesLearnObject):
    """Proxy of C++ plBayesLearnGamma class"""
    __swig_setmethods__ = {}
    for _s in [plBayesLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plBayesLearnGamma, name, value)
    __swig_getmethods__ = {}
    for _s in [plBayesLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plBayesLearnGamma, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plBayesLearnGamma self, plSymbol vars, plFloat v, plFloat mu, plFloat init_alpha, plFloat init_lambda) -> plBayesLearnGamma
        __init__(plBayesLearnGamma self) -> plBayesLearnGamma
        """
        this = _pypl.new_plBayesLearnGamma(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plBayesLearnGamma
    __del__ = lambda self : None;
    def reset(self):
        """reset(plBayesLearnGamma self)"""
        return _pypl.plBayesLearnGamma_reset(self)

    def get_alpha(self):
        """get_alpha(plBayesLearnGamma self) -> plFloat"""
        return _pypl.plBayesLearnGamma_get_alpha(self)

    def get_lambda(self):
        """get_lambda(plBayesLearnGamma self) -> plFloat"""
        return _pypl.plBayesLearnGamma_get_lambda(self)

    def get_aposteriori_distribution(self, *args):
        """get_aposteriori_distribution(plBayesLearnGamma self, plVariablesConjunction gamma_scale_variable) -> plDistribution"""
        return _pypl.plBayesLearnGamma_get_aposteriori_distribution(self, *args)

    def get_distribution(self):
        """get_distribution(plBayesLearnGamma self) -> plDistribution"""
        return _pypl.plBayesLearnGamma_get_distribution(self)

    def get_a_posteriori_expectation(self):
        """get_a_posteriori_expectation(plBayesLearnGamma self) -> plFloat"""
        return _pypl.plBayesLearnGamma_get_a_posteriori_expectation(self)

    def get_parameters(self, *args):
        """get_parameters(plBayesLearnGamma self, plValues params)"""
        return _pypl.plBayesLearnGamma_get_parameters(self, *args)

    def get_n_parameters(self):
        """get_n_parameters(plBayesLearnGamma self) -> unsigned int"""
        return _pypl.plBayesLearnGamma_get_n_parameters(self)

    def clone(self):
        """clone(plBayesLearnGamma self) -> plLearnObject"""
        return _pypl.plBayesLearnGamma_clone(self)

plBayesLearnGamma_swigregister = _pypl.plBayesLearnGamma_swigregister
plBayesLearnGamma_swigregister(plBayesLearnGamma)

class plBayesLearnLogNormalWithKnownShape(plBayesLearnObject):
    """Proxy of C++ plBayesLearnLogNormalWithKnownShape class"""
    __swig_setmethods__ = {}
    for _s in [plBayesLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plBayesLearnLogNormalWithKnownShape, name, value)
    __swig_getmethods__ = {}
    for _s in [plBayesLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plBayesLearnLogNormalWithKnownShape, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plBayesLearnLogNormalWithKnownShape self) -> plBayesLearnLogNormalWithKnownShape
        __init__(plBayesLearnLogNormalWithKnownShape self, plSymbol variable, plFloat init_mu, plFloat init_sigma, plFloat s, plFloat theta) -> plBayesLearnLogNormalWithKnownShape
        """
        this = _pypl.new_plBayesLearnLogNormalWithKnownShape(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plBayesLearnLogNormalWithKnownShape
    __del__ = lambda self : None;
    def reset(self):
        """reset(plBayesLearnLogNormalWithKnownShape self)"""
        return _pypl.plBayesLearnLogNormalWithKnownShape_reset(self)

    def get_mu(self):
        """get_mu(plBayesLearnLogNormalWithKnownShape self) -> plFloat"""
        return _pypl.plBayesLearnLogNormalWithKnownShape_get_mu(self)

    def get_sigma(self):
        """get_sigma(plBayesLearnLogNormalWithKnownShape self) -> plFloat"""
        return _pypl.plBayesLearnLogNormalWithKnownShape_get_sigma(self)

    def get_s(self):
        """get_s(plBayesLearnLogNormalWithKnownShape self) -> plFloat"""
        return _pypl.plBayesLearnLogNormalWithKnownShape_get_s(self)

    def get_theta(self):
        """get_theta(plBayesLearnLogNormalWithKnownShape self) -> plFloat"""
        return _pypl.plBayesLearnLogNormalWithKnownShape_get_theta(self)

    def get_aposteriori_distribution(self, *args):
        """get_aposteriori_distribution(plBayesLearnLogNormalWithKnownShape self, plVariablesConjunction mu) -> plDistribution"""
        return _pypl.plBayesLearnLogNormalWithKnownShape_get_aposteriori_distribution(self, *args)

    def get_distribution(self):
        """get_distribution(plBayesLearnLogNormalWithKnownShape self) -> plDistribution"""
        return _pypl.plBayesLearnLogNormalWithKnownShape_get_distribution(self)

    def get_a_posteriori_expectation(self):
        """get_a_posteriori_expectation(plBayesLearnLogNormalWithKnownShape self) -> plFloat"""
        return _pypl.plBayesLearnLogNormalWithKnownShape_get_a_posteriori_expectation(self)

    def get_parameters(self, *args):
        """get_parameters(plBayesLearnLogNormalWithKnownShape self, plValues params)"""
        return _pypl.plBayesLearnLogNormalWithKnownShape_get_parameters(self, *args)

    def get_n_parameters(self):
        """get_n_parameters(plBayesLearnLogNormalWithKnownShape self) -> unsigned int"""
        return _pypl.plBayesLearnLogNormalWithKnownShape_get_n_parameters(self)

    def clone(self):
        """clone(plBayesLearnLogNormalWithKnownShape self) -> plLearnObject"""
        return _pypl.plBayesLearnLogNormalWithKnownShape_clone(self)

plBayesLearnLogNormalWithKnownShape_swigregister = _pypl.plBayesLearnLogNormalWithKnownShape_swigregister
plBayesLearnLogNormalWithKnownShape_swigregister(plBayesLearnLogNormalWithKnownShape)

class plBayesLearnNdNormalWithKnownVariance(plBayesLearnObject):
    """Proxy of C++ plBayesLearnNdNormalWithKnownVariance class"""
    __swig_setmethods__ = {}
    for _s in [plBayesLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plBayesLearnNdNormalWithKnownVariance, name, value)
    __swig_getmethods__ = {}
    for _s in [plBayesLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plBayesLearnNdNormalWithKnownVariance, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plBayesLearnNdNormalWithKnownVariance self) -> plBayesLearnNdNormalWithKnownVariance
        __init__(plBayesLearnNdNormalWithKnownVariance self, plVariablesConjunction variable, plFloatVector init_mu, plFloatMatrix init_sigma, 
            plFloatMatrix sigma0) -> plBayesLearnNdNormalWithKnownVariance
        """
        this = _pypl.new_plBayesLearnNdNormalWithKnownVariance(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plBayesLearnNdNormalWithKnownVariance
    __del__ = lambda self : None;
    def reset(self):
        """reset(plBayesLearnNdNormalWithKnownVariance self)"""
        return _pypl.plBayesLearnNdNormalWithKnownVariance_reset(self)

    def get_mu(self):
        """get_mu(plBayesLearnNdNormalWithKnownVariance self) -> plFloatVector"""
        return _pypl.plBayesLearnNdNormalWithKnownVariance_get_mu(self)

    def get_sigma(self):
        """get_sigma(plBayesLearnNdNormalWithKnownVariance self) -> plFloatMatrix"""
        return _pypl.plBayesLearnNdNormalWithKnownVariance_get_sigma(self)

    def get_sigma0(self):
        """get_sigma0(plBayesLearnNdNormalWithKnownVariance self) -> plFloatMatrix"""
        return _pypl.plBayesLearnNdNormalWithKnownVariance_get_sigma0(self)

    def get_aposteriori_distribution(self, *args):
        """get_aposteriori_distribution(plBayesLearnNdNormalWithKnownVariance self, plVariablesConjunction mu) -> plDistribution"""
        return _pypl.plBayesLearnNdNormalWithKnownVariance_get_aposteriori_distribution(self, *args)

    def get_distribution(self):
        """get_distribution(plBayesLearnNdNormalWithKnownVariance self) -> plDistribution"""
        return _pypl.plBayesLearnNdNormalWithKnownVariance_get_distribution(self)

    def get_mu_sigma(self, *args):
        """get_mu_sigma(plBayesLearnNdNormalWithKnownVariance self, plFloatVector mu, plFloatMatrix sigma)"""
        return _pypl.plBayesLearnNdNormalWithKnownVariance_get_mu_sigma(self, *args)

    def add_point(self, *args):
        """
        add_point(plBayesLearnNdNormalWithKnownVariance self, plValues point, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, plValues point) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, int const * point, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, int const * point) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, unsigned int const * point, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, unsigned int const * point) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, float const * point, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, float const * point) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, double const * point, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, double const * point) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, long double const * point, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, long double const * point) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, IntVector point, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, IntVector point) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, UnsignedIntVector point, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, UnsignedIntVector point) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, DoubleVector point, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, DoubleVector point) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, FloatVector point, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, FloatVector point) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, LongDoubleVector point, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, LongDoubleVector point) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, int point, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, int point) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, unsigned int point, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, unsigned int point) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, double point, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, double point) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, float point, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, float point) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, long double point, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, long double point) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, plValues point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, plValues point, BoolVector is_defined) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, int const * point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, int const * point, BoolVector is_defined) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, unsigned int const * point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, unsigned int const * point, BoolVector is_defined) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, double const * point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, double const * point, BoolVector is_defined) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, float const * point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, float const * point, BoolVector is_defined) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, long double const * point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, long double const * point, BoolVector is_defined) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, IntVector point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, IntVector point, BoolVector is_defined) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, UnsignedIntVector point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, UnsignedIntVector point, BoolVector is_defined) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, DoubleVector point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, DoubleVector point, BoolVector is_defined) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, FloatVector point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, FloatVector point, BoolVector is_defined) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, LongDoubleVector point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, LongDoubleVector point, BoolVector is_defined) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, plFloatVector point, plFloat weight=1.0) -> bool
        add_point(plBayesLearnNdNormalWithKnownVariance self, plFloatVector point) -> bool
        """
        return _pypl.plBayesLearnNdNormalWithKnownVariance_add_point(self, *args)

    def get_parameters(self, *args):
        """get_parameters(plBayesLearnNdNormalWithKnownVariance self, plValues params)"""
        return _pypl.plBayesLearnNdNormalWithKnownVariance_get_parameters(self, *args)

    def get_n_parameters(self):
        """get_n_parameters(plBayesLearnNdNormalWithKnownVariance self) -> unsigned int"""
        return _pypl.plBayesLearnNdNormalWithKnownVariance_get_n_parameters(self)

    def clone(self):
        """clone(plBayesLearnNdNormalWithKnownVariance self) -> plLearnObject"""
        return _pypl.plBayesLearnNdNormalWithKnownVariance_clone(self)

plBayesLearnNdNormalWithKnownVariance_swigregister = _pypl.plBayesLearnNdNormalWithKnownVariance_swigregister
plBayesLearnNdNormalWithKnownVariance_swigregister(plBayesLearnNdNormalWithKnownVariance)

class plBayesLearnPoisson(plBayesLearnObject):
    """Proxy of C++ plBayesLearnPoisson class"""
    __swig_setmethods__ = {}
    for _s in [plBayesLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plBayesLearnPoisson, name, value)
    __swig_getmethods__ = {}
    for _s in [plBayesLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plBayesLearnPoisson, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plBayesLearnPoisson self, plSymbol vars, plFloat init_alpha, plFloat init_lambda) -> plBayesLearnPoisson
        __init__(plBayesLearnPoisson self) -> plBayesLearnPoisson
        """
        this = _pypl.new_plBayesLearnPoisson(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plBayesLearnPoisson
    __del__ = lambda self : None;
    def reset(self):
        """reset(plBayesLearnPoisson self)"""
        return _pypl.plBayesLearnPoisson_reset(self)

    def get_alpha(self):
        """get_alpha(plBayesLearnPoisson self) -> plFloat"""
        return _pypl.plBayesLearnPoisson_get_alpha(self)

    def get_lambda(self):
        """get_lambda(plBayesLearnPoisson self) -> plFloat"""
        return _pypl.plBayesLearnPoisson_get_lambda(self)

    def get_aposteriori_distribution(self, *args):
        """get_aposteriori_distribution(plBayesLearnPoisson self, plVariablesConjunction poisson_mean_variable) -> plDistribution"""
        return _pypl.plBayesLearnPoisson_get_aposteriori_distribution(self, *args)

    def get_distribution(self):
        """get_distribution(plBayesLearnPoisson self) -> plDistribution"""
        return _pypl.plBayesLearnPoisson_get_distribution(self)

    def get_a_posteriori_expectation(self):
        """get_a_posteriori_expectation(plBayesLearnPoisson self) -> plFloat"""
        return _pypl.plBayesLearnPoisson_get_a_posteriori_expectation(self)

    def get_parameters(self, *args):
        """get_parameters(plBayesLearnPoisson self, plValues params)"""
        return _pypl.plBayesLearnPoisson_get_parameters(self, *args)

    def get_n_parameters(self):
        """get_n_parameters(plBayesLearnPoisson self) -> unsigned int"""
        return _pypl.plBayesLearnPoisson_get_n_parameters(self)

    def clone(self):
        """clone(plBayesLearnPoisson self) -> plLearnObject"""
        return _pypl.plBayesLearnPoisson_clone(self)

plBayesLearnPoisson_swigregister = _pypl.plBayesLearnPoisson_swigregister
plBayesLearnPoisson_swigregister(plBayesLearnPoisson)

class plBayesLearnProbTable(plBayesLearnObject):
    """Proxy of C++ plBayesLearnProbTable class"""
    __swig_setmethods__ = {}
    for _s in [plBayesLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plBayesLearnProbTable, name, value)
    __swig_getmethods__ = {}
    for _s in [plBayesLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plBayesLearnProbTable, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plBayesLearnProbTable self, plVariablesConjunction vars, DoubleVector init_alpha) -> plBayesLearnProbTable
        __init__(plBayesLearnProbTable self) -> plBayesLearnProbTable
        """
        this = _pypl.new_plBayesLearnProbTable(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plBayesLearnProbTable
    __del__ = lambda self : None;
    def reset(self):
        """reset(plBayesLearnProbTable self)"""
        return _pypl.plBayesLearnProbTable_reset(self)

    def get_alpha(self):
        """get_alpha(plBayesLearnProbTable self) -> DoubleVector"""
        return _pypl.plBayesLearnProbTable_get_alpha(self)

    def get_aposteriori_distribution(self, *args):
        """get_aposteriori_distribution(plBayesLearnProbTable self, plVariablesConjunction params_variable) -> plDistribution"""
        return _pypl.plBayesLearnProbTable_get_aposteriori_distribution(self, *args)

    def get_distribution(self):
        """get_distribution(plBayesLearnProbTable self) -> plDistribution"""
        return _pypl.plBayesLearnProbTable_get_distribution(self)

    def get_parameters(self, *args):
        """get_parameters(plBayesLearnProbTable self, plValues params)"""
        return _pypl.plBayesLearnProbTable_get_parameters(self, *args)

    def get_n_parameters(self):
        """get_n_parameters(plBayesLearnProbTable self) -> unsigned int"""
        return _pypl.plBayesLearnProbTable_get_n_parameters(self)

    def clone(self):
        """clone(plBayesLearnProbTable self) -> plLearnObject"""
        return _pypl.plBayesLearnProbTable_clone(self)

plBayesLearnProbTable_swigregister = _pypl.plBayesLearnProbTable_swigregister
plBayesLearnProbTable_swigregister(plBayesLearnProbTable)

class plLearn1dNormal(plMLLearnObject):
    """Proxy of C++ plLearn1dNormal class"""
    __swig_setmethods__ = {}
    for _s in [plMLLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearn1dNormal, name, value)
    __swig_getmethods__ = {}
    for _s in [plMLLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLearn1dNormal, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plLearn1dNormal self, plSymbol vars) -> plLearn1dNormal
        __init__(plLearn1dNormal self, plSymbol vars, plFloat init_mean, plFloat init_std_dev, plFloat init_weight=1.0) -> plLearn1dNormal
        __init__(plLearn1dNormal self, plSymbol vars, plFloat init_mean, plFloat init_std_dev) -> plLearn1dNormal
        __init__(plLearn1dNormal self) -> plLearn1dNormal
        """
        this = _pypl.new_plLearn1dNormal(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plLearn1dNormal
    __del__ = lambda self : None;
    def reset(self):
        """reset(plLearn1dNormal self)"""
        return _pypl.plLearn1dNormal_reset(self)

    def clone(self):
        """clone(plLearn1dNormal self) -> plLearnObject"""
        return _pypl.plLearn1dNormal_clone(self)

    def get_mu(self):
        """get_mu(plLearn1dNormal self) -> plFloat"""
        return _pypl.plLearn1dNormal_get_mu(self)

    def get_var(self):
        """get_var(plLearn1dNormal self) -> plFloat"""
        return _pypl.plLearn1dNormal_get_var(self)

    def get_sigma(self):
        """get_sigma(plLearn1dNormal self) -> plFloat"""
        return _pypl.plLearn1dNormal_get_sigma(self)

    def get_actual_min_max(self, *args):
        """
        get_actual_min_max(plLearn1dNormal self, plFloat & min, plFloat & max, plProbValue cumul_prob=0.95)
        get_actual_min_max(plLearn1dNormal self, plFloat & min, plFloat & max)
        """
        return _pypl.plLearn1dNormal_get_actual_min_max(self, *args)

    def get_distribution(self):
        """get_distribution(plLearn1dNormal self) -> plDistribution"""
        return _pypl.plLearn1dNormal_get_distribution(self)

    def get_parameters(self, *args):
        """get_parameters(plLearn1dNormal self, plValues params)"""
        return _pypl.plLearn1dNormal_get_parameters(self, *args)

    def get_n_parameters(self):
        """get_n_parameters(plLearn1dNormal self) -> unsigned int"""
        return _pypl.plLearn1dNormal_get_n_parameters(self)

plLearn1dNormal_swigregister = _pypl.plLearn1dNormal_swigregister
plLearn1dNormal_swigregister(plLearn1dNormal)

class plLearnDistributionTable(plLearnCndObject):
    """Proxy of C++ plLearnDistributionTable class"""
    __swig_setmethods__ = {}
    for _s in [plLearnCndObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearnDistributionTable, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnCndObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLearnDistributionTable, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plLearnDistributionTable self, plVariablesConjunction left_vars, plVariablesConjunction right_vars) -> plLearnDistributionTable
        __init__(plLearnDistributionTable self, plVariablesConjunction left_vars, plVariablesConjunction right_vars, plNonCndLearnObject init_object) -> plLearnDistributionTable
        __init__(plLearnDistributionTable self) -> plLearnDistributionTable
        __init__(plLearnDistributionTable self, plLearnDistributionTable other) -> plLearnDistributionTable
        """
        this = _pypl.new_plLearnDistributionTable(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plLearnDistributionTable
    __del__ = lambda self : None;
    def push(self, *args):
        """
        push(plLearnDistributionTable self, plNonCndLearnObject learn_object, plValues value)
        push(plLearnDistributionTable self, plNonCndLearnObject learn_object, int value)
        push(plLearnDistributionTable self, plNonCndLearnObject learn_object, plFloat value)
        """
        return _pypl.plLearnDistributionTable_push(self, *args)

    def push_default(self, *args):
        """push_default(plLearnDistributionTable self, plNonCndLearnObject default_learn_object)"""
        return _pypl.plLearnDistributionTable_push_default(self, *args)

    def reset(self):
        """reset(plLearnDistributionTable self)"""
        return _pypl.plLearnDistributionTable_reset(self)

    def get_distribution_table(self):
        """get_distribution_table(plLearnDistributionTable self) -> plDistributionTable"""
        return _pypl.plLearnDistributionTable_get_distribution_table(self)

    def get_cnd_distribution(self):
        """get_cnd_distribution(plLearnDistributionTable self) -> plCndDistribution"""
        return _pypl.plLearnDistributionTable_get_cnd_distribution(self)

    def get_total_weights(self, *args):
        """get_total_weights(plLearnDistributionTable self, DoubleVector w)"""
        return _pypl.plLearnDistributionTable_get_total_weights(self, *args)

    def get_nsamples(self, *args):
        """get_nsamples(plLearnDistributionTable self, UnsignedIntVector n)"""
        return _pypl.plLearnDistributionTable_get_nsamples(self, *args)

    def get_learnt_object_for_value(self, *args):
        """get_learnt_object_for_value(plLearnDistributionTable self, plValues right_value) -> plNonCndLearnObject"""
        return _pypl.plLearnDistributionTable_get_learnt_object_for_value(self, *args)

    def get_parameters(self, *args):
        """get_parameters(plLearnDistributionTable self, plValues params, plValues right_value)"""
        return _pypl.plLearnDistributionTable_get_parameters(self, *args)

    def get_n_parameters(self):
        """get_n_parameters(plLearnDistributionTable self) -> unsigned int"""
        return _pypl.plLearnDistributionTable_get_n_parameters(self)

    def clone(self):
        """clone(plLearnDistributionTable self) -> plLearnObject"""
        return _pypl.plLearnDistributionTable_clone(self)

plLearnDistributionTable_swigregister = _pypl.plLearnDistributionTable_swigregister
plLearnDistributionTable_swigregister(plLearnDistributionTable)

class plLearnExponential(plMLLearnObject):
    """Proxy of C++ plLearnExponential class"""
    __swig_setmethods__ = {}
    for _s in [plMLLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearnExponential, name, value)
    __swig_getmethods__ = {}
    for _s in [plMLLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLearnExponential, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plLearnExponential self, plSymbol vars, plFloat min_value, plFloat init_mean, plFloat init_weight=1.0) -> plLearnExponential
        __init__(plLearnExponential self, plSymbol vars, plFloat min_value, plFloat init_mean) -> plLearnExponential
        __init__(plLearnExponential self, plSymbol vars) -> plLearnExponential
        __init__(plLearnExponential self) -> plLearnExponential
        """
        this = _pypl.new_plLearnExponential(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plLearnExponential
    __del__ = lambda self : None;
    def reset(self):
        """reset(plLearnExponential self)"""
        return _pypl.plLearnExponential_reset(self)

    def get_mu(self):
        """get_mu(plLearnExponential self) -> plFloat"""
        return _pypl.plLearnExponential_get_mu(self)

    def get_beta(self):
        """get_beta(plLearnExponential self) -> plFloat"""
        return _pypl.plLearnExponential_get_beta(self)

    def get_distribution(self):
        """get_distribution(plLearnExponential self) -> plDistribution"""
        return _pypl.plLearnExponential_get_distribution(self)

    def get_parameters(self, *args):
        """get_parameters(plLearnExponential self, plValues params)"""
        return _pypl.plLearnExponential_get_parameters(self, *args)

    def get_n_parameters(self):
        """get_n_parameters(plLearnExponential self) -> unsigned int"""
        return _pypl.plLearnExponential_get_n_parameters(self)

    def clone(self):
        """clone(plLearnExponential self) -> plLearnObject"""
        return _pypl.plLearnExponential_clone(self)

plLearnExponential_swigregister = _pypl.plLearnExponential_swigregister
plLearnExponential_swigregister(plLearnExponential)

class plLearnGamma(plMLLearnObject):
    """Proxy of C++ plLearnGamma class"""
    __swig_setmethods__ = {}
    for _s in [plMLLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearnGamma, name, value)
    __swig_getmethods__ = {}
    for _s in [plMLLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLearnGamma, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plLearnGamma self, plSymbol vars, plFloat mu=0.0) -> plLearnGamma
        __init__(plLearnGamma self, plSymbol vars) -> plLearnGamma
        __init__(plLearnGamma self) -> plLearnGamma
        """
        this = _pypl.new_plLearnGamma(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plLearnGamma
    __del__ = lambda self : None;
    def reset(self):
        """reset(plLearnGamma self)"""
        return _pypl.plLearnGamma_reset(self)

    def get_a(self):
        """get_a(plLearnGamma self) -> plFloat"""
        return _pypl.plLearnGamma_get_a(self)

    def get_b(self):
        """get_b(plLearnGamma self) -> plFloat"""
        return _pypl.plLearnGamma_get_b(self)

    def get_distribution(self):
        """get_distribution(plLearnGamma self) -> plDistribution"""
        return _pypl.plLearnGamma_get_distribution(self)

    def get_parameters(self, *args):
        """get_parameters(plLearnGamma self, plValues params)"""
        return _pypl.plLearnGamma_get_parameters(self, *args)

    def get_n_parameters(self):
        """get_n_parameters(plLearnGamma self) -> unsigned int"""
        return _pypl.plLearnGamma_get_n_parameters(self)

    def clone(self):
        """clone(plLearnGamma self) -> plLearnObject"""
        return _pypl.plLearnGamma_clone(self)

plLearnGamma_swigregister = _pypl.plLearnGamma_swigregister
plLearnGamma_swigregister(plLearnGamma)

class plLearnHistogram(plMLLearnObject):
    """Proxy of C++ plLearnHistogram class"""
    __swig_setmethods__ = {}
    for _s in [plMLLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearnHistogram, name, value)
    __swig_getmethods__ = {}
    for _s in [plMLLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLearnHistogram, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plLearnHistogram self) -> plLearnHistogram
        __init__(plLearnHistogram self, plVariablesConjunction vars) -> plLearnHistogram
        """
        this = _pypl.new_plLearnHistogram(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plLearnHistogram
    __del__ = lambda self : None;
    def reset(self):
        """reset(plLearnHistogram self)"""
        return _pypl.plLearnHistogram_reset(self)

    def get_distribution(self):
        """get_distribution(plLearnHistogram self) -> plDistribution"""
        return _pypl.plLearnHistogram_get_distribution(self)

    def get_frequency(self):
        """get_frequency(plLearnHistogram self) -> DoubleVector"""
        return _pypl.plLearnHistogram_get_frequency(self)

    def get_actual_min_max(self, *args):
        """get_actual_min_max(plLearnHistogram self, plValues min, plValues max)"""
        return _pypl.plLearnHistogram_get_actual_min_max(self, *args)

    def size(self):
        """size(plLearnHistogram self) -> size_t"""
        return _pypl.plLearnHistogram_size(self)

    def get_parameters(self, *args):
        """get_parameters(plLearnHistogram self, plValues params)"""
        return _pypl.plLearnHistogram_get_parameters(self, *args)

    def get_n_parameters(self):
        """get_n_parameters(plLearnHistogram self) -> unsigned int"""
        return _pypl.plLearnHistogram_get_n_parameters(self)

    def clone(self):
        """clone(plLearnHistogram self) -> plLearnObject"""
        return _pypl.plLearnHistogram_clone(self)

plLearnHistogram_swigregister = _pypl.plLearnHistogram_swigregister
plLearnHistogram_swigregister(plLearnHistogram)

class plLearnLidstone(plBayesLearnProbTable):
    """Proxy of C++ plLearnLidstone class"""
    __swig_setmethods__ = {}
    for _s in [plBayesLearnProbTable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearnLidstone, name, value)
    __swig_getmethods__ = {}
    for _s in [plBayesLearnProbTable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLearnLidstone, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plLearnLidstone self) -> plLearnLidstone
        __init__(plLearnLidstone self, plVariablesConjunction vars, plFloat alpha=1.0) -> plLearnLidstone
        __init__(plLearnLidstone self, plVariablesConjunction vars) -> plLearnLidstone
        """
        this = _pypl.new_plLearnLidstone(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plLearnLidstone
    __del__ = lambda self : None;
    def clone(self):
        """clone(plLearnLidstone self) -> plLearnObject"""
        return _pypl.plLearnLidstone_clone(self)

plLearnLidstone_swigregister = _pypl.plLearnLidstone_swigregister
plLearnLidstone_swigregister(plLearnLidstone)

class plLearnLaplace(plLearnLidstone):
    """Proxy of C++ plLearnLaplace class"""
    __swig_setmethods__ = {}
    for _s in [plLearnLidstone]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearnLaplace, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnLidstone]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLearnLaplace, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plLearnLaplace self) -> plLearnLaplace
        __init__(plLearnLaplace self, plVariablesConjunction vars) -> plLearnLaplace
        """
        this = _pypl.new_plLearnLaplace(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plLearnLaplace
    __del__ = lambda self : None;
    def clone(self):
        """clone(plLearnLaplace self) -> plLearnObject"""
        return _pypl.plLearnLaplace_clone(self)

plLearnLaplace_swigregister = _pypl.plLearnLaplace_swigregister
plLearnLaplace_swigregister(plLearnLaplace)

class plLearnLogNormal(plMLLearnObject):
    """Proxy of C++ plLearnLogNormal class"""
    __swig_setmethods__ = {}
    for _s in [plMLLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearnLogNormal, name, value)
    __swig_getmethods__ = {}
    for _s in [plMLLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLearnLogNormal, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plLearnLogNormal self, plSymbol vars, plFloat theta=0.0) -> plLearnLogNormal
        __init__(plLearnLogNormal self, plSymbol vars) -> plLearnLogNormal
        __init__(plLearnLogNormal self) -> plLearnLogNormal
        """
        this = _pypl.new_plLearnLogNormal(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plLearnLogNormal
    __del__ = lambda self : None;
    def reset(self):
        """reset(plLearnLogNormal self)"""
        return _pypl.plLearnLogNormal_reset(self)

    def set_theta(self, *args):
        """set_theta(plLearnLogNormal self, plFloat theta)"""
        return _pypl.plLearnLogNormal_set_theta(self, *args)

    def get_theta(self):
        """get_theta(plLearnLogNormal self) -> plFloat"""
        return _pypl.plLearnLogNormal_get_theta(self)

    def get_m(self):
        """get_m(plLearnLogNormal self) -> plFloat"""
        return _pypl.plLearnLogNormal_get_m(self)

    def get_sigma(self):
        """get_sigma(plLearnLogNormal self) -> plFloat"""
        return _pypl.plLearnLogNormal_get_sigma(self)

    def get_distribution(self):
        """get_distribution(plLearnLogNormal self) -> plDistribution"""
        return _pypl.plLearnLogNormal_get_distribution(self)

    def get_parameters(self, *args):
        """get_parameters(plLearnLogNormal self, plValues params)"""
        return _pypl.plLearnLogNormal_get_parameters(self, *args)

    def get_n_parameters(self):
        """get_n_parameters(plLearnLogNormal self) -> unsigned int"""
        return _pypl.plLearnLogNormal_get_n_parameters(self)

    def clone(self):
        """clone(plLearnLogNormal self) -> plLearnObject"""
        return _pypl.plLearnLogNormal_clone(self)

plLearnLogNormal_swigregister = _pypl.plLearnLogNormal_swigregister
plLearnLogNormal_swigregister(plLearnLogNormal)

class plLearnNdNormal(plMLLearnObject):
    """Proxy of C++ plLearnNdNormal class"""
    __swig_setmethods__ = {}
    for _s in [plMLLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearnNdNormal, name, value)
    __swig_getmethods__ = {}
    for _s in [plMLLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLearnNdNormal, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plLearnNdNormal self, plVariablesConjunction vars) -> plLearnNdNormal
        __init__(plLearnNdNormal self, plVariablesConjunction vars, plFloatVector init_mean, plFloatMatrix init_matrix, 
            plFloat init_weight=1.0) -> plLearnNdNormal
        __init__(plLearnNdNormal self, plVariablesConjunction vars, plFloatVector init_mean, plFloatMatrix init_matrix) -> plLearnNdNormal
        __init__(plLearnNdNormal self) -> plLearnNdNormal
        """
        this = _pypl.new_plLearnNdNormal(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plLearnNdNormal
    __del__ = lambda self : None;
    def reset(self):
        """reset(plLearnNdNormal self)"""
        return _pypl.plLearnNdNormal_reset(self)

    def get_mean(self, *args):
        """
        get_mean(plLearnNdNormal self, plFloatVector mean)
        get_mean(plLearnNdNormal self) -> plFloatVector
        """
        return _pypl.plLearnNdNormal_get_mean(self, *args)

    def get_covariance(self, *args):
        """
        get_covariance(plLearnNdNormal self, plFloatMatrix covariance)
        get_covariance(plLearnNdNormal self) -> plFloatMatrix
        """
        return _pypl.plLearnNdNormal_get_covariance(self, *args)

    def get_actual_min_max(self, *args):
        """
        get_actual_min_max(plLearnNdNormal self, plFloatVector min, plFloatVector max, plProbValue cumul_prob=0.95)
        get_actual_min_max(plLearnNdNormal self, plFloatVector min, plFloatVector max)
        """
        return _pypl.plLearnNdNormal_get_actual_min_max(self, *args)

    def get_distribution(self):
        """get_distribution(plLearnNdNormal self) -> plDistribution"""
        return _pypl.plLearnNdNormal_get_distribution(self)

    def add_point(self, *args):
        """
        add_point(plLearnNdNormal self, plValues point, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, plValues point) -> bool
        add_point(plLearnNdNormal self, int const * point, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, int const * point) -> bool
        add_point(plLearnNdNormal self, unsigned int const * point, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, unsigned int const * point) -> bool
        add_point(plLearnNdNormal self, float const * point, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, float const * point) -> bool
        add_point(plLearnNdNormal self, double const * point, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, double const * point) -> bool
        add_point(plLearnNdNormal self, long double const * point, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, long double const * point) -> bool
        add_point(plLearnNdNormal self, IntVector point, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, IntVector point) -> bool
        add_point(plLearnNdNormal self, UnsignedIntVector point, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, UnsignedIntVector point) -> bool
        add_point(plLearnNdNormal self, DoubleVector point, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, DoubleVector point) -> bool
        add_point(plLearnNdNormal self, FloatVector point, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, FloatVector point) -> bool
        add_point(plLearnNdNormal self, LongDoubleVector point, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, LongDoubleVector point) -> bool
        add_point(plLearnNdNormal self, int point, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, int point) -> bool
        add_point(plLearnNdNormal self, unsigned int point, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, unsigned int point) -> bool
        add_point(plLearnNdNormal self, double point, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, double point) -> bool
        add_point(plLearnNdNormal self, float point, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, float point) -> bool
        add_point(plLearnNdNormal self, long double point, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, long double point) -> bool
        add_point(plLearnNdNormal self, plValues point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, plValues point, BoolVector is_defined) -> bool
        add_point(plLearnNdNormal self, int const * point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, int const * point, BoolVector is_defined) -> bool
        add_point(plLearnNdNormal self, unsigned int const * point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, unsigned int const * point, BoolVector is_defined) -> bool
        add_point(plLearnNdNormal self, double const * point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, double const * point, BoolVector is_defined) -> bool
        add_point(plLearnNdNormal self, float const * point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, float const * point, BoolVector is_defined) -> bool
        add_point(plLearnNdNormal self, long double const * point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, long double const * point, BoolVector is_defined) -> bool
        add_point(plLearnNdNormal self, IntVector point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, IntVector point, BoolVector is_defined) -> bool
        add_point(plLearnNdNormal self, UnsignedIntVector point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, UnsignedIntVector point, BoolVector is_defined) -> bool
        add_point(plLearnNdNormal self, DoubleVector point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, DoubleVector point, BoolVector is_defined) -> bool
        add_point(plLearnNdNormal self, FloatVector point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, FloatVector point, BoolVector is_defined) -> bool
        add_point(plLearnNdNormal self, LongDoubleVector point, BoolVector is_defined, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, LongDoubleVector point, BoolVector is_defined) -> bool
        add_point(plLearnNdNormal self, plFloatVector point, plFloat weight=1.0) -> bool
        add_point(plLearnNdNormal self, plFloatVector point) -> bool
        """
        return _pypl.plLearnNdNormal_add_point(self, *args)

    def get_parameters(self, *args):
        """get_parameters(plLearnNdNormal self, plValues params)"""
        return _pypl.plLearnNdNormal_get_parameters(self, *args)

    def get_n_parameters(self):
        """get_n_parameters(plLearnNdNormal self) -> unsigned int"""
        return _pypl.plLearnNdNormal_get_n_parameters(self)

    def clone(self):
        """clone(plLearnNdNormal self) -> plLearnObject"""
        return _pypl.plLearnNdNormal_clone(self)

plLearnNdNormal_swigregister = _pypl.plLearnNdNormal_swigregister
plLearnNdNormal_swigregister(plLearnNdNormal)

class plLearnPoisson(plMLLearnObject):
    """Proxy of C++ plLearnPoisson class"""
    __swig_setmethods__ = {}
    for _s in [plMLLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearnPoisson, name, value)
    __swig_getmethods__ = {}
    for _s in [plMLLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLearnPoisson, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plLearnPoisson self, plSymbol vars) -> plLearnPoisson
        __init__(plLearnPoisson self, plSymbol vars, plFloat init_mean, plFloat init_weight=1.0) -> plLearnPoisson
        __init__(plLearnPoisson self, plSymbol vars, plFloat init_mean) -> plLearnPoisson
        __init__(plLearnPoisson self) -> plLearnPoisson
        """
        this = _pypl.new_plLearnPoisson(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plLearnPoisson
    __del__ = lambda self : None;
    def reset(self):
        """reset(plLearnPoisson self)"""
        return _pypl.plLearnPoisson_reset(self)

    def get_mu(self):
        """get_mu(plLearnPoisson self) -> plFloat"""
        return _pypl.plLearnPoisson_get_mu(self)

    def get_distribution(self):
        """get_distribution(plLearnPoisson self) -> plDistribution"""
        return _pypl.plLearnPoisson_get_distribution(self)

    def get_parameters(self, *args):
        """get_parameters(plLearnPoisson self, plValues params)"""
        return _pypl.plLearnPoisson_get_parameters(self, *args)

    def get_n_parameters(self):
        """get_n_parameters(plLearnPoisson self) -> unsigned int"""
        return _pypl.plLearnPoisson_get_n_parameters(self)

    def clone(self):
        """clone(plLearnPoisson self) -> plLearnObject"""
        return _pypl.plLearnPoisson_clone(self)

plLearnPoisson_swigregister = _pypl.plLearnPoisson_swigregister
plLearnPoisson_swigregister(plLearnPoisson)

class plLearnSparseHistogram(plMLLearnObject):
    """Proxy of C++ plLearnSparseHistogram class"""
    __swig_setmethods__ = {}
    for _s in [plMLLearnObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearnSparseHistogram, name, value)
    __swig_getmethods__ = {}
    for _s in [plMLLearnObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLearnSparseHistogram, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plLearnSparseHistogram self) -> plLearnSparseHistogram
        __init__(plLearnSparseHistogram self, plLearnSparseHistogram histo) -> plLearnSparseHistogram
        __init__(plLearnSparseHistogram self, plVariablesConjunction vars) -> plLearnSparseHistogram
        """
        this = _pypl.new_plLearnSparseHistogram(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plLearnSparseHistogram
    __del__ = lambda self : None;
    def get_distribution(self):
        """get_distribution(plLearnSparseHistogram self) -> plDistribution"""
        return _pypl.plLearnSparseHistogram_get_distribution(self)

    def reset(self):
        """reset(plLearnSparseHistogram self)"""
        return _pypl.plLearnSparseHistogram_reset(self)

    def get_probability(self, *args):
        """
        get_probability(plLearnSparseHistogram self, DoubleVector table)
        get_probability(plLearnSparseHistogram self, plProbValue * table)
        """
        return _pypl.plLearnSparseHistogram_get_probability(self, *args)

    def get_parameters(self, *args):
        """get_parameters(plLearnSparseHistogram self, plValues params)"""
        return _pypl.plLearnSparseHistogram_get_parameters(self, *args)

    def get_n_parameters(self):
        """get_n_parameters(plLearnSparseHistogram self) -> unsigned int"""
        return _pypl.plLearnSparseHistogram_get_n_parameters(self)

    def clone(self):
        """clone(plLearnSparseHistogram self) -> plLearnObject"""
        return _pypl.plLearnSparseHistogram_clone(self)

plLearnSparseHistogram_swigregister = _pypl.plLearnSparseHistogram_swigregister
plLearnSparseHistogram_swigregister(plLearnSparseHistogram)

class plLearnLinearRegression(plLearnCndObject):
    """Proxy of C++ plLearnLinearRegression class"""
    __swig_setmethods__ = {}
    for _s in [plLearnCndObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearnLinearRegression, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnCndObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLearnLinearRegression, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plLearnLinearRegression self, plSymbol left_var, plVariablesConjunction right_vars, plFloat regression_std_deviation=-1.0, 
            plFloat inv_threshold=0.001) -> plLearnLinearRegression
        __init__(plLearnLinearRegression self, plSymbol left_var, plVariablesConjunction right_vars, plFloat regression_std_deviation=-1.0) -> plLearnLinearRegression
        __init__(plLearnLinearRegression self, plSymbol left_var, plVariablesConjunction right_vars) -> plLearnLinearRegression
        __init__(plLearnLinearRegression self) -> plLearnLinearRegression
        """
        this = _pypl.new_plLearnLinearRegression(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plLearnLinearRegression
    __del__ = lambda self : None;
    def reset(self):
        """reset(plLearnLinearRegression self)"""
        return _pypl.plLearnLinearRegression_reset(self)

    def get_cnd_distribution(self):
        """get_cnd_distribution(plLearnLinearRegression self) -> plCndDistribution"""
        return _pypl.plLearnLinearRegression_get_cnd_distribution(self)

    def get_n_parameters(self):
        """get_n_parameters(plLearnLinearRegression self) -> unsigned int"""
        return _pypl.plLearnLinearRegression_get_n_parameters(self)

    def clone(self):
        """clone(plLearnLinearRegression self) -> plLearnObject"""
        return _pypl.plLearnLinearRegression_clone(self)

    def get_beta(self):
        """get_beta(plLearnLinearRegression self) -> plFloatVector"""
        return _pypl.plLearnLinearRegression_get_beta(self)

    def get_regression_std_deviation(self):
        """get_regression_std_deviation(plLearnLinearRegression self) -> plFloat"""
        return _pypl.plLearnLinearRegression_get_regression_std_deviation(self)

plLearnLinearRegression_swigregister = _pypl.plLearnLinearRegression_swigregister
plLearnLinearRegression_swigregister(plLearnLinearRegression)

class plLearnLinearRegressionFamily(plLearnCndObject):
    """Proxy of C++ plLearnLinearRegressionFamily class"""
    __swig_setmethods__ = {}
    for _s in [plLearnCndObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearnLinearRegressionFamily, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnCndObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLearnLinearRegressionFamily, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plLearnLinearRegressionFamily self, plSymbol left_var, plVariablesConjunction quantitative_right_vars, plVariablesConjunction categorical_right_vars, 
            plFloat regression_std_deviation=-1.0, plFloat inv_threshold=0.001) -> plLearnLinearRegressionFamily
        __init__(plLearnLinearRegressionFamily self, plSymbol left_var, plVariablesConjunction quantitative_right_vars, plVariablesConjunction categorical_right_vars, 
            plFloat regression_std_deviation=-1.0) -> plLearnLinearRegressionFamily
        __init__(plLearnLinearRegressionFamily self, plSymbol left_var, plVariablesConjunction quantitative_right_vars, plVariablesConjunction categorical_right_vars) -> plLearnLinearRegressionFamily
        __init__(plLearnLinearRegressionFamily self) -> plLearnLinearRegressionFamily
        """
        this = _pypl.new_plLearnLinearRegressionFamily(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plLearnLinearRegressionFamily
    __del__ = lambda self : None;
    def reset(self):
        """reset(plLearnLinearRegressionFamily self)"""
        return _pypl.plLearnLinearRegressionFamily_reset(self)

    def get_cnd_distribution(self):
        """get_cnd_distribution(plLearnLinearRegressionFamily self) -> plCndDistribution"""
        return _pypl.plLearnLinearRegressionFamily_get_cnd_distribution(self)

    def get_n_parameters(self):
        """get_n_parameters(plLearnLinearRegressionFamily self) -> unsigned int"""
        return _pypl.plLearnLinearRegressionFamily_get_n_parameters(self)

    def clone(self):
        """clone(plLearnLinearRegressionFamily self) -> plLearnObject"""
        return _pypl.plLearnLinearRegressionFamily_clone(self)

plLearnLinearRegressionFamily_swigregister = _pypl.plLearnLinearRegressionFamily_swigregister
plLearnLinearRegressionFamily_swigregister(plLearnLinearRegressionFamily)

class plLearnNoisyOR(plLearnCndObject):
    """Proxy of C++ plLearnNoisyOR class"""
    __swig_setmethods__ = {}
    for _s in [plLearnCndObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearnNoisyOR, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnCndObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLearnNoisyOR, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plLearnNoisyOR self, plSymbol left_binary_var, plVariablesConjunction right_vars, unsigned int n_em_it) -> plLearnNoisyOR
        __init__(plLearnNoisyOR self) -> plLearnNoisyOR
        """
        this = _pypl.new_plLearnNoisyOR(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plLearnNoisyOR
    __del__ = lambda self : None;
    def reset(self):
        """reset(plLearnNoisyOR self)"""
        return _pypl.plLearnNoisyOR_reset(self)

    def get_cnd_distribution(self):
        """get_cnd_distribution(plLearnNoisyOR self) -> plCndDistribution"""
        return _pypl.plLearnNoisyOR_get_cnd_distribution(self)

    def get_n_parameters(self):
        """get_n_parameters(plLearnNoisyOR self) -> unsigned int"""
        return _pypl.plLearnNoisyOR_get_n_parameters(self)

    def clone(self):
        """clone(plLearnNoisyOR self) -> plLearnObject"""
        return _pypl.plLearnNoisyOR_clone(self)

plLearnNoisyOR_swigregister = _pypl.plLearnNoisyOR_swigregister
plLearnNoisyOR_swigregister(plLearnNoisyOR)

class plLearnSoftmax(plLearnCndObject):
    """Proxy of C++ plLearnSoftmax class"""
    __swig_setmethods__ = {}
    for _s in [plLearnCndObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearnSoftmax, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnCndObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLearnSoftmax, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plLearnSoftmax self, plSymbol left_var, plVariablesConjunction right_vars, plFloat conv_threshold=0.00001, 
            plFloat inv_threshold=0.001) -> plLearnSoftmax
        __init__(plLearnSoftmax self, plSymbol left_var, plVariablesConjunction right_vars, plFloat conv_threshold=0.00001) -> plLearnSoftmax
        __init__(plLearnSoftmax self, plSymbol left_var, plVariablesConjunction right_vars) -> plLearnSoftmax
        __init__(plLearnSoftmax self) -> plLearnSoftmax
        """
        this = _pypl.new_plLearnSoftmax(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plLearnSoftmax
    __del__ = lambda self : None;
    def reset(self):
        """reset(plLearnSoftmax self)"""
        return _pypl.plLearnSoftmax_reset(self)

    def get_cnd_distribution(self):
        """get_cnd_distribution(plLearnSoftmax self) -> plCndDistribution"""
        return _pypl.plLearnSoftmax_get_cnd_distribution(self)

    def get_n_parameters(self):
        """get_n_parameters(plLearnSoftmax self) -> unsigned int"""
        return _pypl.plLearnSoftmax_get_n_parameters(self)

    def clone(self):
        """clone(plLearnSoftmax self) -> plLearnObject"""
        return _pypl.plLearnSoftmax_clone(self)

plLearnSoftmax_swigregister = _pypl.plLearnSoftmax_swigregister
plLearnSoftmax_swigregister(plLearnSoftmax)

class plLearnSoftmaxFamily(plLearnCndObject):
    """Proxy of C++ plLearnSoftmaxFamily class"""
    __swig_setmethods__ = {}
    for _s in [plLearnCndObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plLearnSoftmaxFamily, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnCndObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plLearnSoftmaxFamily, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plLearnSoftmaxFamily self, plSymbol left_var, plVariablesConjunction quantitative_right_vars, plVariablesConjunction categorical_right_vars, 
            plFloat conv_threshold=0.00001, plFloat inv_threshold=0.001) -> plLearnSoftmaxFamily
        __init__(plLearnSoftmaxFamily self, plSymbol left_var, plVariablesConjunction quantitative_right_vars, plVariablesConjunction categorical_right_vars, 
            plFloat conv_threshold=0.00001) -> plLearnSoftmaxFamily
        __init__(plLearnSoftmaxFamily self, plSymbol left_var, plVariablesConjunction quantitative_right_vars, plVariablesConjunction categorical_right_vars) -> plLearnSoftmaxFamily
        __init__(plLearnSoftmaxFamily self) -> plLearnSoftmaxFamily
        """
        this = _pypl.new_plLearnSoftmaxFamily(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plLearnSoftmaxFamily
    __del__ = lambda self : None;
    def reset(self):
        """reset(plLearnSoftmaxFamily self)"""
        return _pypl.plLearnSoftmaxFamily_reset(self)

    def get_cnd_distribution(self):
        """get_cnd_distribution(plLearnSoftmaxFamily self) -> plCndDistribution"""
        return _pypl.plLearnSoftmaxFamily_get_cnd_distribution(self)

    def get_n_parameters(self):
        """get_n_parameters(plLearnSoftmaxFamily self) -> unsigned int"""
        return _pypl.plLearnSoftmaxFamily_get_n_parameters(self)

    def clone(self):
        """clone(plLearnSoftmaxFamily self) -> plLearnObject"""
        return _pypl.plLearnSoftmaxFamily_clone(self)

plLearnSoftmaxFamily_swigregister = _pypl.plLearnSoftmaxFamily_swigregister
plLearnSoftmaxFamily_swigregister(plLearnSoftmaxFamily)

class plCndBayesLearn1dNormalWithKnownMean(plLearnDistributionTable):
    """Proxy of C++ plCndLearnObject<(plBayesLearn1dNormalWithKnownMean)> class"""
    __swig_setmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndBayesLearn1dNormalWithKnownMean, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndBayesLearn1dNormalWithKnownMean, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCndLearnObject<(plBayesLearn1dNormalWithKnownMean)> self) -> plCndBayesLearn1dNormalWithKnownMean
        __init__(plCndLearnObject<(plBayesLearn1dNormalWithKnownMean)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars, plBayesLearn1dNormalWithKnownMean init_object=plBayesLearn1dNormalWithKnownMean()) -> plCndBayesLearn1dNormalWithKnownMean
        __init__(plCndLearnObject<(plBayesLearn1dNormalWithKnownMean)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars) -> plCndBayesLearn1dNormalWithKnownMean
        """
        this = _pypl.new_plCndBayesLearn1dNormalWithKnownMean(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_learnt_object_for_value(self, *args):
        """get_learnt_object_for_value(plCndBayesLearn1dNormalWithKnownMean self, plValues right_value) -> plBayesLearn1dNormalWithKnownMean"""
        return _pypl.plCndBayesLearn1dNormalWithKnownMean_get_learnt_object_for_value(self, *args)

    def clone(self):
        """clone(plCndBayesLearn1dNormalWithKnownMean self) -> plLearnObject"""
        return _pypl.plCndBayesLearn1dNormalWithKnownMean_clone(self)

    __swig_destroy__ = _pypl.delete_plCndBayesLearn1dNormalWithKnownMean
    __del__ = lambda self : None;
plCndBayesLearn1dNormalWithKnownMean_swigregister = _pypl.plCndBayesLearn1dNormalWithKnownMean_swigregister
plCndBayesLearn1dNormalWithKnownMean_swigregister(plCndBayesLearn1dNormalWithKnownMean)

class plCndBayesLearn1dNormalWithKnownStandardDeviation(plLearnDistributionTable):
    """Proxy of C++ plCndLearnObject<(plBayesLearn1dNormalWithKnownStandardDeviation)> class"""
    __swig_setmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndBayesLearn1dNormalWithKnownStandardDeviation, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndBayesLearn1dNormalWithKnownStandardDeviation, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCndLearnObject<(plBayesLearn1dNormalWithKnownStandardDeviation)> self) -> plCndBayesLearn1dNormalWithKnownStandardDeviation
        __init__(plCndLearnObject<(plBayesLearn1dNormalWithKnownStandardDeviation)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars, plBayesLearn1dNormalWithKnownStandardDeviation init_object=plBayesLearn1dNormalWithKnownStandardDeviation()) -> plCndBayesLearn1dNormalWithKnownStandardDeviation
        __init__(plCndLearnObject<(plBayesLearn1dNormalWithKnownStandardDeviation)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars) -> plCndBayesLearn1dNormalWithKnownStandardDeviation
        """
        this = _pypl.new_plCndBayesLearn1dNormalWithKnownStandardDeviation(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_learnt_object_for_value(self, *args):
        """get_learnt_object_for_value(plCndBayesLearn1dNormalWithKnownStandardDeviation self, plValues right_value) -> plBayesLearn1dNormalWithKnownStandardDeviation"""
        return _pypl.plCndBayesLearn1dNormalWithKnownStandardDeviation_get_learnt_object_for_value(self, *args)

    def clone(self):
        """clone(plCndBayesLearn1dNormalWithKnownStandardDeviation self) -> plLearnObject"""
        return _pypl.plCndBayesLearn1dNormalWithKnownStandardDeviation_clone(self)

    __swig_destroy__ = _pypl.delete_plCndBayesLearn1dNormalWithKnownStandardDeviation
    __del__ = lambda self : None;
plCndBayesLearn1dNormalWithKnownStandardDeviation_swigregister = _pypl.plCndBayesLearn1dNormalWithKnownStandardDeviation_swigregister
plCndBayesLearn1dNormalWithKnownStandardDeviation_swigregister(plCndBayesLearn1dNormalWithKnownStandardDeviation)

class plCndBayesLearnBinomial(plLearnDistributionTable):
    """Proxy of C++ plCndLearnObject<(plBayesLearnBinomial)> class"""
    __swig_setmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndBayesLearnBinomial, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndBayesLearnBinomial, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCndLearnObject<(plBayesLearnBinomial)> self) -> plCndBayesLearnBinomial
        __init__(plCndLearnObject<(plBayesLearnBinomial)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars, plBayesLearnBinomial init_object=plBayesLearnBinomial()) -> plCndBayesLearnBinomial
        __init__(plCndLearnObject<(plBayesLearnBinomial)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars) -> plCndBayesLearnBinomial
        """
        this = _pypl.new_plCndBayesLearnBinomial(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_learnt_object_for_value(self, *args):
        """get_learnt_object_for_value(plCndBayesLearnBinomial self, plValues right_value) -> plBayesLearnBinomial"""
        return _pypl.plCndBayesLearnBinomial_get_learnt_object_for_value(self, *args)

    def clone(self):
        """clone(plCndBayesLearnBinomial self) -> plLearnObject"""
        return _pypl.plCndBayesLearnBinomial_clone(self)

    __swig_destroy__ = _pypl.delete_plCndBayesLearnBinomial
    __del__ = lambda self : None;
plCndBayesLearnBinomial_swigregister = _pypl.plCndBayesLearnBinomial_swigregister
plCndBayesLearnBinomial_swigregister(plCndBayesLearnBinomial)

class plCndBayesLearnExponential(plLearnDistributionTable):
    """Proxy of C++ plCndLearnObject<(plBayesLearnExponential)> class"""
    __swig_setmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndBayesLearnExponential, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndBayesLearnExponential, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCndLearnObject<(plBayesLearnExponential)> self) -> plCndBayesLearnExponential
        __init__(plCndLearnObject<(plBayesLearnExponential)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars, plBayesLearnExponential init_object=plBayesLearnExponential()) -> plCndBayesLearnExponential
        __init__(plCndLearnObject<(plBayesLearnExponential)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars) -> plCndBayesLearnExponential
        """
        this = _pypl.new_plCndBayesLearnExponential(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_learnt_object_for_value(self, *args):
        """get_learnt_object_for_value(plCndBayesLearnExponential self, plValues right_value) -> plBayesLearnExponential"""
        return _pypl.plCndBayesLearnExponential_get_learnt_object_for_value(self, *args)

    def clone(self):
        """clone(plCndBayesLearnExponential self) -> plLearnObject"""
        return _pypl.plCndBayesLearnExponential_clone(self)

    __swig_destroy__ = _pypl.delete_plCndBayesLearnExponential
    __del__ = lambda self : None;
plCndBayesLearnExponential_swigregister = _pypl.plCndBayesLearnExponential_swigregister
plCndBayesLearnExponential_swigregister(plCndBayesLearnExponential)

class plCndBayesLearnGamma(plLearnDistributionTable):
    """Proxy of C++ plCndLearnObject<(plBayesLearnGamma)> class"""
    __swig_setmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndBayesLearnGamma, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndBayesLearnGamma, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCndLearnObject<(plBayesLearnGamma)> self) -> plCndBayesLearnGamma
        __init__(plCndLearnObject<(plBayesLearnGamma)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars, plBayesLearnGamma init_object=plBayesLearnGamma()) -> plCndBayesLearnGamma
        __init__(plCndLearnObject<(plBayesLearnGamma)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars) -> plCndBayesLearnGamma
        """
        this = _pypl.new_plCndBayesLearnGamma(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_learnt_object_for_value(self, *args):
        """get_learnt_object_for_value(plCndBayesLearnGamma self, plValues right_value) -> plBayesLearnGamma"""
        return _pypl.plCndBayesLearnGamma_get_learnt_object_for_value(self, *args)

    def clone(self):
        """clone(plCndBayesLearnGamma self) -> plLearnObject"""
        return _pypl.plCndBayesLearnGamma_clone(self)

    __swig_destroy__ = _pypl.delete_plCndBayesLearnGamma
    __del__ = lambda self : None;
plCndBayesLearnGamma_swigregister = _pypl.plCndBayesLearnGamma_swigregister
plCndBayesLearnGamma_swigregister(plCndBayesLearnGamma)

class plCndBayesLearnLogNormalWithKnownShape(plLearnDistributionTable):
    """Proxy of C++ plCndLearnObject<(plBayesLearnLogNormalWithKnownShape)> class"""
    __swig_setmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndBayesLearnLogNormalWithKnownShape, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndBayesLearnLogNormalWithKnownShape, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCndLearnObject<(plBayesLearnLogNormalWithKnownShape)> self) -> plCndBayesLearnLogNormalWithKnownShape
        __init__(plCndLearnObject<(plBayesLearnLogNormalWithKnownShape)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars, plBayesLearnLogNormalWithKnownShape init_object=plBayesLearnLogNormalWithKnownShape()) -> plCndBayesLearnLogNormalWithKnownShape
        __init__(plCndLearnObject<(plBayesLearnLogNormalWithKnownShape)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars) -> plCndBayesLearnLogNormalWithKnownShape
        """
        this = _pypl.new_plCndBayesLearnLogNormalWithKnownShape(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_learnt_object_for_value(self, *args):
        """get_learnt_object_for_value(plCndBayesLearnLogNormalWithKnownShape self, plValues right_value) -> plBayesLearnLogNormalWithKnownShape"""
        return _pypl.plCndBayesLearnLogNormalWithKnownShape_get_learnt_object_for_value(self, *args)

    def clone(self):
        """clone(plCndBayesLearnLogNormalWithKnownShape self) -> plLearnObject"""
        return _pypl.plCndBayesLearnLogNormalWithKnownShape_clone(self)

    __swig_destroy__ = _pypl.delete_plCndBayesLearnLogNormalWithKnownShape
    __del__ = lambda self : None;
plCndBayesLearnLogNormalWithKnownShape_swigregister = _pypl.plCndBayesLearnLogNormalWithKnownShape_swigregister
plCndBayesLearnLogNormalWithKnownShape_swigregister(plCndBayesLearnLogNormalWithKnownShape)

class plCndBayesLearnNdNormalWithKnownVariance(plLearnDistributionTable):
    """Proxy of C++ plCndLearnObject<(plBayesLearnNdNormalWithKnownVariance)> class"""
    __swig_setmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndBayesLearnNdNormalWithKnownVariance, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndBayesLearnNdNormalWithKnownVariance, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCndLearnObject<(plBayesLearnNdNormalWithKnownVariance)> self) -> plCndBayesLearnNdNormalWithKnownVariance
        __init__(plCndLearnObject<(plBayesLearnNdNormalWithKnownVariance)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars, plBayesLearnNdNormalWithKnownVariance init_object=plBayesLearnNdNormalWithKnownVariance()) -> plCndBayesLearnNdNormalWithKnownVariance
        __init__(plCndLearnObject<(plBayesLearnNdNormalWithKnownVariance)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars) -> plCndBayesLearnNdNormalWithKnownVariance
        """
        this = _pypl.new_plCndBayesLearnNdNormalWithKnownVariance(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_learnt_object_for_value(self, *args):
        """get_learnt_object_for_value(plCndBayesLearnNdNormalWithKnownVariance self, plValues right_value) -> plBayesLearnNdNormalWithKnownVariance"""
        return _pypl.plCndBayesLearnNdNormalWithKnownVariance_get_learnt_object_for_value(self, *args)

    def clone(self):
        """clone(plCndBayesLearnNdNormalWithKnownVariance self) -> plLearnObject"""
        return _pypl.plCndBayesLearnNdNormalWithKnownVariance_clone(self)

    __swig_destroy__ = _pypl.delete_plCndBayesLearnNdNormalWithKnownVariance
    __del__ = lambda self : None;
plCndBayesLearnNdNormalWithKnownVariance_swigregister = _pypl.plCndBayesLearnNdNormalWithKnownVariance_swigregister
plCndBayesLearnNdNormalWithKnownVariance_swigregister(plCndBayesLearnNdNormalWithKnownVariance)

class plCndBayesLearnPoisson(plLearnDistributionTable):
    """Proxy of C++ plCndLearnObject<(plBayesLearnPoisson)> class"""
    __swig_setmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndBayesLearnPoisson, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndBayesLearnPoisson, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCndLearnObject<(plBayesLearnPoisson)> self) -> plCndBayesLearnPoisson
        __init__(plCndLearnObject<(plBayesLearnPoisson)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars, plBayesLearnPoisson init_object=plBayesLearnPoisson()) -> plCndBayesLearnPoisson
        __init__(plCndLearnObject<(plBayesLearnPoisson)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars) -> plCndBayesLearnPoisson
        """
        this = _pypl.new_plCndBayesLearnPoisson(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_learnt_object_for_value(self, *args):
        """get_learnt_object_for_value(plCndBayesLearnPoisson self, plValues right_value) -> plBayesLearnPoisson"""
        return _pypl.plCndBayesLearnPoisson_get_learnt_object_for_value(self, *args)

    def clone(self):
        """clone(plCndBayesLearnPoisson self) -> plLearnObject"""
        return _pypl.plCndBayesLearnPoisson_clone(self)

    __swig_destroy__ = _pypl.delete_plCndBayesLearnPoisson
    __del__ = lambda self : None;
plCndBayesLearnPoisson_swigregister = _pypl.plCndBayesLearnPoisson_swigregister
plCndBayesLearnPoisson_swigregister(plCndBayesLearnPoisson)

class plCndBayesLearnProbTable(plLearnDistributionTable):
    """Proxy of C++ plCndLearnObject<(plBayesLearnProbTable)> class"""
    __swig_setmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndBayesLearnProbTable, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndBayesLearnProbTable, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCndLearnObject<(plBayesLearnProbTable)> self) -> plCndBayesLearnProbTable
        __init__(plCndLearnObject<(plBayesLearnProbTable)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars, plBayesLearnProbTable init_object=plBayesLearnProbTable()) -> plCndBayesLearnProbTable
        __init__(plCndLearnObject<(plBayesLearnProbTable)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars) -> plCndBayesLearnProbTable
        """
        this = _pypl.new_plCndBayesLearnProbTable(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_learnt_object_for_value(self, *args):
        """get_learnt_object_for_value(plCndBayesLearnProbTable self, plValues right_value) -> plBayesLearnProbTable"""
        return _pypl.plCndBayesLearnProbTable_get_learnt_object_for_value(self, *args)

    def clone(self):
        """clone(plCndBayesLearnProbTable self) -> plLearnObject"""
        return _pypl.plCndBayesLearnProbTable_clone(self)

    __swig_destroy__ = _pypl.delete_plCndBayesLearnProbTable
    __del__ = lambda self : None;
plCndBayesLearnProbTable_swigregister = _pypl.plCndBayesLearnProbTable_swigregister
plCndBayesLearnProbTable_swigregister(plCndBayesLearnProbTable)

class plCndLearn1dNormal(plLearnDistributionTable):
    """Proxy of C++ plCndLearnObject<(plLearn1dNormal)> class"""
    __swig_setmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndLearn1dNormal, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndLearn1dNormal, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCndLearnObject<(plLearn1dNormal)> self) -> plCndLearn1dNormal
        __init__(plCndLearnObject<(plLearn1dNormal)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars, plLearn1dNormal init_object=plLearn1dNormal()) -> plCndLearn1dNormal
        __init__(plCndLearnObject<(plLearn1dNormal)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars) -> plCndLearn1dNormal
        """
        this = _pypl.new_plCndLearn1dNormal(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_learnt_object_for_value(self, *args):
        """get_learnt_object_for_value(plCndLearn1dNormal self, plValues right_value) -> plLearn1dNormal"""
        return _pypl.plCndLearn1dNormal_get_learnt_object_for_value(self, *args)

    def clone(self):
        """clone(plCndLearn1dNormal self) -> plLearnObject"""
        return _pypl.plCndLearn1dNormal_clone(self)

    __swig_destroy__ = _pypl.delete_plCndLearn1dNormal
    __del__ = lambda self : None;
plCndLearn1dNormal_swigregister = _pypl.plCndLearn1dNormal_swigregister
plCndLearn1dNormal_swigregister(plCndLearn1dNormal)

class plCndLearnExponential(plLearnDistributionTable):
    """Proxy of C++ plCndLearnObject<(plLearnExponential)> class"""
    __swig_setmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndLearnExponential, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndLearnExponential, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCndLearnObject<(plLearnExponential)> self) -> plCndLearnExponential
        __init__(plCndLearnObject<(plLearnExponential)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars, plLearnExponential init_object=plLearnExponential()) -> plCndLearnExponential
        __init__(plCndLearnObject<(plLearnExponential)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars) -> plCndLearnExponential
        """
        this = _pypl.new_plCndLearnExponential(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_learnt_object_for_value(self, *args):
        """get_learnt_object_for_value(plCndLearnExponential self, plValues right_value) -> plLearnExponential"""
        return _pypl.plCndLearnExponential_get_learnt_object_for_value(self, *args)

    def clone(self):
        """clone(plCndLearnExponential self) -> plLearnObject"""
        return _pypl.plCndLearnExponential_clone(self)

    __swig_destroy__ = _pypl.delete_plCndLearnExponential
    __del__ = lambda self : None;
plCndLearnExponential_swigregister = _pypl.plCndLearnExponential_swigregister
plCndLearnExponential_swigregister(plCndLearnExponential)

class plCndLearnGamma(plLearnDistributionTable):
    """Proxy of C++ plCndLearnObject<(plLearnGamma)> class"""
    __swig_setmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndLearnGamma, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndLearnGamma, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCndLearnObject<(plLearnGamma)> self) -> plCndLearnGamma
        __init__(plCndLearnObject<(plLearnGamma)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars, plLearnGamma init_object=plLearnGamma()) -> plCndLearnGamma
        __init__(plCndLearnObject<(plLearnGamma)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars) -> plCndLearnGamma
        """
        this = _pypl.new_plCndLearnGamma(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_learnt_object_for_value(self, *args):
        """get_learnt_object_for_value(plCndLearnGamma self, plValues right_value) -> plLearnGamma"""
        return _pypl.plCndLearnGamma_get_learnt_object_for_value(self, *args)

    def clone(self):
        """clone(plCndLearnGamma self) -> plLearnObject"""
        return _pypl.plCndLearnGamma_clone(self)

    __swig_destroy__ = _pypl.delete_plCndLearnGamma
    __del__ = lambda self : None;
plCndLearnGamma_swigregister = _pypl.plCndLearnGamma_swigregister
plCndLearnGamma_swigregister(plCndLearnGamma)

class plCndLearnHistogram(plLearnDistributionTable):
    """Proxy of C++ plCndLearnObject<(plLearnHistogram)> class"""
    __swig_setmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndLearnHistogram, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndLearnHistogram, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCndLearnObject<(plLearnHistogram)> self) -> plCndLearnHistogram
        __init__(plCndLearnObject<(plLearnHistogram)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars, plLearnHistogram init_object=plLearnHistogram()) -> plCndLearnHistogram
        __init__(plCndLearnObject<(plLearnHistogram)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars) -> plCndLearnHistogram
        """
        this = _pypl.new_plCndLearnHistogram(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_learnt_object_for_value(self, *args):
        """get_learnt_object_for_value(plCndLearnHistogram self, plValues right_value) -> plLearnHistogram"""
        return _pypl.plCndLearnHistogram_get_learnt_object_for_value(self, *args)

    def clone(self):
        """clone(plCndLearnHistogram self) -> plLearnObject"""
        return _pypl.plCndLearnHistogram_clone(self)

    __swig_destroy__ = _pypl.delete_plCndLearnHistogram
    __del__ = lambda self : None;
plCndLearnHistogram_swigregister = _pypl.plCndLearnHistogram_swigregister
plCndLearnHistogram_swigregister(plCndLearnHistogram)

class plCndLearnLaplace(plLearnDistributionTable):
    """Proxy of C++ plCndLearnObject<(plLearnLaplace)> class"""
    __swig_setmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndLearnLaplace, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndLearnLaplace, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCndLearnObject<(plLearnLaplace)> self) -> plCndLearnLaplace
        __init__(plCndLearnObject<(plLearnLaplace)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars, plLearnLaplace init_object=plLearnLaplace()) -> plCndLearnLaplace
        __init__(plCndLearnObject<(plLearnLaplace)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars) -> plCndLearnLaplace
        """
        this = _pypl.new_plCndLearnLaplace(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_learnt_object_for_value(self, *args):
        """get_learnt_object_for_value(plCndLearnLaplace self, plValues right_value) -> plLearnLaplace"""
        return _pypl.plCndLearnLaplace_get_learnt_object_for_value(self, *args)

    def clone(self):
        """clone(plCndLearnLaplace self) -> plLearnObject"""
        return _pypl.plCndLearnLaplace_clone(self)

    __swig_destroy__ = _pypl.delete_plCndLearnLaplace
    __del__ = lambda self : None;
plCndLearnLaplace_swigregister = _pypl.plCndLearnLaplace_swigregister
plCndLearnLaplace_swigregister(plCndLearnLaplace)

class plCndLearnLidstone(plLearnDistributionTable):
    """Proxy of C++ plCndLearnObject<(plLearnLidstone)> class"""
    __swig_setmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndLearnLidstone, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndLearnLidstone, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCndLearnObject<(plLearnLidstone)> self) -> plCndLearnLidstone
        __init__(plCndLearnObject<(plLearnLidstone)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars, plLearnLidstone init_object=plLearnLidstone()) -> plCndLearnLidstone
        __init__(plCndLearnObject<(plLearnLidstone)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars) -> plCndLearnLidstone
        """
        this = _pypl.new_plCndLearnLidstone(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_learnt_object_for_value(self, *args):
        """get_learnt_object_for_value(plCndLearnLidstone self, plValues right_value) -> plLearnLidstone"""
        return _pypl.plCndLearnLidstone_get_learnt_object_for_value(self, *args)

    def clone(self):
        """clone(plCndLearnLidstone self) -> plLearnObject"""
        return _pypl.plCndLearnLidstone_clone(self)

    __swig_destroy__ = _pypl.delete_plCndLearnLidstone
    __del__ = lambda self : None;
plCndLearnLidstone_swigregister = _pypl.plCndLearnLidstone_swigregister
plCndLearnLidstone_swigregister(plCndLearnLidstone)

class plCndLearnLogNormal(plLearnDistributionTable):
    """Proxy of C++ plCndLearnObject<(plLearnLogNormal)> class"""
    __swig_setmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndLearnLogNormal, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndLearnLogNormal, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCndLearnObject<(plLearnLogNormal)> self) -> plCndLearnLogNormal
        __init__(plCndLearnObject<(plLearnLogNormal)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars, plLearnLogNormal init_object=plLearnLogNormal()) -> plCndLearnLogNormal
        __init__(plCndLearnObject<(plLearnLogNormal)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars) -> plCndLearnLogNormal
        """
        this = _pypl.new_plCndLearnLogNormal(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_learnt_object_for_value(self, *args):
        """get_learnt_object_for_value(plCndLearnLogNormal self, plValues right_value) -> plLearnLogNormal"""
        return _pypl.plCndLearnLogNormal_get_learnt_object_for_value(self, *args)

    def clone(self):
        """clone(plCndLearnLogNormal self) -> plLearnObject"""
        return _pypl.plCndLearnLogNormal_clone(self)

    __swig_destroy__ = _pypl.delete_plCndLearnLogNormal
    __del__ = lambda self : None;
plCndLearnLogNormal_swigregister = _pypl.plCndLearnLogNormal_swigregister
plCndLearnLogNormal_swigregister(plCndLearnLogNormal)

class plCndLearnNdNormal(plLearnDistributionTable):
    """Proxy of C++ plCndLearnObject<(plLearnNdNormal)> class"""
    __swig_setmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndLearnNdNormal, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndLearnNdNormal, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCndLearnObject<(plLearnNdNormal)> self) -> plCndLearnNdNormal
        __init__(plCndLearnObject<(plLearnNdNormal)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars, plLearnNdNormal init_object=plLearnNdNormal()) -> plCndLearnNdNormal
        __init__(plCndLearnObject<(plLearnNdNormal)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars) -> plCndLearnNdNormal
        """
        this = _pypl.new_plCndLearnNdNormal(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_learnt_object_for_value(self, *args):
        """get_learnt_object_for_value(plCndLearnNdNormal self, plValues right_value) -> plLearnNdNormal"""
        return _pypl.plCndLearnNdNormal_get_learnt_object_for_value(self, *args)

    def clone(self):
        """clone(plCndLearnNdNormal self) -> plLearnObject"""
        return _pypl.plCndLearnNdNormal_clone(self)

    __swig_destroy__ = _pypl.delete_plCndLearnNdNormal
    __del__ = lambda self : None;
plCndLearnNdNormal_swigregister = _pypl.plCndLearnNdNormal_swigregister
plCndLearnNdNormal_swigregister(plCndLearnNdNormal)

class plCndLearnPoisson(plLearnDistributionTable):
    """Proxy of C++ plCndLearnObject<(plLearnPoisson)> class"""
    __swig_setmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndLearnPoisson, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndLearnPoisson, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCndLearnObject<(plLearnPoisson)> self) -> plCndLearnPoisson
        __init__(plCndLearnObject<(plLearnPoisson)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars, plLearnPoisson init_object=plLearnPoisson()) -> plCndLearnPoisson
        __init__(plCndLearnObject<(plLearnPoisson)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars) -> plCndLearnPoisson
        """
        this = _pypl.new_plCndLearnPoisson(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_learnt_object_for_value(self, *args):
        """get_learnt_object_for_value(plCndLearnPoisson self, plValues right_value) -> plLearnPoisson"""
        return _pypl.plCndLearnPoisson_get_learnt_object_for_value(self, *args)

    def clone(self):
        """clone(plCndLearnPoisson self) -> plLearnObject"""
        return _pypl.plCndLearnPoisson_clone(self)

    __swig_destroy__ = _pypl.delete_plCndLearnPoisson
    __del__ = lambda self : None;
plCndLearnPoisson_swigregister = _pypl.plCndLearnPoisson_swigregister
plCndLearnPoisson_swigregister(plCndLearnPoisson)

class plCndLearnSparseHistogram(plLearnDistributionTable):
    """Proxy of C++ plCndLearnObject<(plLearnSparseHistogram)> class"""
    __swig_setmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plCndLearnSparseHistogram, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearnDistributionTable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plCndLearnSparseHistogram, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plCndLearnObject<(plLearnSparseHistogram)> self) -> plCndLearnSparseHistogram
        __init__(plCndLearnObject<(plLearnSparseHistogram)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars, plLearnSparseHistogram init_object=plLearnSparseHistogram()) -> plCndLearnSparseHistogram
        __init__(plCndLearnObject<(plLearnSparseHistogram)> self, plVariablesConjunction left_vars, plVariablesConjunction right_vars) -> plCndLearnSparseHistogram
        """
        this = _pypl.new_plCndLearnSparseHistogram(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_learnt_object_for_value(self, *args):
        """get_learnt_object_for_value(plCndLearnSparseHistogram self, plValues right_value) -> plLearnSparseHistogram"""
        return _pypl.plCndLearnSparseHistogram_get_learnt_object_for_value(self, *args)

    def clone(self):
        """clone(plCndLearnSparseHistogram self) -> plLearnObject"""
        return _pypl.plCndLearnSparseHistogram_clone(self)

    __swig_destroy__ = _pypl.delete_plCndLearnSparseHistogram
    __del__ = lambda self : None;
plCndLearnSparseHistogram_swigregister = _pypl.plCndLearnSparseHistogram_swigregister
plCndLearnSparseHistogram_swigregister(plCndLearnSparseHistogram)

class plEMLearner(plLearner):
    """Proxy of C++ plEMLearner class"""
    __swig_setmethods__ = {}
    for _s in [plLearner]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plEMLearner, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearner]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plEMLearner, name)
    __repr__ = _swig_repr
    def assign_from(self, *args):
        """assign_from(plEMLearner self, plEMLearner other) -> plEMLearner"""
        return _pypl.plEMLearner_assign_from(self, *args)

    def __init__(self, *args): 
        """
        __init__(plEMLearner self, plComputableObjectList init_distribs, plLearnObjectVector learn_objects) -> plEMLearner
        __init__(plEMLearner self, plLearnObjectVector learn_objects) -> plEMLearner
        __init__(plEMLearner self, plEMLearner other) -> plEMLearner
        __init__(plEMLearner self, plVariablesConjunction data_descriptor_vars, plLearnObjectVector learn_objects) -> plEMLearner
        __init__(plEMLearner self, plVariablesConjunction data_descriptor_vars, plComputableObjectList init_distribs, 
            plLearnObjectVector learn_objects) -> plEMLearner
        __init__(plEMLearner self) -> plEMLearner
        """
        this = _pypl.new_plEMLearner(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plEMLearner
    __del__ = lambda self : None;
    def reset(self):
        """reset(plEMLearner self)"""
        return _pypl.plEMLearner_reset(self)

    def run(self, *args):
        """
        run(plEMLearner self, plDataDescriptor data_descriptor, unsigned int nit)
        run(plEMLearner self, plDataDescriptor data_descriptor, int nit)
        run(plEMLearner self, plDataDescriptor data_descriptor, double convergence_loglikelihood_threshold=0.0001, 
            unsigned int max_it=std::numeric_limits< unsigned int >::max()) -> unsigned int
        run(plEMLearner self, plDataDescriptor data_descriptor, double convergence_loglikelihood_threshold=0.0001) -> unsigned int
        run(plEMLearner self, plDataDescriptor data_descriptor) -> unsigned int
        run(plEMLearner self, plDataDescriptor data_descriptor, unsigned int nit, plValuesVector missing_most_probable_value, 
            DoubleVectorVector missing_probability_table)
        """
        return _pypl.plEMLearner_run(self, *args)

    def get_distribution(self, *args):
        """get_distribution(plEMLearner self, unsigned int n) -> plComputableObject"""
        return _pypl.plEMLearner_get_distribution(self, *args)

    def set_distribution(self, *args):
        """set_distribution(plEMLearner self, unsigned int n, plComputableObject new_distrib)"""
        return _pypl.plEMLearner_set_distribution(self, *args)

    def get_joint_distribution(self):
        """get_joint_distribution(plEMLearner self) -> plJointDistribution"""
        return _pypl.plEMLearner_get_joint_distribution(self)

    def set_same_missing_variables(self, same=True):
        """
        set_same_missing_variables(plEMLearner self, bool same=True)
        set_same_missing_variables(plEMLearner self)
        """
        return _pypl.plEMLearner_set_same_missing_variables(self, same)

    def output_distributions(self):
        """
        output_distributions(plEMLearner self)
        output_distributions(plEMLearner self)
        """
        return _pypl.plEMLearner_output_distributions(self)

    def set_distributions_display(self, display=True):
        """
        set_distributions_display(plEMLearner self, bool display=True)
        set_distributions_display(plEMLearner self)
        """
        return _pypl.plEMLearner_set_distributions_display(self, display)

    def set_distributions_display_stream(self):
        """set_distributions_display_stream(plEMLearner self)"""
        return _pypl.plEMLearner_set_distributions_display_stream(self)

    def distribution_set_frozen(self, *args):
        """
        distribution_set_frozen(plEMLearner self, unsigned int n, bool freeze=True)
        distribution_set_frozen(plEMLearner self, unsigned int n)
        """
        return _pypl.plEMLearner_distribution_set_frozen(self, *args)

    def use_junction_tree(self, use_jt=True):
        """
        use_junction_tree(plEMLearner self, bool use_jt=True)
        use_junction_tree(plEMLearner self)
        """
        return _pypl.plEMLearner_use_junction_tree(self, use_jt)

    def set_mc_integration_npoints(self, *args):
        """set_mc_integration_npoints(plEMLearner self, unsigned int npoints)"""
        return _pypl.plEMLearner_set_mc_integration_npoints(self, *args)

    def set_approximate_compilation_time(self, *args):
        """set_approximate_compilation_time(plEMLearner self, double compilation_time_in_seconds)"""
        return _pypl.plEMLearner_set_approximate_compilation_time(self, *args)

    def set_approximate_compilation_nsamples(self, *args):
        """set_approximate_compilation_nsamples(plEMLearner self, unsigned int n)"""
        return _pypl.plEMLearner_set_approximate_compilation_nsamples(self, *args)

    def set_use_sampling_for_compilation(self, use_it=True):
        """
        set_use_sampling_for_compilation(plEMLearner self, bool use_it=True)
        set_use_sampling_for_compilation(plEMLearner self)
        """
        return _pypl.plEMLearner_set_use_sampling_for_compilation(self, use_it)

    def compute_missing_values_infos(self, *args):
        """compute_missing_values_infos(plEMLearner self, plDataDescriptor data_descriptor, plValuesVector missing_most_probable_value, DoubleVectorVector missing_probability_table)"""
        return _pypl.plEMLearner_compute_missing_values_infos(self, *args)

    def compute_loglikelihood(self, *args):
        """
        compute_loglikelihood(plEMLearner self, plDataDescriptor data_descriptor, DoubleVector data_loglikelihood) -> plFloat
        compute_loglikelihood(plEMLearner self, plDataDescriptor data_descriptor) -> plFloat
        """
        return _pypl.plEMLearner_compute_loglikelihood(self, *args)

    def get_computable_object_list(self):
        """get_computable_object_list(plEMLearner self) -> plComputableObjectList"""
        return _pypl.plEMLearner_get_computable_object_list(self)

    def set_trace_loglikelihood(self, trace_it=True):
        """
        set_trace_loglikelihood(plEMLearner self, bool trace_it=True)
        set_trace_loglikelihood(plEMLearner self)
        """
        return _pypl.plEMLearner_set_trace_loglikelihood(self, trace_it)

    def get_learn_object(self, *args):
        """get_learn_object(plEMLearner self, unsigned int n) -> plLearnObject"""
        return _pypl.plEMLearner_get_learn_object(self, *args)

    def get_learn_objects(self):
        """get_learn_objects(plEMLearner self) -> plLearnObjectVector"""
        return _pypl.plEMLearner_get_learn_objects(self)

    def iteration(self, *args):
        """
        iteration(plEMLearner self, plDataDescriptor data_descriptor)
        iteration(plEMLearner self, plDataDescriptor data_descriptor, plValuesVector missing_most_probable_value, DoubleVectorVector missing_probability_table)
        """
        return _pypl.plEMLearner_iteration(self, *args)

    def get_last_computed_loglikelihood(self):
        """get_last_computed_loglikelihood(plEMLearner self) -> plFloat"""
        return _pypl.plEMLearner_get_last_computed_loglikelihood(self)

    def set_trace_observation_and_inference_info(self, set_it=True):
        """
        set_trace_observation_and_inference_info(plEMLearner self, bool set_it=True)
        set_trace_observation_and_inference_info(plEMLearner self)
        """
        return _pypl.plEMLearner_set_trace_observation_and_inference_info(self, set_it)

    def get_n_parameters(self):
        """get_n_parameters(plEMLearner self) -> unsigned int"""
        return _pypl.plEMLearner_get_n_parameters(self)

plEMLearner_swigregister = _pypl.plEMLearner_swigregister
plEMLearner_swigregister(plEMLearner)

PL_JT = _pypl.PL_JT
PL_SR = _pypl.PL_SR
PL_MI = _pypl.PL_MI
PL_MI_DIST = _pypl.PL_MI_DIST
PL_ENTROPY = _pypl.PL_ENTROPY
PL_BIC = _pypl.PL_BIC
PL_AIC = _pypl.PL_AIC
PL_MDL = _pypl.PL_MDL
class plBayesianNetwork(plObject):
    """Proxy of C++ plBayesianNetwork class"""
    __swig_setmethods__ = {}
    for _s in [plObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plBayesianNetwork, name, value)
    __swig_getmethods__ = {}
    for _s in [plObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plBayesianNetwork, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plBayesianNetwork self, std::string const & name="untitled_BN") -> plBayesianNetwork
        __init__(plBayesianNetwork self) -> plBayesianNetwork
        __init__(plBayesianNetwork self, plJointDistribution joint, std::string const & name="untitled_BN") -> plBayesianNetwork
        __init__(plBayesianNetwork self, plJointDistribution joint) -> plBayesianNetwork
        __init__(plBayesianNetwork self, plBayesianNetwork other) -> plBayesianNetwork
        """
        this = _pypl.new_plBayesianNetwork(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plBayesianNetwork
    __del__ = lambda self : None;
    def assign_from(self, *args):
        """assign_from(plBayesianNetwork self, plBayesianNetwork other) -> plBayesianNetwork"""
        return _pypl.plBayesianNetwork_assign_from(self, *args)

    def add_node(self, *args):
        """
        add_node(plBayesianNetwork self, std::string const & name, plType type)
        add_node(plBayesianNetwork self, plSymbol node)
        """
        return _pypl.plBayesianNetwork_add_node(self, *args)

    def remove_node(self, *args):
        """
        remove_node(plBayesianNetwork self, plSymbol node)
        remove_node(plBayesianNetwork self, std::string const & name)
        """
        return _pypl.plBayesianNetwork_remove_node(self, *args)

    def set_nodes(self, *args):
        """
        set_nodes(plBayesianNetwork self, plVariablesConjunction nodes)
        set_nodes(plBayesianNetwork self, std::vector< plSymbol,std::allocator< plSymbol > > const & nodes)
        """
        return _pypl.plBayesianNetwork_set_nodes(self, *args)

    def add_edge(self, *args):
        """
        add_edge(plBayesianNetwork self, plSymbol source, plSymbol destination)
        add_edge(plBayesianNetwork self, std::string const & source_name, std::string const & destination_name)
        """
        return _pypl.plBayesianNetwork_add_edge(self, *args)

    def remove_edge(self, *args):
        """
        remove_edge(plBayesianNetwork self, plSymbol source, plSymbol destination)
        remove_edge(plBayesianNetwork self, std::string const & source_name, std::string const & destination_name)
        """
        return _pypl.plBayesianNetwork_remove_edge(self, *args)

    def set_distribution(self, *args):
        """
        set_distribution(plBayesianNetwork self, plComputableObject distribution)
        set_distribution(plBayesianNetwork self, plLearnObject learnable_distribution)
        """
        return _pypl.plBayesianNetwork_set_distribution(self, *args)

    def nodes(self):
        """nodes(plBayesianNetwork self) -> plVariablesConjunction"""
        return _pypl.plBayesianNetwork_nodes(self)

    def edges(self):
        """edges(plBayesianNetwork self) -> plBayesianNetwork::bn_edge_list_t"""
        return _pypl.plBayesianNetwork_edges(self)

    def get_n_nodes(self):
        """get_n_nodes(plBayesianNetwork self) -> size_t"""
        return _pypl.plBayesianNetwork_get_n_nodes(self)

    def get_nth_node_name(self, *args):
        """get_nth_node_name(plBayesianNetwork self, unsigned int n) -> std::string"""
        return _pypl.plBayesianNetwork_get_nth_node_name(self, *args)

    def get_node(self, *args):
        """
        get_node(plBayesianNetwork self, unsigned int n) -> plSymbol
        get_node(plBayesianNetwork self, std::string const & node_name) -> plSymbol
        """
        return _pypl.plBayesianNetwork_get_node(self, *args)

    def clear(self):
        """clear(plBayesianNetwork self)"""
        return _pypl.plBayesianNetwork_clear(self)

    def set_evidence(self, *args):
        """
        set_evidence(plBayesianNetwork self, plValues evidence, bool check_validity=True)
        set_evidence(plBayesianNetwork self, plValues evidence)
        """
        return _pypl.plBayesianNetwork_set_evidence(self, *args)

    def add_evidence(self, *args):
        """
        add_evidence(plBayesianNetwork self, plValues added_evidence, bool check_validity=True)
        add_evidence(plBayesianNetwork self, plValues added_evidence)
        """
        return _pypl.plBayesianNetwork_add_evidence(self, *args)

    def get_evidence(self):
        """get_evidence(plBayesianNetwork self) -> plValues"""
        return _pypl.plBayesianNetwork_get_evidence(self)

    def clear_evidence(self):
        """clear_evidence(plBayesianNetwork self)"""
        return _pypl.plBayesianNetwork_clear_evidence(self)

    def learn_parameters(self, *args):
        """
        learn_parameters(plBayesianNetwork self, std::string const & csv_file, int em_iterations=-1, bool csv_file_has_header=True, 
            std::string const & csv_file_undefined_field=" ", std::string const & csv_file_field_separators=",;", 
            std::string const & csv_file_quotes="\'\"", bool no_em=False)
        learn_parameters(plBayesianNetwork self, std::string const & csv_file, int em_iterations=-1, bool csv_file_has_header=True, 
            std::string const & csv_file_undefined_field=" ", std::string const & csv_file_field_separators=",;", 
            std::string const & csv_file_quotes="\'\"")
        learn_parameters(plBayesianNetwork self, std::string const & csv_file, int em_iterations=-1, bool csv_file_has_header=True, 
            std::string const & csv_file_undefined_field=" ", std::string const & csv_file_field_separators=",;")
        learn_parameters(plBayesianNetwork self, std::string const & csv_file, int em_iterations=-1, bool csv_file_has_header=True, 
            std::string const & csv_file_undefined_field=" ")
        learn_parameters(plBayesianNetwork self, std::string const & csv_file, int em_iterations=-1, bool csv_file_has_header=True)
        learn_parameters(plBayesianNetwork self, std::string const & csv_file, int em_iterations=-1)
        learn_parameters(plBayesianNetwork self, std::string const & csv_file)
        learn_parameters(plBayesianNetwork self, plDataDescriptor data_set, int em_iterations=-1, bool no_em=False)
        learn_parameters(plBayesianNetwork self, plDataDescriptor data_set, int em_iterations=-1)
        learn_parameters(plBayesianNetwork self, plDataDescriptor data_set)
        """
        return _pypl.plBayesianNetwork_learn_parameters(self, *args)

    def learn_parameters_em(self, *args):
        """
        learn_parameters_em(plBayesianNetwork self, plDataDescriptor data_set, int em_iterations=-1, bool same_missing_variables=False) -> plFloat
        learn_parameters_em(plBayesianNetwork self, plDataDescriptor data_set, int em_iterations=-1) -> plFloat
        learn_parameters_em(plBayesianNetwork self, plDataDescriptor data_set) -> plFloat
        """
        return _pypl.plBayesianNetwork_learn_parameters_em(self, *args)

    def learn_parameters_no_em(self, *args):
        """learn_parameters_no_em(plBayesianNetwork self, plDataDescriptor data_set)"""
        return _pypl.plBayesianNetwork_learn_parameters_no_em(self, *args)

    def learn_parameters_add_point(self, *args):
        """
        learn_parameters_add_point(plBayesianNetwork self, plValues data_row, plFloat weight=1.0) -> bool
        learn_parameters_add_point(plBayesianNetwork self, plValues data_row) -> bool
        learn_parameters_add_point(plBayesianNetwork self, plValues data_row, BoolVector definitions, plFloat weight=1.0) -> bool
        learn_parameters_add_point(plBayesianNetwork self, plValues data_row, BoolVector definitions) -> bool
        """
        return _pypl.plBayesianNetwork_learn_parameters_add_point(self, *args)

    def reset_learned_parameters(self):
        """reset_learned_parameters(plBayesianNetwork self)"""
        return _pypl.plBayesianNetwork_reset_learned_parameters(self)

    def learn_structure(self, *args):
        """
        learn_structure(plBayesianNetwork self, plDataDescriptor data, bool use_current_structure_as_starting_point=True, bool keep_current_edges=True, 
            plStructureLearningScore edge_score=PL_MI, plStructureLearningScore node_score=PL_AIC, 
            plSymbol root_node=plSymbol(), unsigned int maxp=10, 
            unsigned int maxpc=1000, plBayesianNetwork::bn_edge_list_t const & edges_to_exclude=plBayesianNetwork::bn_edge_list_t()) -> plFloat
        learn_structure(plBayesianNetwork self, plDataDescriptor data, bool use_current_structure_as_starting_point=True, bool keep_current_edges=True, 
            plStructureLearningScore edge_score=PL_MI, plStructureLearningScore node_score=PL_AIC, 
            plSymbol root_node=plSymbol(), unsigned int maxp=10, 
            unsigned int maxpc=1000) -> plFloat
        learn_structure(plBayesianNetwork self, plDataDescriptor data, bool use_current_structure_as_starting_point=True, bool keep_current_edges=True, 
            plStructureLearningScore edge_score=PL_MI, plStructureLearningScore node_score=PL_AIC, 
            plSymbol root_node=plSymbol(), unsigned int maxp=10) -> plFloat
        learn_structure(plBayesianNetwork self, plDataDescriptor data, bool use_current_structure_as_starting_point=True, bool keep_current_edges=True, 
            plStructureLearningScore edge_score=PL_MI, plStructureLearningScore node_score=PL_AIC, 
            plSymbol root_node=plSymbol()) -> plFloat
        learn_structure(plBayesianNetwork self, plDataDescriptor data, bool use_current_structure_as_starting_point=True, bool keep_current_edges=True, 
            plStructureLearningScore edge_score=PL_MI, plStructureLearningScore node_score=PL_AIC) -> plFloat
        learn_structure(plBayesianNetwork self, plDataDescriptor data, bool use_current_structure_as_starting_point=True, bool keep_current_edges=True, 
            plStructureLearningScore edge_score=PL_MI) -> plFloat
        learn_structure(plBayesianNetwork self, plDataDescriptor data, bool use_current_structure_as_starting_point=True, bool keep_current_edges=True) -> plFloat
        learn_structure(plBayesianNetwork self, plDataDescriptor data, bool use_current_structure_as_starting_point=True) -> plFloat
        learn_structure(plBayesianNetwork self, plDataDescriptor data) -> plFloat
        """
        return _pypl.plBayesianNetwork_learn_structure(self, *args)

    def learn_structure_tree_augmented_naive_bayes(self, *args):
        """
        learn_structure_tree_augmented_naive_bayes(plBayesianNetwork self, plDataDescriptor data, plSymbol class_node, plStructureLearningScore edge_score=PL_AIC, 
            plFloat score_threshold=0.0, bool keep_current_edges=True, plBayesianNetwork::bn_edge_list_t const & edges_to_exclude=plBayesianNetwork::bn_edge_list_t())
        learn_structure_tree_augmented_naive_bayes(plBayesianNetwork self, plDataDescriptor data, plSymbol class_node, plStructureLearningScore edge_score=PL_AIC, 
            plFloat score_threshold=0.0, bool keep_current_edges=True)
        learn_structure_tree_augmented_naive_bayes(plBayesianNetwork self, plDataDescriptor data, plSymbol class_node, plStructureLearningScore edge_score=PL_AIC, 
            plFloat score_threshold=0.0)
        learn_structure_tree_augmented_naive_bayes(plBayesianNetwork self, plDataDescriptor data, plSymbol class_node, plStructureLearningScore edge_score=PL_AIC)
        learn_structure_tree_augmented_naive_bayes(plBayesianNetwork self, plDataDescriptor data, plSymbol class_node)
        """
        return _pypl.plBayesianNetwork_learn_structure_tree_augmented_naive_bayes(self, *args)

    def learn_naive_bayes(self, *args):
        """
        learn_naive_bayes(plBayesianNetwork self, plDataDescriptor data, plSymbol class_node, plStructureLearningScore edge_score=PL_MI, 
            plFloat score_threshold=-std::numeric_limits< plFloat >::infinity())
        learn_naive_bayes(plBayesianNetwork self, plDataDescriptor data, plSymbol class_node, plStructureLearningScore edge_score=PL_MI)
        learn_naive_bayes(plBayesianNetwork self, plDataDescriptor data, plSymbol class_node)
        """
        return _pypl.plBayesianNetwork_learn_naive_bayes(self, *args)

    def get_belief(self, *args):
        """
        get_belief(plBayesianNetwork self, plSymbol node) -> plDistribution
        get_belief(plBayesianNetwork self, std::string const & node_name) -> plDistribution
        get_belief(plBayesianNetwork self, plVariablesConjunction node_conjunction) -> plDistribution
        """
        return _pypl.plBayesianNetwork_get_belief(self, *args)

    def get_belief_table(self, *args):
        """
        get_belief_table(plBayesianNetwork self, plSymbol node) -> DoubleVector
        get_belief_table(plBayesianNetwork self, std::string const & node_name) -> DoubleVector
        get_belief_table(plBayesianNetwork self, plVariablesConjunction node_conjunction) -> DoubleVector
        """
        return _pypl.plBayesianNetwork_get_belief_table(self, *args)

    def get_joint_distribution(self):
        """get_joint_distribution(plBayesianNetwork self) -> plJointDistribution"""
        return _pypl.plBayesianNetwork_get_joint_distribution(self)

    def save(self, *args):
        """save(plBayesianNetwork self, std::string const & file_name)"""
        return _pypl.plBayesianNetwork_save(self, *args)

    def load(self, *args):
        """load(plBayesianNetwork self, std::string const & file_name)"""
        return _pypl.plBayesianNetwork_load(self, *args)

    def name(self):
        """name(plBayesianNetwork self) -> std::string const &"""
        return _pypl.plBayesianNetwork_name(self)

    def set_name(self, *args):
        """set_name(plBayesianNetwork self, std::string const & name)"""
        return _pypl.plBayesianNetwork_set_name(self, *args)

    def set_inference_algorithm(self, *args):
        """set_inference_algorithm(plBayesianNetwork self, plInferenceAlgorithm algo)"""
        return _pypl.plBayesianNetwork_set_inference_algorithm(self, *args)

    def draw_graph(self, *args):
        """
        draw_graph(plBayesianNetwork self, std::string const & file_name, plDrawingLanguage drawing_language=PL_XFIG_GRAPH)
        draw_graph(plBayesianNetwork self, std::string const & file_name)
        """
        return _pypl.plBayesianNetwork_draw_graph(self, *args)

    def draw_graph_dot(self, *args):
        """
        draw_graph_dot(plBayesianNetwork self, std::string const & file_name, std::string const & dot_node_shape="", std::string const & dot_node_color="", 
            std::string const & dot_node_fill_color="", std::string const & dot_background_color="", 
            std::string const & dot_rankdir="")
        draw_graph_dot(plBayesianNetwork self, std::string const & file_name, std::string const & dot_node_shape="", std::string const & dot_node_color="", 
            std::string const & dot_node_fill_color="", std::string const & dot_background_color="")
        draw_graph_dot(plBayesianNetwork self, std::string const & file_name, std::string const & dot_node_shape="", std::string const & dot_node_color="", 
            std::string const & dot_node_fill_color="")
        draw_graph_dot(plBayesianNetwork self, std::string const & file_name, std::string const & dot_node_shape="", std::string const & dot_node_color="")
        draw_graph_dot(plBayesianNetwork self, std::string const & file_name, std::string const & dot_node_shape="")
        draw_graph_dot(plBayesianNetwork self, std::string const & file_name)
        """
        return _pypl.plBayesianNetwork_draw_graph_dot(self, *args)

    def sample(self, *args):
        """
        sample(plBayesianNetwork self, std::string const & file, unsigned int nsamples, DoubleVector missing_probabilities=std::vector< plProbValue >())
        sample(plBayesianNetwork self, std::string const & file, unsigned int nsamples)
        """
        return _pypl.plBayesianNetwork_sample(self, *args)

    def exists_node(self, *args):
        """
        exists_node(plBayesianNetwork self, plSymbol node) -> bool
        exists_node(plBayesianNetwork self, std::string const & name) -> bool
        """
        return _pypl.plBayesianNetwork_exists_node(self, *args)

    def node_parents(self, *args):
        """
        node_parents(plBayesianNetwork self, plSymbol node) -> plVariablesConjunction
        node_parents(plBayesianNetwork self, std::string const & name) -> plVariablesConjunction
        """
        return _pypl.plBayesianNetwork_node_parents(self, *args)

    def node_children(self, *args):
        """
        node_children(plBayesianNetwork self, plSymbol node) -> plVariablesConjunction
        node_children(plBayesianNetwork self, std::string const & name) -> plVariablesConjunction
        """
        return _pypl.plBayesianNetwork_node_children(self, *args)

    def apply_prediction(self, *args):
        """
        apply_prediction(plBayesianNetwork self, plVariablesConjunction target_variables, plDataDescriptor data, std::string const & output_file, 
            bool output_probability_table=False, unsigned int nrows=std::numeric_limits< unsigned int >::max())
        apply_prediction(plBayesianNetwork self, plVariablesConjunction target_variables, plDataDescriptor data, std::string const & output_file, 
            bool output_probability_table=False)
        apply_prediction(plBayesianNetwork self, plVariablesConjunction target_variables, plDataDescriptor data, std::string const & output_file)
        apply_prediction(plBayesianNetwork self, plVariablesConjunction target_variables, plDataDescriptor data, unsigned int nrows=std::numeric_limits< unsigned int >::max()) -> plValuesVector
        apply_prediction(plBayesianNetwork self, plVariablesConjunction target_variables, plDataDescriptor data) -> plValuesVector
        """
        return _pypl.plBayesianNetwork_apply_prediction(self, *args)

    def prediction(self, *args):
        """prediction(plBayesianNetwork self, plVariablesConjunction target_variables, plValues evidence) -> plValues"""
        return _pypl.plBayesianNetwork_prediction(self, *args)

    def validate_prediction(self, *args):
        """
        validate_prediction(plBayesianNetwork self, plVariablesConjunction target_variables, plDataDescriptor data, std::string const & output_file, 
            bool output_probability_table=False, unsigned int nrows=std::numeric_limits< unsigned int >::max()) -> plFloat
        validate_prediction(plBayesianNetwork self, plVariablesConjunction target_variables, plDataDescriptor data, std::string const & output_file, 
            bool output_probability_table=False) -> plFloat
        validate_prediction(plBayesianNetwork self, plVariablesConjunction target_variables, plDataDescriptor data, std::string const & output_file) -> plFloat
        validate_prediction(plBayesianNetwork self, plVariablesConjunction target_variables, plDataDescriptor data, std::string const & output_file, 
            UnsignedIntVector hard_confusion_matrix, bool output_probability_table=False, 
            unsigned int nrows=std::numeric_limits< unsigned int >::max()) -> plFloat
        validate_prediction(plBayesianNetwork self, plVariablesConjunction target_variables, plDataDescriptor data, std::string const & output_file, 
            UnsignedIntVector hard_confusion_matrix, bool output_probability_table=False) -> plFloat
        validate_prediction(plBayesianNetwork self, plVariablesConjunction target_variables, plDataDescriptor data, std::string const & output_file, 
            UnsignedIntVector hard_confusion_matrix) -> plFloat
        validate_prediction(plBayesianNetwork self, plVariablesConjunction target_variables, plDataDescriptor data, std::string const & output_file, 
            UnsignedIntVector hard_confusion_matrix, DoubleVector soft_confusion_matrix, 
            bool output_probability_table=False, unsigned int nrows=std::numeric_limits< unsigned int >::max()) -> plFloat
        validate_prediction(plBayesianNetwork self, plVariablesConjunction target_variables, plDataDescriptor data, std::string const & output_file, 
            UnsignedIntVector hard_confusion_matrix, DoubleVector soft_confusion_matrix, 
            bool output_probability_table=False) -> plFloat
        validate_prediction(plBayesianNetwork self, plVariablesConjunction target_variables, plDataDescriptor data, std::string const & output_file, 
            UnsignedIntVector hard_confusion_matrix, DoubleVector soft_confusion_matrix) -> plFloat
        """
        return _pypl.plBayesianNetwork_validate_prediction(self, *args)

    def get_markov_blanket(self, *args):
        """get_markov_blanket(plBayesianNetwork self, plSymbol node) -> plVariablesConjunction"""
        return _pypl.plBayesianNetwork_get_markov_blanket(self, *args)

    def set_verbose_structure_learning(self, verbose=True):
        """
        set_verbose_structure_learning(plBayesianNetwork self, bool verbose=True)
        set_verbose_structure_learning(plBayesianNetwork self)
        """
        return _pypl.plBayesianNetwork_set_verbose_structure_learning(self, verbose)

    def set_verbose_em_learning(self, verbose=True):
        """
        set_verbose_em_learning(plBayesianNetwork self, bool verbose=True)
        set_verbose_em_learning(plBayesianNetwork self)
        """
        return _pypl.plBayesianNetwork_set_verbose_em_learning(self, verbose)

    def set_compiled_belief_distribution(self, *args):
        """set_compiled_belief_distribution(plBayesianNetwork self, bool compile_it)"""
        return _pypl.plBayesianNetwork_set_compiled_belief_distribution(self, *args)

    def learned_parameters_number(self):
        """learned_parameters_number(plBayesianNetwork self) -> unsigned int"""
        return _pypl.plBayesianNetwork_learned_parameters_number(self)

    def compute_data_record_log_likelihood(self, *args):
        """compute_data_record_log_likelihood(plBayesianNetwork self, plValues data_record) -> plFloat"""
        return _pypl.plBayesianNetwork_compute_data_record_log_likelihood(self, *args)

    def compute_data_set_log_likelihood(self, *args):
        """
        compute_data_set_log_likelihood(plBayesianNetwork self, plDataDescriptor data_set, unsigned int nrows=std::numeric_limits< unsigned int >::max()) -> plFloat
        compute_data_set_log_likelihood(plBayesianNetwork self, plDataDescriptor data_set) -> plFloat
        compute_data_set_log_likelihood(plBayesianNetwork self, plValuesVector data_records) -> plFloat
        """
        return _pypl.plBayesianNetwork_compute_data_set_log_likelihood(self, *args)

    def get_node_distribution(self, *args):
        """get_node_distribution(plBayesianNetwork self, plSymbol node) -> plComputableObject"""
        return _pypl.plBayesianNetwork_get_node_distribution(self, *args)

    def get_node_learnable_distribution(self, *args):
        """get_node_learnable_distribution(plBayesianNetwork self, plSymbol node) -> plLearnObject"""
        return _pypl.plBayesianNetwork_get_node_learnable_distribution(self, *args)

    def add_time_transition_edge(self, *args):
        """add_time_transition_edge(plBayesianNetwork self, plSymbol node_prec_timeslice, plSymbol node_current_timeslice)"""
        return _pypl.plBayesianNetwork_add_time_transition_edge(self, *args)

    def set_time_transition_distribution(self, *args):
        """set_time_transition_distribution(plBayesianNetwork self, plCndDistribution transition)"""
        return _pypl.plBayesianNetwork_set_time_transition_distribution(self, *args)

    def set_time_transition_learnable_distribution(self, *args):
        """set_time_transition_learnable_distribution(plBayesianNetwork self, plLearnObject learnable_transition)"""
        return _pypl.plBayesianNetwork_set_time_transition_learnable_distribution(self, *args)

    def next_time_slice(self):
        """next_time_slice(plBayesianNetwork self)"""
        return _pypl.plBayesianNetwork_next_time_slice(self)

    def get_time_slice_edges(self):
        """get_time_slice_edges(plBayesianNetwork self) -> plBayesianNetwork::bn_edge_list_t"""
        return _pypl.plBayesianNetwork_get_time_slice_edges(self)

    def set_query_cache_max_size(self, *args):
        """set_query_cache_max_size(plBayesianNetwork self, unsigned int new_size)"""
        return _pypl.plBayesianNetwork_set_query_cache_max_size(self, *args)

    def save_as_genie(self, *args):
        """save_as_genie(plBayesianNetwork self, std::string const & file_name)"""
        return _pypl.plBayesianNetwork_save_as_genie(self, *args)

    def load_from_genie(self, *args):
        """load_from_genie(plBayesianNetwork self, std::string const & file_name)"""
        return _pypl.plBayesianNetwork_load_from_genie(self, *args)

    def save_as_netica(self, *args):
        """save_as_netica(plBayesianNetwork self, std::string const & file_name)"""
        return _pypl.plBayesianNetwork_save_as_netica(self, *args)

    def load_from_netica(self, *args):
        """load_from_netica(plBayesianNetwork self, std::string const & file_name)"""
        return _pypl.plBayesianNetwork_load_from_netica(self, *args)

    def save_as_hugin(self, *args):
        """save_as_hugin(plBayesianNetwork self, std::string const & file_name)"""
        return _pypl.plBayesianNetwork_save_as_hugin(self, *args)

    def load_from_hugin(self, *args):
        """load_from_hugin(plBayesianNetwork self, std::string const & file_name)"""
        return _pypl.plBayesianNetwork_load_from_hugin(self, *args)

plBayesianNetwork_swigregister = _pypl.plBayesianNetwork_swigregister
plBayesianNetwork_swigregister(plBayesianNetwork)

class plQuery(_object):
    """Proxy of C++ plQuery class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plQuery, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plQuery, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plQuery self) -> plQuery
        __init__(plQuery self, plVariablesConjunction vars, bool compile_it) -> plQuery
        """
        this = _pypl.new_plQuery(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["variables"] = _pypl.plQuery_variables_set
    __swig_getmethods__["variables"] = _pypl.plQuery_variables_get
    if _newclass:variables = _swig_property(_pypl.plQuery_variables_get, _pypl.plQuery_variables_set)
    __swig_setmethods__["discretized_variables"] = _pypl.plQuery_discretized_variables_set
    __swig_getmethods__["discretized_variables"] = _pypl.plQuery_discretized_variables_get
    if _newclass:discretized_variables = _swig_property(_pypl.plQuery_discretized_variables_get, _pypl.plQuery_discretized_variables_set)
    __swig_setmethods__["dist"] = _pypl.plQuery_dist_set
    __swig_getmethods__["dist"] = _pypl.plQuery_dist_get
    if _newclass:dist = _swig_property(_pypl.plQuery_dist_get, _pypl.plQuery_dist_set)
    __swig_setmethods__["compiled_dist"] = _pypl.plQuery_compiled_dist_set
    __swig_getmethods__["compiled_dist"] = _pypl.plQuery_compiled_dist_get
    if _newclass:compiled_dist = _swig_property(_pypl.plQuery_compiled_dist_get, _pypl.plQuery_compiled_dist_set)
    __swig_setmethods__["cnd_dist"] = _pypl.plQuery_cnd_dist_set
    __swig_getmethods__["cnd_dist"] = _pypl.plQuery_cnd_dist_get
    if _newclass:cnd_dist = _swig_property(_pypl.plQuery_cnd_dist_get, _pypl.plQuery_cnd_dist_set)
    __swig_setmethods__["compiled_response_as_probtable"] = _pypl.plQuery_compiled_response_as_probtable_set
    __swig_getmethods__["compiled_response_as_probtable"] = _pypl.plQuery_compiled_response_as_probtable_get
    if _newclass:compiled_response_as_probtable = _swig_property(_pypl.plQuery_compiled_response_as_probtable_get, _pypl.plQuery_compiled_response_as_probtable_set)
    __swig_setmethods__["first_computation"] = _pypl.plQuery_first_computation_set
    __swig_getmethods__["first_computation"] = _pypl.plQuery_first_computation_get
    if _newclass:first_computation = _swig_property(_pypl.plQuery_first_computation_get, _pypl.plQuery_first_computation_set)
    __swig_setmethods__["last_evidence"] = _pypl.plQuery_last_evidence_set
    __swig_getmethods__["last_evidence"] = _pypl.plQuery_last_evidence_get
    if _newclass:last_evidence = _swig_property(_pypl.plQuery_last_evidence_get, _pypl.plQuery_last_evidence_set)
    __swig_setmethods__["compile_distribution"] = _pypl.plQuery_compile_distribution_set
    __swig_getmethods__["compile_distribution"] = _pypl.plQuery_compile_distribution_get
    if _newclass:compile_distribution = _swig_property(_pypl.plQuery_compile_distribution_get, _pypl.plQuery_compile_distribution_set)
    __swig_setmethods__["invalidated_compiled_distribution"] = _pypl.plQuery_invalidated_compiled_distribution_set
    __swig_getmethods__["invalidated_compiled_distribution"] = _pypl.plQuery_invalidated_compiled_distribution_get
    if _newclass:invalidated_compiled_distribution = _swig_property(_pypl.plQuery_invalidated_compiled_distribution_get, _pypl.plQuery_invalidated_compiled_distribution_set)
    __swig_destroy__ = _pypl.delete_plQuery
    __del__ = lambda self : None;
plQuery_swigregister = _pypl.plQuery_swigregister
plQuery_swigregister(plQuery)

class plTimeSliceQuery(plQuery):
    """Proxy of C++ plTimeSliceQuery class"""
    __swig_setmethods__ = {}
    for _s in [plQuery]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plTimeSliceQuery, name, value)
    __swig_getmethods__ = {}
    for _s in [plQuery]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plTimeSliceQuery, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plTimeSliceQuery self) -> plTimeSliceQuery
        __init__(plTimeSliceQuery self, plSymbol node_prec, plSymbol node_current, plDistribution init_dist) -> plTimeSliceQuery
        __init__(plTimeSliceQuery self, plSymbol node_prec, plSymbol node_current) -> plTimeSliceQuery
        """
        this = _pypl.new_plTimeSliceQuery(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plTimeSliceQuery
    __del__ = lambda self : None;
    def set_mutable(self, *args):
        """set_mutable(plTimeSliceQuery self, plBayesianNetwork bn)"""
        return _pypl.plTimeSliceQuery_set_mutable(self, *args)

    __swig_setmethods__["mutable_dist"] = _pypl.plTimeSliceQuery_mutable_dist_set
    __swig_getmethods__["mutable_dist"] = _pypl.plTimeSliceQuery_mutable_dist_get
    if _newclass:mutable_dist = _swig_property(_pypl.plTimeSliceQuery_mutable_dist_get, _pypl.plTimeSliceQuery_mutable_dist_set)
    __swig_setmethods__["prec_variable"] = _pypl.plTimeSliceQuery_prec_variable_set
    __swig_getmethods__["prec_variable"] = _pypl.plTimeSliceQuery_prec_variable_get
    if _newclass:prec_variable = _swig_property(_pypl.plTimeSliceQuery_prec_variable_get, _pypl.plTimeSliceQuery_prec_variable_set)
plTimeSliceQuery_swigregister = _pypl.plTimeSliceQuery_swigregister
plTimeSliceQuery_swigregister(plTimeSliceQuery)

class plStructureLearner(plLearner):
    """Proxy of C++ plStructureLearner class"""
    __swig_setmethods__ = {}
    for _s in [plLearner]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plStructureLearner, name, value)
    __swig_getmethods__ = {}
    for _s in [plLearner]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plStructureLearner, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plStructureLearner self, plJointDistribution joint) -> plStructureLearner
        __init__(plStructureLearner self, plVariablesConjunction variables, plStructureLearner::symbol_edge_list_t const & init_edges=plStructureLearner::symbol_edge_list_t()) -> plStructureLearner
        __init__(plStructureLearner self, plVariablesConjunction variables) -> plStructureLearner
        __init__(plStructureLearner self, plStructureLearner arg2) -> plStructureLearner
        """
        this = _pypl.new_plStructureLearner(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plStructureLearner
    __del__ = lambda self : None;
    def DMST(self, *args):
        """
        DMST(plStructureLearner self, plEdgeScore score, std::vector< plSymbol,std::allocator< plSymbol > > & vertex_order, 
            plSymbol root_node, plStructureLearner::symbol_edge_list_t const & included_edges=plStructureLearner::symbol_edge_list_t(), 
            plStructureLearner::symbol_edge_list_t const & excluded_edges=plStructureLearner::symbol_edge_list_t()) -> bool
        DMST(plStructureLearner self, plEdgeScore score, std::vector< plSymbol,std::allocator< plSymbol > > & vertex_order, 
            plSymbol root_node, plStructureLearner::symbol_edge_list_t const & included_edges=plStructureLearner::symbol_edge_list_t()) -> bool
        DMST(plStructureLearner self, plEdgeScore score, std::vector< plSymbol,std::allocator< plSymbol > > & vertex_order, 
            plSymbol root_node) -> bool
        DMST(plStructureLearner self, plEdgeScore score, plSymbol root_node, plStructureLearner::symbol_edge_list_t const & included_edges=plStructureLearner::symbol_edge_list_t(), 
            plStructureLearner::symbol_edge_list_t const & excluded_edges=plStructureLearner::symbol_edge_list_t()) -> bool
        DMST(plStructureLearner self, plEdgeScore score, plSymbol root_node, plStructureLearner::symbol_edge_list_t const & included_edges=plStructureLearner::symbol_edge_list_t()) -> bool
        DMST(plStructureLearner self, plEdgeScore score, plSymbol root_node) -> bool
        """
        return _pypl.plStructureLearner_DMST(self, *args)

    def K2(self, *args):
        """
        K2(plStructureLearner self, plNodeScore score, std::vector< plSymbol,std::allocator< plSymbol > > const & vertex_order, 
            plStructureLearner::symbol_edge_list_t const & included_edges=plStructureLearner::symbol_edge_list_t(), 
            plStructureLearner::symbol_edge_list_t const & excluded_edges=plStructureLearner::symbol_edge_list_t(), 
            unsigned int max_parents=100, 
            unsigned int max_parent_card=100000)
        K2(plStructureLearner self, plNodeScore score, std::vector< plSymbol,std::allocator< plSymbol > > const & vertex_order, 
            plStructureLearner::symbol_edge_list_t const & included_edges=plStructureLearner::symbol_edge_list_t(), 
            plStructureLearner::symbol_edge_list_t const & excluded_edges=plStructureLearner::symbol_edge_list_t(), 
            unsigned int max_parents=100)
        K2(plStructureLearner self, plNodeScore score, std::vector< plSymbol,std::allocator< plSymbol > > const & vertex_order, 
            plStructureLearner::symbol_edge_list_t const & included_edges=plStructureLearner::symbol_edge_list_t(), 
            plStructureLearner::symbol_edge_list_t const & excluded_edges=plStructureLearner::symbol_edge_list_t())
        K2(plStructureLearner self, plNodeScore score, std::vector< plSymbol,std::allocator< plSymbol > > const & vertex_order, 
            plStructureLearner::symbol_edge_list_t const & included_edges=plStructureLearner::symbol_edge_list_t())
        K2(plStructureLearner self, plNodeScore score, std::vector< plSymbol,std::allocator< plSymbol > > const & vertex_order)
        """
        return _pypl.plStructureLearner_K2(self, *args)

    def GS(self, *args):
        """
        GS(plStructureLearner self, plNodeScore score, plStructureLearner::symbol_edge_list_t const & included_edges=plStructureLearner::symbol_edge_list_t(), 
            plStructureLearner::symbol_edge_list_t const & excluded_edges=plStructureLearner::symbol_edge_list_t(), 
            unsigned int max_parents=100, 
            unsigned int max_parent_card=100000)
        GS(plStructureLearner self, plNodeScore score, plStructureLearner::symbol_edge_list_t const & included_edges=plStructureLearner::symbol_edge_list_t(), 
            plStructureLearner::symbol_edge_list_t const & excluded_edges=plStructureLearner::symbol_edge_list_t(), 
            unsigned int max_parents=100)
        GS(plStructureLearner self, plNodeScore score, plStructureLearner::symbol_edge_list_t const & included_edges=plStructureLearner::symbol_edge_list_t(), 
            plStructureLearner::symbol_edge_list_t const & excluded_edges=plStructureLearner::symbol_edge_list_t())
        GS(plStructureLearner self, plNodeScore score, plStructureLearner::symbol_edge_list_t const & included_edges=plStructureLearner::symbol_edge_list_t())
        GS(plStructureLearner self, plNodeScore score)
        """
        return _pypl.plStructureLearner_GS(self, *args)

    def get_joint_distribution(self, *args):
        """get_joint_distribution(plStructureLearner self, plDataDescriptor data_desc) -> plJointDistribution"""
        return _pypl.plStructureLearner_get_joint_distribution(self, *args)

    def get_variables(self):
        """get_variables(plStructureLearner self) -> plVariablesConjunction"""
        return _pypl.plStructureLearner_get_variables(self)

    def get_edges(self):
        """get_edges(plStructureLearner self) -> std::vector< std::pair< plSymbol,plSymbol >,std::allocator< std::pair< plSymbol,plSymbol > > >"""
        return _pypl.plStructureLearner_get_edges(self)

    def set_verbose(self, *args):
        """set_verbose(plStructureLearner self, bool verbose)"""
        return _pypl.plStructureLearner_set_verbose(self, *args)

plStructureLearner_swigregister = _pypl.plStructureLearner_swigregister
plStructureLearner_swigregister(plStructureLearner)

class plScore(_object):
    """Proxy of C++ plScore class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plScore, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plScore, name)
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(plScore self) -> plScore"""
        this = _pypl.new_plScore()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plScore
    __del__ = lambda self : None;
plScore_swigregister = _pypl.plScore_swigregister
plScore_swigregister(plScore)

class plNodeScore(plScore):
    """Proxy of C++ plNodeScore class"""
    __swig_setmethods__ = {}
    for _s in [plScore]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plNodeScore, name, value)
    __swig_getmethods__ = {}
    for _s in [plScore]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plNodeScore, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def __call__(self, *args):
        """
        __call__(plNodeScore self, plSymbol node, plVariablesConjunction parents) -> plFloat
        __call__(plNodeScore self, plJointDistribution jd) -> plFloat
        """
        return _pypl.plNodeScore___call__(self, *args)

    __swig_destroy__ = _pypl.delete_plNodeScore
    __del__ = lambda self : None;
plNodeScore_swigregister = _pypl.plNodeScore_swigregister
plNodeScore_swigregister(plNodeScore)

class plNodeScore_t(plNodeScore):
    """Proxy of C++ plNodeScore_t class"""
    __swig_setmethods__ = {}
    for _s in [plNodeScore]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plNodeScore_t, name, value)
    __swig_getmethods__ = {}
    for _s in [plNodeScore]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plNodeScore_t, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pypl.delete_plNodeScore_t
    __del__ = lambda self : None;
plNodeScore_t_swigregister = _pypl.plNodeScore_t_swigregister
plNodeScore_t_swigregister(plNodeScore_t)

class plNodeScoreAIC(plNodeScore_t):
    """Proxy of C++ plNodeScoreAIC class"""
    __swig_setmethods__ = {}
    for _s in [plNodeScore_t]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plNodeScoreAIC, name, value)
    __swig_getmethods__ = {}
    for _s in [plNodeScore_t]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plNodeScoreAIC, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(plNodeScoreAIC self, plDataDescriptor data_desc) -> plNodeScoreAIC"""
        this = _pypl.new_plNodeScoreAIC(*args)
        try: self.this.append(this)
        except: self.this = this
    def __call__(self, *args):
        """
        __call__(plNodeScoreAIC self, plSymbol node, plVariablesConjunction parents) -> plFloat
        __call__(plNodeScoreAIC self, plJointDistribution jd) -> plFloat
        """
        return _pypl.plNodeScoreAIC___call__(self, *args)

    __swig_destroy__ = _pypl.delete_plNodeScoreAIC
    __del__ = lambda self : None;
plNodeScoreAIC_swigregister = _pypl.plNodeScoreAIC_swigregister
plNodeScoreAIC_swigregister(plNodeScoreAIC)

class plNodeScoreBIC(plNodeScore_t):
    """Proxy of C++ plNodeScoreBIC class"""
    __swig_setmethods__ = {}
    for _s in [plNodeScore_t]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plNodeScoreBIC, name, value)
    __swig_getmethods__ = {}
    for _s in [plNodeScore_t]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plNodeScoreBIC, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(plNodeScoreBIC self, plDataDescriptor data_desc) -> plNodeScoreBIC"""
        this = _pypl.new_plNodeScoreBIC(*args)
        try: self.this.append(this)
        except: self.this = this
    def __call__(self, *args):
        """
        __call__(plNodeScoreBIC self, plSymbol node, plVariablesConjunction parents) -> plFloat
        __call__(plNodeScoreBIC self, plJointDistribution jd) -> plFloat
        """
        return _pypl.plNodeScoreBIC___call__(self, *args)

    __swig_destroy__ = _pypl.delete_plNodeScoreBIC
    __del__ = lambda self : None;
plNodeScoreBIC_swigregister = _pypl.plNodeScoreBIC_swigregister
plNodeScoreBIC_swigregister(plNodeScoreBIC)

class plNodeScoreBDeu(plNodeScore_t):
    """Proxy of C++ plNodeScoreBDeu class"""
    __swig_setmethods__ = {}
    for _s in [plNodeScore_t]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plNodeScoreBDeu, name, value)
    __swig_getmethods__ = {}
    for _s in [plNodeScore_t]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plNodeScoreBDeu, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(plNodeScoreBDeu self, plDataDescriptor data_desc, plFloat Nprime) -> plNodeScoreBDeu"""
        this = _pypl.new_plNodeScoreBDeu(*args)
        try: self.this.append(this)
        except: self.this = this
    def __call__(self, *args):
        """
        __call__(plNodeScoreBDeu self, plSymbol node, plVariablesConjunction parents) -> plFloat
        __call__(plNodeScoreBDeu self, plJointDistribution jd) -> plFloat
        """
        return _pypl.plNodeScoreBDeu___call__(self, *args)

    __swig_destroy__ = _pypl.delete_plNodeScoreBDeu
    __del__ = lambda self : None;
plNodeScoreBDeu_swigregister = _pypl.plNodeScoreBDeu_swigregister
plNodeScoreBDeu_swigregister(plNodeScoreBDeu)

class plNodeScoreMDL(plNodeScore_t):
    """Proxy of C++ plNodeScoreMDL class"""
    __swig_setmethods__ = {}
    for _s in [plNodeScore_t]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plNodeScoreMDL, name, value)
    __swig_getmethods__ = {}
    for _s in [plNodeScore_t]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plNodeScoreMDL, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(plNodeScoreMDL self, plDataDescriptor data_desc) -> plNodeScoreMDL"""
        this = _pypl.new_plNodeScoreMDL(*args)
        try: self.this.append(this)
        except: self.this = this
    def __call__(self, *args):
        """
        __call__(plNodeScoreMDL self, plSymbol node, plVariablesConjunction parents) -> plFloat
        __call__(plNodeScoreMDL self, plJointDistribution jd) -> plFloat
        """
        return _pypl.plNodeScoreMDL___call__(self, *args)

    __swig_destroy__ = _pypl.delete_plNodeScoreMDL
    __del__ = lambda self : None;
plNodeScoreMDL_swigregister = _pypl.plNodeScoreMDL_swigregister
plNodeScoreMDL_swigregister(plNodeScoreMDL)

class plEdgeScore(plScore):
    """Proxy of C++ plEdgeScore class"""
    __swig_setmethods__ = {}
    for _s in [plScore]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plEdgeScore, name, value)
    __swig_getmethods__ = {}
    for _s in [plScore]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plEdgeScore, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def __call__(self, *args):
        """
        __call__(plEdgeScore self, plSymbol A, plSymbol B) -> plFloat
        __call__(plEdgeScore self, plSymbol A, plSymbol B, plVariablesConjunction C) -> plFloat
        __call__(plEdgeScore self, plJointDistribution jd) -> plFloat
        """
        return _pypl.plEdgeScore___call__(self, *args)

    __swig_destroy__ = _pypl.delete_plEdgeScore
    __del__ = lambda self : None;
plEdgeScore_swigregister = _pypl.plEdgeScore_swigregister
plEdgeScore_swigregister(plEdgeScore)

class plEdgeScoreMI(plEdgeScore):
    """Proxy of C++ plEdgeScoreMI class"""
    __swig_setmethods__ = {}
    for _s in [plEdgeScore]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plEdgeScoreMI, name, value)
    __swig_getmethods__ = {}
    for _s in [plEdgeScore]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plEdgeScoreMI, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plEdgeScoreMI self, plDataDescriptor data_desc) -> plEdgeScoreMI
        __init__(plEdgeScoreMI self, plDataDescriptor data_desc, plVariablesConjunction conditioning_variables) -> plEdgeScoreMI
        """
        this = _pypl.new_plEdgeScoreMI(*args)
        try: self.this.append(this)
        except: self.this = this
    def __call__(self, *args):
        """
        __call__(plEdgeScoreMI self, plSymbol A, plSymbol B) -> plFloat
        __call__(plEdgeScoreMI self, plSymbol A, plSymbol B, plVariablesConjunction C) -> plFloat
        __call__(plEdgeScoreMI self, plJointDistribution jd) -> plFloat
        """
        return _pypl.plEdgeScoreMI___call__(self, *args)

    __swig_destroy__ = _pypl.delete_plEdgeScoreMI
    __del__ = lambda self : None;
plEdgeScoreMI_swigregister = _pypl.plEdgeScoreMI_swigregister
plEdgeScoreMI_swigregister(plEdgeScoreMI)

class plEdgeScoreMIDistance(plEdgeScore):
    """Proxy of C++ plEdgeScoreMIDistance class"""
    __swig_setmethods__ = {}
    for _s in [plEdgeScore]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plEdgeScoreMIDistance, name, value)
    __swig_getmethods__ = {}
    for _s in [plEdgeScore]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plEdgeScoreMIDistance, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plEdgeScoreMIDistance self, plDataDescriptor data_desc) -> plEdgeScoreMIDistance
        __init__(plEdgeScoreMIDistance self, plDataDescriptor data_desc, plVariablesConjunction conditioning_variables) -> plEdgeScoreMIDistance
        """
        this = _pypl.new_plEdgeScoreMIDistance(*args)
        try: self.this.append(this)
        except: self.this = this
    def __call__(self, *args):
        """
        __call__(plEdgeScoreMIDistance self, plSymbol A, plSymbol B) -> plFloat
        __call__(plEdgeScoreMIDistance self, plSymbol A, plSymbol B, plVariablesConjunction C) -> plFloat
        __call__(plEdgeScoreMIDistance self, plJointDistribution jd) -> plFloat
        """
        return _pypl.plEdgeScoreMIDistance___call__(self, *args)

    __swig_destroy__ = _pypl.delete_plEdgeScoreMIDistance
    __del__ = lambda self : None;
plEdgeScoreMIDistance_swigregister = _pypl.plEdgeScoreMIDistance_swigregister
plEdgeScoreMIDistance_swigregister(plEdgeScoreMIDistance)

class plEdgeScoreEntropy(plEdgeScore):
    """Proxy of C++ plEdgeScoreEntropy class"""
    __swig_setmethods__ = {}
    for _s in [plEdgeScore]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, plEdgeScoreEntropy, name, value)
    __swig_getmethods__ = {}
    for _s in [plEdgeScore]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, plEdgeScoreEntropy, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plEdgeScoreEntropy self, plDataDescriptor data_desc) -> plEdgeScoreEntropy
        __init__(plEdgeScoreEntropy self, plDataDescriptor data_desc, plVariablesConjunction conditioning_variables) -> plEdgeScoreEntropy
        """
        this = _pypl.new_plEdgeScoreEntropy(*args)
        try: self.this.append(this)
        except: self.this = this
    def __call__(self, *args):
        """
        __call__(plEdgeScoreEntropy self, plSymbol A, plSymbol B) -> plFloat
        __call__(plEdgeScoreEntropy self, plSymbol A, plSymbol B, plVariablesConjunction C) -> plFloat
        __call__(plEdgeScoreEntropy self, plJointDistribution jd) -> plFloat
        """
        return _pypl.plEdgeScoreEntropy___call__(self, *args)

    __swig_destroy__ = _pypl.delete_plEdgeScoreEntropy
    __del__ = lambda self : None;
plEdgeScoreEntropy_swigregister = _pypl.plEdgeScoreEntropy_swigregister
plEdgeScoreEntropy_swigregister(plEdgeScoreEntropy)

class plEdgeScoreAIC(_object):
    """Proxy of C++ plEdgeScoreAIC class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plEdgeScoreAIC, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plEdgeScoreAIC, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plEdgeScoreAIC self, plDataDescriptor data_desc) -> plEdgeScoreAIC
        __init__(plEdgeScoreAIC self, plDataDescriptor data_desc, plVariablesConjunction conditioning_variables) -> plEdgeScoreAIC
        """
        this = _pypl.new_plEdgeScoreAIC(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plEdgeScoreAIC
    __del__ = lambda self : None;
plEdgeScoreAIC_swigregister = _pypl.plEdgeScoreAIC_swigregister
plEdgeScoreAIC_swigregister(plEdgeScoreAIC)

class plEdgeScoreBIC(_object):
    """Proxy of C++ plEdgeScoreBIC class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plEdgeScoreBIC, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plEdgeScoreBIC, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plEdgeScoreBIC self, plDataDescriptor data_desc) -> plEdgeScoreBIC
        __init__(plEdgeScoreBIC self, plDataDescriptor data_desc, plVariablesConjunction conditioning_variables) -> plEdgeScoreBIC
        """
        this = _pypl.new_plEdgeScoreBIC(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plEdgeScoreBIC
    __del__ = lambda self : None;
plEdgeScoreBIC_swigregister = _pypl.plEdgeScoreBIC_swigregister
plEdgeScoreBIC_swigregister(plEdgeScoreBIC)

class plEdgeScoreBDeu(_object):
    """Proxy of C++ plEdgeScoreBDeu class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plEdgeScoreBDeu, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plEdgeScoreBDeu, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plEdgeScoreBDeu self, plDataDescriptor data_desc, plFloat Nprime) -> plEdgeScoreBDeu
        __init__(plEdgeScoreBDeu self, plDataDescriptor data_desc, plFloat Nprime, plVariablesConjunction conditioning_variables) -> plEdgeScoreBDeu
        """
        this = _pypl.new_plEdgeScoreBDeu(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plEdgeScoreBDeu
    __del__ = lambda self : None;
plEdgeScoreBDeu_swigregister = _pypl.plEdgeScoreBDeu_swigregister
plEdgeScoreBDeu_swigregister(plEdgeScoreBDeu)

class plEdgeScoreMDL(_object):
    """Proxy of C++ plEdgeScoreMDL class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plEdgeScoreMDL, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plEdgeScoreMDL, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(plEdgeScoreMDL self, plDataDescriptor data_desc) -> plEdgeScoreMDL
        __init__(plEdgeScoreMDL self, plDataDescriptor data_desc, plVariablesConjunction conditioning_variables) -> plEdgeScoreMDL
        """
        this = _pypl.new_plEdgeScoreMDL(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pypl.delete_plEdgeScoreMDL
    __del__ = lambda self : None;
plEdgeScoreMDL_swigregister = _pypl.plEdgeScoreMDL_swigregister
plEdgeScoreMDL_swigregister(plEdgeScoreMDL)

class plSerializer(_object):
    """Proxy of C++ plPythonSerializer class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, plSerializer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, plSerializer, name)
    __repr__ = _swig_repr
    BINARY_ARCHIVE = _pypl.plSerializer_BINARY_ARCHIVE
    XML_ARCHIVE = _pypl.plSerializer_XML_ARCHIVE
    def __init__(self, *args): 
        """
        __init__(plPythonSerializer self) -> plSerializer
        __init__(plPythonSerializer self, PyObject * dict, PyObject * name) -> plSerializer
        """
        this = _pypl.new_plSerializer(*args)
        try: self.this.append(this)
        except: self.this = this
    def clear(self):
        """clear(plSerializer self)"""
        return _pypl.plSerializer_clear(self)

    def add_object(self, *args):
        """add_object(plSerializer self, PyObject * name, PyObject * object)"""
        return _pypl.plSerializer_add_object(self, *args)

    def get_object(self, *args):
        """get_object(plSerializer self, PyObject * name) -> PyObject *"""
        return _pypl.plSerializer_get_object(self, *args)

    def get_all_objects_map(self):
        """get_all_objects_map(plSerializer self) -> PyObject *"""
        return _pypl.plSerializer_get_all_objects_map(self)

    def save_to_string(self, *args):
        """
        save_to_string(plSerializer self, plPythonSerializer::ArchiveType format=XML_ARCHIVE) -> PyObject
        save_to_string(plSerializer self) -> PyObject *
        """
        return _pypl.plSerializer_save_to_string(self, *args)

    def load_from_string(self, *args):
        """
        load_from_string(plSerializer self, PyObject * str, plPythonSerializer::ArchiveType format=XML_ARCHIVE)
        load_from_string(plSerializer self, PyObject * str)
        """
        return _pypl.plSerializer_load_from_string(self, *args)

    def save(self, *args):
        """
        save(plSerializer self, std::string const & fileName, plPythonSerializer::ArchiveType format=XML_ARCHIVE)
        save(plSerializer self, std::string const & fileName)
        """
        return _pypl.plSerializer_save(self, *args)

    def load(self, *args):
        """
        load(plSerializer self, std::string const & fileName, plPythonSerializer::ArchiveType format=XML_ARCHIVE)
        load(plSerializer self, std::string const & fileName)
        """
        return _pypl.plSerializer_load(self, *args)

    def set_name(self, *args):
        """set_name(plSerializer self, std::string const & name)"""
        return _pypl.plSerializer_set_name(self, *args)

    def get_name(self):
        """get_name(plSerializer self) -> std::string const &"""
        return _pypl.plSerializer_get_name(self)

    def get_strict_mode():
        """get_strict_mode() -> bool"""
        return _pypl.plSerializer_get_strict_mode()

    if _newclass:get_strict_mode = staticmethod(get_strict_mode)
    __swig_getmethods__["get_strict_mode"] = lambda x: get_strict_mode
    def set_strict_mode(*args):
        """set_strict_mode(bool m)"""
        return _pypl.plSerializer_set_strict_mode(*args)

    if _newclass:set_strict_mode = staticmethod(set_strict_mode)
    __swig_getmethods__["set_strict_mode"] = lambda x: set_strict_mode
    def check_s11n_version_compatibility(*args):
        """check_s11n_version_compatibility(std::string const & s11n_file_version) -> bool"""
        return _pypl.plSerializer_check_s11n_version_compatibility(*args)

    if _newclass:check_s11n_version_compatibility = staticmethod(check_s11n_version_compatibility)
    __swig_getmethods__["check_s11n_version_compatibility"] = lambda x: check_s11n_version_compatibility
    def get_s11n_compatibility_version(*args):
        """get_s11n_compatibility_version(plVersion probt_version) -> unsigned int"""
        return _pypl.plSerializer_get_s11n_compatibility_version(*args)

    if _newclass:get_s11n_compatibility_version = staticmethod(get_s11n_compatibility_version)
    __swig_getmethods__["get_s11n_compatibility_version"] = lambda x: get_s11n_compatibility_version
    __swig_destroy__ = _pypl.delete_plSerializer
    __del__ = lambda self : None;
plSerializer_swigregister = _pypl.plSerializer_swigregister
plSerializer_swigregister(plSerializer)

def plSerializer_get_strict_mode():
  """plSerializer_get_strict_mode() -> bool"""
  return _pypl.plSerializer_get_strict_mode()

def plSerializer_set_strict_mode(*args):
  """plSerializer_set_strict_mode(bool m)"""
  return _pypl.plSerializer_set_strict_mode(*args)

def plSerializer_check_s11n_version_compatibility(*args):
  """plSerializer_check_s11n_version_compatibility(std::string const & s11n_file_version) -> bool"""
  return _pypl.plSerializer_check_s11n_version_compatibility(*args)

def plSerializer_get_s11n_compatibility_version(*args):
  """plSerializer_get_s11n_compatibility_version(plVersion probt_version) -> unsigned int"""
  return _pypl.plSerializer_get_s11n_compatibility_version(*args)

def serialize_to_string(the_dict, name='untitled'):
  '''
  Input: a dictionary of plObject instances.
  Output: the XML archive as a string.
  '''
  serializer = plSerializer(the_dict, name)
  return serializer.save_to_string()

def deserialize_from_string(the_string):
  '''
  Input: an XML archive as a string.
  Output: a dictionary of plObject instances.
  '''
  serializer = plSerializer()
  serializer.load_from_string(the_string)
  return serializer.get_all_objects_map()

# This file is compatible with both classic and new-style classes.


